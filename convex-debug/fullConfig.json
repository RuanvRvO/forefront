{"projectConfig":{"functions":"convex/","node":{"externalPackages":[]},"generateCommonJSApi":false,"codegen":{"staticApi":false,"staticDataModel":false}},"modules":[{"path":"auth.js","source":"import {\n  a,\n  b,\n  c,\n  d,\n  e\n} from \"./_deps/ZY6YXHCM.js\";\nimport \"./_deps/HCQKE6P2.js\";\nimport \"./_deps/Q5VBJYR5.js\";\nexport {\n  a as auth,\n  e as isAuthenticated,\n  b as signIn,\n  c as signOut,\n  d as store\n};\n//# sourceMappingURL=auth.js.map\n","environment":"isolate","sourceMap":"{\n  \"version\": 3,\n  \"sources\": [],\n  \"mappings\": \"\",\n  \"names\": []\n}\n"},{"path":"codaSync.js","source":"import {\n  b as a\n} from \"./_deps/MIBXW62M.js\";\nimport {\n  d as l,\n  e as d\n} from \"./_deps/TRX5I57W.js\";\nimport {\n  a as o\n} from \"./_deps/Q5VBJYR5.js\";\n\n// convex/codaSync.ts\nvar C = d({\n  args: {},\n  handler: /* @__PURE__ */ o(async (n) => {\n    let r = process.env.CODA_API_TOKEN, c = process.env.CODA_DOC_ID, i = process.env.CODA_TABLE_ID;\n    if (!r || !c || !i)\n      return console.error(\"Coda credentials not configured\"), { success: !1, error: \"Coda credentials not configured\" };\n    try {\n      let s = await fetch(\n        `https://coda.io/apis/v1/docs/${c}/tables/${i}/rows`,\n        {\n          headers: {\n            Authorization: `Bearer ${r}`\n          }\n        }\n      );\n      if (!s.ok)\n        throw new Error(`Coda API error: ${s.statusText}`);\n      let t = (await s.json()).items.map((e) => ({\n        codaId: e.id,\n        title: e.values[\"c-title\"] || e.values.Title || \"\",\n        description: e.values[\"c-description\"] || e.values.Description || \"\",\n        date: e.values[\"c-date\"] || e.values.Date || \"\",\n        time: e.values[\"c-time\"] || e.values.Time || \"\",\n        location: e.values[\"c-location\"] || e.values.Location || \"\",\n        type: e.values[\"c-type\"] || e.values.Type || \"Online\"\n      }));\n      return await n.runMutation(a.meetings.syncMeetingsFromCoda, {\n        meetings: t\n      }), console.log(`Successfully synced ${t.length} meetings from Coda`), { success: !0, synced: t.length };\n    } catch (s) {\n      return console.error(\"Error syncing from Coda:\", s), { success: !1, error: String(s) };\n    }\n  }, \"handler\")\n}), p = l({\n  args: {},\n  handler: /* @__PURE__ */ o(async (n) => await n.runAction(a.codaSync.syncMeetingsFromCodaAction, {}), \"handler\")\n});\nexport {\n  p as manualSyncFromCoda,\n  C as syncMeetingsFromCodaAction\n};\n//# sourceMappingURL=codaSync.js.map\n","environment":"isolate","sourceMap":"{\n  \"version\": 3,\n  \"sources\": [\"../convex/codaSync.ts\"],\n  \"mappings\": \";;;;;;;;;;;;AAUO,IAAMA,IAA6BC,EAAe;AAAA,EACvD,MAAM,CAAC;AAAA,EACP,SAAS,gBAAAC,EAAA,OAAOC,MAAQ;AAGtB,QAAMC,IAAiB,QAAQ,IAAI,gBAC7BC,IAAc,QAAQ,IAAI,aAC1BC,IAAgB,QAAQ,IAAI;AAElC,QAAI,CAACF,KAAkB,CAACC,KAAe,CAACC;AACtC,qBAAQ,MAAM,iCAAiC,GACxC,EAAE,SAAS,IAAO,OAAO,kCAAkC;AAGpE,QAAI;AAEF,UAAMC,IAAW,MAAM;AAAA,QACrB,gCAAgCF,CAAW,WAAWC,CAAa;AAAA,QACnE;AAAA,UACE,SAAS;AAAA,YACP,eAAe,UAAUF,CAAc;AAAA,UACzC;AAAA,QACF;AAAA,MACF;AAEA,UAAI,CAACG,EAAS;AACZ,cAAM,IAAI,MAAM,mBAAmBA,EAAS,UAAU,EAAE;AAO1D,UAAMC,KAJO,MAAMD,EAAS,KAAK,GAIX,MAAM,IAAI,CAACE,OAAkB;AAAA,QACjD,QAAQA,EAAI;AAAA,QACZ,OAAOA,EAAI,OAAO,SAAS,KAAKA,EAAI,OAAO,SAAY;AAAA,QACvD,aAAaA,EAAI,OAAO,eAAe,KAAKA,EAAI,OAAO,eAAkB;AAAA,QACzE,MAAMA,EAAI,OAAO,QAAQ,KAAKA,EAAI,OAAO,QAAW;AAAA,QACpD,MAAMA,EAAI,OAAO,QAAQ,KAAKA,EAAI,OAAO,QAAW;AAAA,QACpD,UAAUA,EAAI,OAAO,YAAY,KAAKA,EAAI,OAAO,YAAe;AAAA,QAChE,MAAOA,EAAI,OAAO,QAAQ,KAAKA,EAAI,OAAO,QAAW;AAAA,MACvD,EAAE;AAGF,mBAAMN,EAAI,YAAYO,EAAS,SAAS,sBAAsB;AAAA,QAC5D,UAAAF;AAAA,MACF,CAAC,GAED,QAAQ,IAAI,uBAAuBA,EAAS,MAAM,qBAAqB,GAChE,EAAE,SAAS,IAAM,QAAQA,EAAS,OAAO;AAAA,IAClD,SAASG,GAAO;AACd,qBAAQ,MAAM,4BAA4BA,CAAK,GACxC,EAAE,SAAS,IAAO,OAAO,OAAOA,CAAK,EAAE;AAAA,IAChD;AAAA,EACF,GApDS;AAqDX,CAAC,GAGYC,IAAqBC,EAAO;AAAA,EACvC,MAAM,CAAC;AAAA,EACP,SAAS,gBAAAX,EAAA,OAAOC,MACP,MAAMA,EAAI,UAAUO,EAAS,SAAS,4BAA4B,CAAC,CAAC,GADpE;AAGX,CAAC;\",\n  \"names\": [\"syncMeetingsFromCodaAction\", \"internalAction\", \"__name\", \"ctx\", \"CODA_API_TOKEN\", \"CODA_DOC_ID\", \"CODA_TABLE_ID\", \"response\", \"meetings\", \"row\", \"internal\", \"error\", \"manualSyncFromCoda\", \"action\"]\n}\n"},{"path":"cron.js","source":"import {\n  b as n\n} from \"./_deps/MIBXW62M.js\";\nimport {\n  n as o\n} from \"./_deps/Q5VBJYR5.js\";\n\n// convex/cron.ts\nvar r = o();\nr.daily(\n  \"sync meetings from Coda\",\n  { hourUTC: 6, minuteUTC: 0 },\n  // 6 AM UTC\n  n.codaSync.syncMeetingsFromCodaAction\n);\nvar e = r;\nexport {\n  e as default\n};\n//# sourceMappingURL=cron.js.map\n","environment":"isolate","sourceMap":"{\n  \"version\": 3,\n  \"sources\": [\"../convex/cron.ts\"],\n  \"mappings\": \";;;;;;;;AAGA,IAAMA,IAAQC,EAAS;AAGvBD,EAAM;AAAA,EACJ;AAAA,EACA,EAAE,SAAS,GAAG,WAAW,EAAE;AAAA;AAAA,EAC3BE,EAAS,SAAS;AACpB;AAEA,IAAOC,IAAQH;\",\n  \"names\": [\"crons\", \"cronJobs\", \"internal\", \"cron_default\"]\n}\n"},{"path":"emailSubscribers.js","source":"import {\n  a as b,\n  b as t\n} from \"./_deps/TRX5I57W.js\";\nimport {\n  a as i,\n  e as s\n} from \"./_deps/Q5VBJYR5.js\";\n\n// convex/emailSubscribers.ts\nvar m = t({\n  args: {\n    email: s.string(),\n    source: s.optional(s.string())\n  },\n  handler: /* @__PURE__ */ i(async (e, r) => {\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(r.email))\n      throw new Error(\"Invalid email address\");\n    if (await e.db.query(\"emailSubscribers\").withIndex(\"by_email\", (c) => c.eq(\"email\", r.email)).first())\n      throw new Error(\"This email is already subscribed\");\n    return { success: !0, subscriberId: await e.db.insert(\"emailSubscribers\", {\n      email: r.email,\n      subscribedAt: Date.now(),\n      source: r.source || \"landing_page\"\n    }) };\n  }, \"handler\")\n}), d = b({\n  args: {},\n  handler: /* @__PURE__ */ i(async (e) => await e.db.query(\"emailSubscribers\").order(\"desc\").collect(), \"handler\")\n}), w = t({\n  args: {\n    email: s.string()\n  },\n  handler: /* @__PURE__ */ i(async (e, r) => {\n    let a = await e.db.query(\"emailSubscribers\").withIndex(\"by_email\", (n) => n.eq(\"email\", r.email)).first();\n    if (!a)\n      throw new Error(\"Email not found\");\n    return await e.db.delete(a._id), { success: !0 };\n  }, \"handler\")\n});\nexport {\n  d as listSubscribers,\n  m as subscribe,\n  w as unsubscribe\n};\n//# sourceMappingURL=emailSubscribers.js.map\n","environment":"isolate","sourceMap":"{\n  \"version\": 3,\n  \"sources\": [\"../convex/emailSubscribers.ts\"],\n  \"mappings\": \";;;;;;;;;;AAIO,IAAMA,IAAYC,EAAS;AAAA,EAChC,MAAM;AAAA,IACJ,OAAOC,EAAE,OAAO;AAAA,IAChB,QAAQA,EAAE,SAASA,EAAE,OAAO,CAAC;AAAA,EAC/B;AAAA,EACA,SAAS,gBAAAC,EAAA,OAAOC,GAAKC,MAAS;AAG5B,QAAI,CADe,6BACH,KAAKA,EAAK,KAAK;AAC7B,YAAM,IAAI,MAAM,uBAAuB;AASzC,QALiB,MAAMD,EAAI,GACxB,MAAM,kBAAkB,EACxB,UAAU,YAAY,CAACE,MAAMA,EAAE,GAAG,SAASD,EAAK,KAAK,CAAC,EACtD,MAAM;AAGP,YAAM,IAAI,MAAM,kCAAkC;AAUpD,WAAO,EAAE,SAAS,IAAM,cANH,MAAMD,EAAI,GAAG,OAAO,oBAAoB;AAAA,MAC3D,OAAOC,EAAK;AAAA,MACZ,cAAc,KAAK,IAAI;AAAA,MACvB,QAAQA,EAAK,UAAU;AAAA,IACzB,CAAC,EAEoC;AAAA,EACvC,GAzBS;AA0BX,CAAC,GAGYE,IAAkBC,EAAM;AAAA,EACnC,MAAM,CAAC;AAAA,EACP,SAAS,gBAAAL,EAAA,OAAOC,MACM,MAAMA,EAAI,GAC3B,MAAM,kBAAkB,EACxB,MAAM,MAAM,EACZ,QAAQ,GAJJ;AAQX,CAAC,GAGYK,IAAcR,EAAS;AAAA,EAClC,MAAM;AAAA,IACJ,OAAOC,EAAE,OAAO;AAAA,EAClB;AAAA,EACA,SAAS,gBAAAC,EAAA,OAAOC,GAAKC,MAAS;AAC5B,QAAMK,IAAa,MAAMN,EAAI,GAC1B,MAAM,kBAAkB,EACxB,UAAU,YAAY,CAACE,MAAMA,EAAE,GAAG,SAASD,EAAK,KAAK,CAAC,EACtD,MAAM;AAET,QAAI,CAACK;AACH,YAAM,IAAI,MAAM,iBAAiB;AAGnC,iBAAMN,EAAI,GAAG,OAAOM,EAAW,GAAG,GAC3B,EAAE,SAAS,GAAK;AAAA,EACzB,GAZS;AAaX,CAAC;\",\n  \"names\": [\"subscribe\", \"mutation\", \"v\", \"__name\", \"ctx\", \"args\", \"q\", \"listSubscribers\", \"query\", \"unsubscribe\", \"subscriber\"]\n}\n"},{"path":"http.js","source":"import {\n  a as o\n} from \"./_deps/ZY6YXHCM.js\";\nimport \"./_deps/HCQKE6P2.js\";\nimport {\n  o as t\n} from \"./_deps/Q5VBJYR5.js\";\n\n// convex/http.ts\nvar p = t();\no.addHttpRoutes(p);\nvar m = p;\nexport {\n  m as default\n};\n//# sourceMappingURL=http.js.map\n","environment":"isolate","sourceMap":"{\n  \"version\": 3,\n  \"sources\": [\"../convex/http.ts\"],\n  \"mappings\": \";;;;;;;;;AAGA,IAAMA,IAAOC,EAAW;AAExBC,EAAK,cAAcF,CAAI;AAEvB,IAAOG,IAAQH;\",\n  \"names\": [\"http\", \"httpRouter\", \"auth\", \"http_default\"]\n}\n"},{"path":"_deps/ZY6YXHCM.js","source":"import {\n  a as $,\n  b as _,\n  c as X,\n  e as G,\n  f as M,\n  g as J,\n  h as Q,\n  i as F\n} from \"./HCQKE6P2.js\";\nimport {\n  a\n} from \"./Q5VBJYR5.js\";\n\n// node_modules/@convex-dev/auth/dist/providers/ConvexCredentials.js\nfunction Y(e) {\n  return {\n    id: \"credentials\",\n    type: \"credentials\",\n    authorize: /* @__PURE__ */ a(async () => null, \"authorize\"),\n    // @ts-expect-error Internal\n    options: e\n  };\n}\na(Y, \"ConvexCredentials\");\n\n// node_modules/@oslojs/crypto/dist/subtle/index.js\nfunction Z(e, r) {\n  if (e.length !== r.length)\n    return !1;\n  let s = 0;\n  for (let t = 0; t < e.length; t++)\n    s |= e[t] ^ r[t];\n  return s === 0;\n}\na(Z, \"constantTimeEqual\");\n\n// node_modules/lucia/dist/scrypt/index.js\nasync function se(e, r, s) {\n  let { N: t, r: n, p: i } = s, u = s.dkLen ?? 32, c = 1024 ** 3 + 1024, d = 128 * n, f = d / 4;\n  if (t <= 1 || (t & t - 1) !== 0 || t >= 2 ** (d / 8) || t > 2 ** 32)\n    throw new Error(\"Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32\");\n  if (i < 0 || i > (2 ** 32 - 1) * 32 / d)\n    throw new Error(\"Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)\");\n  if (u < 0 || u > (2 ** 32 - 1) * 32)\n    throw new Error(\"Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32\");\n  let y = d * (t + i);\n  if (y > c)\n    throw new Error(`Scrypt: parameters too large, ${y} (128 * r * (N + p)) > ${c} (maxmem)`);\n  let l = await te(e, r, { c: 1, dkLen: d * i }), p = H(l), w = H(new Uint8Array(d * t)), x = H(new Uint8Array(d));\n  for (let V = 0; V < i; V++) {\n    let k = f * V;\n    for (let h = 0; h < f; h++)\n      w[h] = p[k + h];\n    for (let h = 0, S = 0; h < t - 1; h++)\n      O(w, S, w, S += f, n), await new Promise((m) => m());\n    O(w, (t - 1) * f, p, k, n);\n    for (let h = 0; h < t; h++) {\n      let S = p[k + f - 16] % t;\n      for (let m = 0; m < f; m++)\n        x[m] = p[k + m] ^ w[S * f + m];\n      O(x, 0, p, k, n), await new Promise((m) => m());\n    }\n  }\n  let T = await te(e, l, { c: 1, dkLen: u });\n  return l.fill(0), w.fill(0), x.fill(0), T;\n}\na(se, \"scrypt\");\nfunction o(e, r) {\n  return e << r | e >>> 32 - r;\n}\na(o, \"rotl\");\nfunction ee(e, r, s, t, n, i) {\n  let u = e[r++] ^ s[t++], c = e[r++] ^ s[t++], d = e[r++] ^ s[t++], f = e[r++] ^ s[t++], y = e[r++] ^ s[t++], l = e[r++] ^ s[t++], p = e[r++] ^ s[t++], w = e[r++] ^ s[t++], x = e[r++] ^ s[t++], T = e[r++] ^ s[t++], V = e[r++] ^ s[t++], k = e[r++] ^ s[t++], h = e[r++] ^ s[t++], S = e[r++] ^ s[t++], m = e[r++] ^ s[t++], j = e[r++] ^ s[t++], g = u, A = c, C = d, E = f, I = y, v = l, b = p, U = w, P = x, N = T, R = V, z = k, B = h, K = S, L = m, D = j;\n  for (let W = 0; W < 8; W += 2)\n    I ^= o(g + B | 0, 7), P ^= o(I + g | 0, 9), B ^= o(P + I | 0, 13), g ^= o(B + P | 0, 18), N ^= o(v + A | 0, 7), K ^= o(N + v | 0, 9), A ^= o(K + N | 0, 13), v ^= o(A + K | 0, 18), L ^= o(R + b | 0, 7), C ^= o(L + R | 0, 9), b ^= o(C + L | 0, 13), R ^= o(b + C | 0, 18), E ^= o(D + z | 0, 7), U ^= o(E + D | 0, 9), z ^= o(U + E | 0, 13), D ^= o(z + U | 0, 18), A ^= o(g + E | 0, 7), C ^= o(A + g | 0, 9), E ^= o(C + A | 0, 13), g ^= o(E + C | 0, 18), b ^= o(v + I | 0, 7), U ^= o(b + v | 0, 9), I ^= o(U + b | 0, 13), v ^= o(I + U | 0, 18), z ^= o(R + N | 0, 7), P ^= o(z + R | 0, 9), N ^= o(P + z | 0, 13), R ^= o(N + P | 0, 18), B ^= o(D + L | 0, 7), K ^= o(B + D | 0, 9), L ^= o(K + B | 0, 13), D ^= o(L + K | 0, 18);\n  n[i++] = u + g | 0, n[i++] = c + A | 0, n[i++] = d + C | 0, n[i++] = f + E | 0, n[i++] = y + I | 0, n[i++] = l + v | 0, n[i++] = p + b | 0, n[i++] = w + U | 0, n[i++] = x + P | 0, n[i++] = T + N | 0, n[i++] = V + R | 0, n[i++] = k + z | 0, n[i++] = h + B | 0, n[i++] = S + K | 0, n[i++] = m + L | 0, n[i++] = j + D | 0;\n}\na(ee, \"XorAndSalsa\");\nasync function te(e, r, s) {\n  let t = await crypto.subtle.importKey(\"raw\", e, \"PBKDF2\", !1, [\"deriveBits\"]), n = await crypto.subtle.deriveBits({\n    name: \"PBKDF2\",\n    hash: \"SHA-256\",\n    salt: r,\n    iterations: s.c\n  }, t, s.dkLen * 8);\n  return new Uint8Array(n);\n}\na(te, \"pbkdf2\");\nfunction O(e, r, s, t, n) {\n  let i = t + 0, u = t + 16 * n;\n  for (let c = 0; c < 16; c++)\n    s[u + c] = e[r + (2 * n - 1) * 16 + c];\n  for (let c = 0; c < n; c++, i += 16, r += 16)\n    ee(s, u, e, r, s, i), c > 0 && (u += 16), ee(s, i, e, r += 16, s, u);\n}\na(O, \"BlockMix\");\nfunction H(e) {\n  return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));\n}\na(H, \"u32\");\n\n// node_modules/lucia/dist/crypto.js\nasync function re(e, r, s = 16) {\n  let t = new TextEncoder().encode(e), n = new TextEncoder().encode(r), i = await se(t, n, {\n    N: 16384,\n    r: s,\n    p: 1,\n    dkLen: 64\n  });\n  return new Uint8Array(i);\n}\na(re, \"generateScryptKey\");\nvar q = class {\n  static {\n    a(this, \"Scrypt\");\n  }\n  async hash(r) {\n    let s = $(crypto.getRandomValues(new Uint8Array(16))), t = await re(r.normalize(\"NFKC\"), s);\n    return `${s}:${$(t)}`;\n  }\n  async verify(r, s) {\n    let t = r.split(\":\");\n    if (t.length !== 2)\n      return !1;\n    let [n, i] = t, u = await re(s.normalize(\"NFKC\"), n);\n    return Z(u, _(i));\n  }\n};\n\n// node_modules/@convex-dev/auth/dist/providers/Password.js\nfunction ne(e = {}) {\n  let r = e.id ?? \"password\";\n  return Y({\n    id: \"password\",\n    authorize: /* @__PURE__ */ a(async (s, t) => {\n      let n = s.flow, i = n === \"signUp\" ? s.password : n === \"reset-verification\" ? s.newPassword : null;\n      i !== null && (e.validatePasswordRequirements !== void 0 ? e.validatePasswordRequirements(i) : ae(i));\n      let u = e.profile?.(s, t) ?? ce(s), { email: c } = u, d = s.password, f, y;\n      if (n === \"signUp\") {\n        if (d === void 0)\n          throw new Error(\"Missing `password` param for `signUp` flow\");\n        ({ account: f, user: y } = await G(t, {\n          provider: r,\n          account: { id: c, secret: d },\n          profile: u,\n          shouldLinkViaEmail: e.verify !== void 0,\n          shouldLinkViaPhone: !1\n        }));\n      } else if (n === \"signIn\") {\n        if (d === void 0)\n          throw new Error(\"Missing `password` param for `signIn` flow\");\n        let l = await M(t, {\n          provider: r,\n          account: { id: c, secret: d }\n        });\n        if (l === null)\n          throw new Error(\"Invalid credentials\");\n        ({ account: f, user: y } = l);\n      } else if (n === \"reset\") {\n        if (!e.reset)\n          throw new Error(`Password reset is not enabled for ${r}`);\n        let { account: l } = await M(t, {\n          provider: r,\n          account: { id: c }\n        });\n        return await F(t, e.reset, {\n          accountId: l._id,\n          params: s\n        });\n      } else if (n === \"reset-verification\") {\n        if (!e.reset)\n          throw new Error(`Password reset is not enabled for ${r}`);\n        if (s.newPassword === void 0)\n          throw new Error(\"Missing `newPassword` param for `reset-verification` flow\");\n        let l = await F(t, e.reset, { params: s });\n        if (l === null)\n          throw new Error(\"Invalid code\");\n        let { userId: p, sessionId: w } = l, x = s.newPassword;\n        return await J(t, {\n          provider: r,\n          account: { id: c, secret: x }\n        }), await Q(t, { userId: p, except: [w] }), { userId: p, sessionId: w };\n      } else if (n === \"email-verification\") {\n        if (!e.verify)\n          throw new Error(`Email verification is not enabled for ${r}`);\n        let { account: l } = await M(t, {\n          provider: r,\n          account: { id: c }\n        });\n        return await F(t, e.verify, {\n          accountId: l._id,\n          params: s\n        });\n      } else\n        throw new Error('Missing `flow` param, it must be one of \"signUp\", \"signIn\", \"reset\", \"reset-verification\" or \"email-verification\"!');\n      return e.verify && !f.emailVerified ? await F(t, e.verify, {\n        accountId: f._id,\n        params: s\n      }) : { userId: y._id };\n    }, \"authorize\"),\n    crypto: {\n      async hashSecret(s) {\n        return await new q().hash(s);\n      },\n      async verifySecret(s, t) {\n        return await new q().verify(t, s);\n      }\n    },\n    extraProviders: [e.reset, e.verify],\n    ...e\n  });\n}\na(ne, \"Password\");\nfunction ae(e) {\n  if (!e || e.length < 8)\n    throw new Error(\"Invalid password\");\n}\na(ae, \"validateDefaultPasswordRequirements\");\nfunction ce(e) {\n  return {\n    email: e.email\n  };\n}\na(ce, \"defaultProfile\");\n\n// convex/auth.ts\nvar { auth: tt, signIn: st, signOut: rt, store: nt, isAuthenticated: it } = X({\n  providers: [ne]\n});\n\nexport {\n  tt as a,\n  st as b,\n  rt as c,\n  nt as d,\n  it as e\n};\n//# sourceMappingURL=ZY6YXHCM.js.map\n","environment":"isolate"},{"path":"meetings.js","source":"import {\n  a as l,\n  b as d,\n  c\n} from \"./_deps/TRX5I57W.js\";\nimport {\n  a as o,\n  e as t\n} from \"./_deps/Q5VBJYR5.js\";\n\n// convex/meetings.ts\nvar y = l({\n  args: {},\n  handler: /* @__PURE__ */ o(async (n) => await n.db.query(\"meetings\").order(\"desc\").collect(), \"handler\")\n}), I = d({\n  args: {\n    title: t.string(),\n    description: t.string(),\n    date: t.string(),\n    time: t.string(),\n    location: t.string(),\n    type: t.union(t.literal(\"Online\"), t.literal(\"In-Person\")),\n    codaId: t.optional(t.string())\n  },\n  handler: /* @__PURE__ */ o(async (n, i) => await n.db.insert(\"meetings\", {\n    title: i.title,\n    description: i.description,\n    date: i.date,\n    time: i.time,\n    location: i.location,\n    type: i.type,\n    codaId: i.codaId\n  }), \"handler\")\n}), u = d({\n  args: {\n    id: t.id(\"meetings\"),\n    title: t.optional(t.string()),\n    description: t.optional(t.string()),\n    date: t.optional(t.string()),\n    time: t.optional(t.string()),\n    location: t.optional(t.string()),\n    type: t.optional(t.union(t.literal(\"Online\"), t.literal(\"In-Person\")))\n  },\n  handler: /* @__PURE__ */ o(async (n, i) => {\n    let { id: a, ...s } = i;\n    await n.db.patch(a, s);\n  }, \"handler\")\n}), b = d({\n  args: {\n    id: t.id(\"meetings\")\n  },\n  handler: /* @__PURE__ */ o(async (n, i) => {\n    await n.db.delete(i.id);\n  }, \"handler\")\n}), f = c({\n  args: {\n    meetings: t.array(\n      t.object({\n        codaId: t.string(),\n        title: t.string(),\n        description: t.string(),\n        date: t.string(),\n        time: t.string(),\n        location: t.string(),\n        type: t.union(t.literal(\"Online\"), t.literal(\"In-Person\"))\n      })\n    )\n  },\n  handler: /* @__PURE__ */ o(async (n, i) => {\n    let a = await n.db.query(\"meetings\").collect(), s = new Set(i.meetings.map((e) => e.codaId));\n    for (let e of a)\n      e.codaId && !s.has(e.codaId) && await n.db.delete(e._id);\n    for (let e of i.meetings) {\n      let r = a.find((g) => g.codaId === e.codaId);\n      r ? await n.db.patch(r._id, {\n        title: e.title,\n        description: e.description,\n        date: e.date,\n        time: e.time,\n        location: e.location,\n        type: e.type\n      }) : await n.db.insert(\"meetings\", {\n        title: e.title,\n        description: e.description,\n        date: e.date,\n        time: e.time,\n        location: e.location,\n        type: e.type,\n        codaId: e.codaId\n      });\n    }\n    return { synced: i.meetings.length };\n  }, \"handler\")\n});\nexport {\n  I as addMeeting,\n  b as deleteMeeting,\n  y as listMeetings,\n  f as syncMeetingsFromCoda,\n  u as updateMeeting\n};\n//# sourceMappingURL=meetings.js.map\n","environment":"isolate","sourceMap":"{\n  \"version\": 3,\n  \"sources\": [\"../convex/meetings.ts\"],\n  \"mappings\": \";;;;;;;;;;;AAIO,IAAMA,IAAeC,EAAM;AAAA,EAChC,MAAM,CAAC;AAAA,EACP,SAAS,gBAAAC,EAAA,OAAOC,MACG,MAAMA,EAAI,GACxB,MAAM,UAAU,EAChB,MAAM,MAAM,EACZ,QAAQ,GAJJ;AAQX,CAAC,GAGYC,IAAaC,EAAS;AAAA,EACjC,MAAM;AAAA,IACJ,OAAOC,EAAE,OAAO;AAAA,IAChB,aAAaA,EAAE,OAAO;AAAA,IACtB,MAAMA,EAAE,OAAO;AAAA,IACf,MAAMA,EAAE,OAAO;AAAA,IACf,UAAUA,EAAE,OAAO;AAAA,IACnB,MAAMA,EAAE,MAAMA,EAAE,QAAQ,QAAQ,GAAGA,EAAE,QAAQ,WAAW,CAAC;AAAA,IACzD,QAAQA,EAAE,SAASA,EAAE,OAAO,CAAC;AAAA,EAC/B;AAAA,EACA,SAAS,gBAAAJ,EAAA,OAAOC,GAAKI,MACD,MAAMJ,EAAI,GAAG,OAAO,YAAY;AAAA,IAChD,OAAOI,EAAK;AAAA,IACZ,aAAaA,EAAK;AAAA,IAClB,MAAMA,EAAK;AAAA,IACX,MAAMA,EAAK;AAAA,IACX,UAAUA,EAAK;AAAA,IACf,MAAMA,EAAK;AAAA,IACX,QAAQA,EAAK;AAAA,EACf,CAAC,GATM;AAYX,CAAC,GAGYC,IAAgBH,EAAS;AAAA,EACpC,MAAM;AAAA,IACJ,IAAIC,EAAE,GAAG,UAAU;AAAA,IACnB,OAAOA,EAAE,SAASA,EAAE,OAAO,CAAC;AAAA,IAC5B,aAAaA,EAAE,SAASA,EAAE,OAAO,CAAC;AAAA,IAClC,MAAMA,EAAE,SAASA,EAAE,OAAO,CAAC;AAAA,IAC3B,MAAMA,EAAE,SAASA,EAAE,OAAO,CAAC;AAAA,IAC3B,UAAUA,EAAE,SAASA,EAAE,OAAO,CAAC;AAAA,IAC/B,MAAMA,EAAE,SAASA,EAAE,MAAMA,EAAE,QAAQ,QAAQ,GAAGA,EAAE,QAAQ,WAAW,CAAC,CAAC;AAAA,EACvE;AAAA,EACA,SAAS,gBAAAJ,EAAA,OAAOC,GAAKI,MAAS;AAC5B,QAAM,EAAE,IAAAE,GAAI,GAAGC,EAAQ,IAAIH;AAC3B,UAAMJ,EAAI,GAAG,MAAMM,GAAIC,CAAO;AAAA,EAChC,GAHS;AAIX,CAAC,GAGYC,IAAgBN,EAAS;AAAA,EACpC,MAAM;AAAA,IACJ,IAAIC,EAAE,GAAG,UAAU;AAAA,EACrB;AAAA,EACA,SAAS,gBAAAJ,EAAA,OAAOC,GAAKI,MAAS;AAC5B,UAAMJ,EAAI,GAAG,OAAOI,EAAK,EAAE;AAAA,EAC7B,GAFS;AAGX,CAAC,GAIYK,IAAuBC,EAAiB;AAAA,EACnD,MAAM;AAAA,IACJ,UAAUP,EAAE;AAAA,MACVA,EAAE,OAAO;AAAA,QACP,QAAQA,EAAE,OAAO;AAAA,QACjB,OAAOA,EAAE,OAAO;AAAA,QAChB,aAAaA,EAAE,OAAO;AAAA,QACtB,MAAMA,EAAE,OAAO;AAAA,QACf,MAAMA,EAAE,OAAO;AAAA,QACf,UAAUA,EAAE,OAAO;AAAA,QACnB,MAAMA,EAAE,MAAMA,EAAE,QAAQ,QAAQ,GAAGA,EAAE,QAAQ,WAAW,CAAC;AAAA,MAC3D,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,SAAS,gBAAAJ,EAAA,OAAOC,GAAKI,MAAS;AAE5B,QAAMO,IAAmB,MAAMX,EAAI,GAAG,MAAM,UAAU,EAAE,QAAQ,GAE1DY,IAAU,IAAI,IAAIR,EAAK,SAAS,IAAI,CAACS,MAAMA,EAAE,MAAM,CAAC;AAG1D,aAAWC,KAAWH;AACpB,MAAIG,EAAQ,UAAU,CAACF,EAAQ,IAAIE,EAAQ,MAAM,KAC/C,MAAMd,EAAI,GAAG,OAAOc,EAAQ,GAAG;AAKnC,aAAWA,KAAWV,EAAK,UAAU;AACnC,UAAMW,IAAWJ,EAAiB,KAAK,CAACE,MAAMA,EAAE,WAAWC,EAAQ,MAAM;AAEzE,MAAIC,IAEF,MAAMf,EAAI,GAAG,MAAMe,EAAS,KAAK;AAAA,QAC/B,OAAOD,EAAQ;AAAA,QACf,aAAaA,EAAQ;AAAA,QACrB,MAAMA,EAAQ;AAAA,QACd,MAAMA,EAAQ;AAAA,QACd,UAAUA,EAAQ;AAAA,QAClB,MAAMA,EAAQ;AAAA,MAChB,CAAC,IAGD,MAAMd,EAAI,GAAG,OAAO,YAAY;AAAA,QAC9B,OAAOc,EAAQ;AAAA,QACf,aAAaA,EAAQ;AAAA,QACrB,MAAMA,EAAQ;AAAA,QACd,MAAMA,EAAQ;AAAA,QACd,UAAUA,EAAQ;AAAA,QAClB,MAAMA,EAAQ;AAAA,QACd,QAAQA,EAAQ;AAAA,MAClB,CAAC;AAAA,IAEL;AAEA,WAAO,EAAE,QAAQV,EAAK,SAAS,OAAO;AAAA,EACxC,GA1CS;AA2CX,CAAC;\",\n  \"names\": [\"listMeetings\", \"query\", \"__name\", \"ctx\", \"addMeeting\", \"mutation\", \"v\", \"args\", \"updateMeeting\", \"id\", \"updates\", \"deleteMeeting\", \"syncMeetingsFromCoda\", \"internalMutation\", \"existingMeetings\", \"codaIds\", \"m\", \"meeting\", \"existing\"]\n}\n"},{"path":"myFunctions.js","source":"import {\n  a as u\n} from \"./_deps/MIBXW62M.js\";\nimport {\n  d as o\n} from \"./_deps/HCQKE6P2.js\";\nimport {\n  a as i,\n  b as m,\n  d\n} from \"./_deps/TRX5I57W.js\";\nimport {\n  a as s,\n  e as t\n} from \"./_deps/Q5VBJYR5.js\";\n\n// convex/myFunctions.ts\nvar g = i({\n  // Validators for arguments.\n  args: {\n    count: t.number()\n  },\n  // Query implementation.\n  handler: /* @__PURE__ */ s(async (e, r) => {\n    let n = await e.db.query(\"numbers\").order(\"desc\").take(r.count), a = await o(e);\n    return {\n      viewer: (a === null ? null : await e.db.get(\"users\", a))?.email ?? null,\n      numbers: n.reverse().map((l) => l.value)\n    };\n  }, \"handler\")\n}), v = m({\n  // Validators for arguments.\n  args: {\n    value: t.number()\n  },\n  // Mutation implementation.\n  handler: /* @__PURE__ */ s(async (e, r) => {\n    let n = await e.db.insert(\"numbers\", { value: r.value });\n    console.log(\"Added new document with id:\", n);\n  }, \"handler\")\n}), f = d({\n  // Validators for arguments.\n  args: {\n    first: t.number(),\n    second: t.string()\n  },\n  // Action implementation.\n  handler: /* @__PURE__ */ s(async (e, r) => {\n    let n = await e.runQuery(u.myFunctions.listNumbers, {\n      count: 10\n    });\n    console.log(n), await e.runMutation(u.myFunctions.addNumber, {\n      value: r.first\n    });\n  }, \"handler\")\n});\nexport {\n  v as addNumber,\n  g as listNumbers,\n  f as myAction\n};\n//# sourceMappingURL=myFunctions.js.map\n","environment":"isolate","sourceMap":"{\n  \"version\": 3,\n  \"sources\": [\"../convex/myFunctions.ts\"],\n  \"mappings\": \";;;;;;;;;;;;;;;;;AASO,IAAMA,IAAcC,EAAM;AAAA;AAAA,EAE/B,MAAM;AAAA,IACJ,OAAOC,EAAE,OAAO;AAAA,EAClB;AAAA;AAAA,EAGA,SAAS,gBAAAC,EAAA,OAAOC,GAAKC,MAAS;AAG5B,QAAMC,IAAU,MAAMF,EAAI,GACvB,MAAM,SAAS,EAEf,MAAM,MAAM,EACZ,KAAKC,EAAK,KAAK,GACZE,IAAS,MAAMC,EAAcJ,CAAG;AAEtC,WAAO;AAAA,MACL,SAFWG,MAAW,OAAO,OAAO,MAAMH,EAAI,GAAG,IAAI,SAASG,CAAM,IAEtD,SAAS;AAAA,MACvB,SAASD,EAAQ,QAAQ,EAAE,IAAI,CAACG,MAAWA,EAAO,KAAK;AAAA,IACzD;AAAA,EACF,GAdS;AAeX,CAAC,GAGYC,IAAYC,EAAS;AAAA;AAAA,EAEhC,MAAM;AAAA,IACJ,OAAOT,EAAE,OAAO;AAAA,EAClB;AAAA;AAAA,EAGA,SAAS,gBAAAC,EAAA,OAAOC,GAAKC,MAAS;AAK5B,QAAMO,IAAK,MAAMR,EAAI,GAAG,OAAO,WAAW,EAAE,OAAOC,EAAK,MAAM,CAAC;AAE/D,YAAQ,IAAI,+BAA+BO,CAAE;AAAA,EAG/C,GAVS;AAWX,CAAC,GAGYC,IAAWC,EAAO;AAAA;AAAA,EAE7B,MAAM;AAAA,IACJ,OAAOZ,EAAE,OAAO;AAAA,IAChB,QAAQA,EAAE,OAAO;AAAA,EACnB;AAAA;AAAA,EAGA,SAAS,gBAAAC,EAAA,OAAOC,GAAKC,MAAS;AAO5B,QAAMU,IAAO,MAAMX,EAAI,SAASY,EAAI,YAAY,aAAa;AAAA,MAC3D,OAAO;AAAA,IACT,CAAC;AACD,YAAQ,IAAID,CAAI,GAGhB,MAAMX,EAAI,YAAYY,EAAI,YAAY,WAAW;AAAA,MAC/C,OAAOX,EAAK;AAAA,IACd,CAAC;AAAA,EACH,GAhBS;AAiBX,CAAC;\",\n  \"names\": [\"listNumbers\", \"query\", \"v\", \"__name\", \"ctx\", \"args\", \"numbers\", \"userId\", \"getAuthUserId\", \"number\", \"addNumber\", \"mutation\", \"id\", \"myAction\", \"action\", \"data\", \"api\"]\n}\n"},{"path":"_deps/MIBXW62M.js","source":"import {\n  m as o,\n  p as n\n} from \"./Q5VBJYR5.js\";\n\n// convex/_generated/api.js\nvar e = o, p = o, r = n();\n\nexport {\n  e as a,\n  p as b\n};\n//# sourceMappingURL=MIBXW62M.js.map\n","environment":"isolate"},{"path":"_deps/HCQKE6P2.js","source":"import {\n  a as o,\n  b as Da,\n  c as Wo,\n  d as Ka,\n  e as h,\n  f as $o,\n  h as Bo,\n  i as Jo,\n  j as un,\n  l as rt\n} from \"./Q5VBJYR5.js\";\n\n// node_modules/cookie/dist/index.js\nvar Fo = Da((ne) => {\n  \"use strict\";\n  Object.defineProperty(ne, \"__esModule\", { value: !0 });\n  ne.parseCookie = jo;\n  ne.parse = jo;\n  ne.stringifyCookie = Ma;\n  ne.stringifySetCookie = Pt;\n  ne.serialize = Pt;\n  ne.parseSetCookie = za;\n  ne.stringifySetCookie = Pt;\n  ne.serialize = Pt;\n  var Mo = /^[\\u0021-\\u003A\\u003C\\u003E-\\u007E]+$/, zo = /^[\\u0021-\\u003A\\u003C-\\u007E]*$/, Na = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, Wa = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/, $a = /^-?\\d+$/, Ba = Object.prototype.toString, Ja = /* @__PURE__ */ (() => {\n    let e = /* @__PURE__ */ o(function() {\n    }, \"C\");\n    return e.prototype = /* @__PURE__ */ Object.create(null), e;\n  })();\n  function jo(e, t) {\n    let r = new Ja(), n = e.length;\n    if (n < 2)\n      return r;\n    let i = t?.decode || Vo, s = 0;\n    do {\n      let a = ln(e, s, n);\n      if (a === -1)\n        break;\n      let c = dn(e, s, n);\n      if (a > c) {\n        s = e.lastIndexOf(\";\", a - 1) + 1;\n        continue;\n      }\n      let d = fe(e, s, a);\n      r[d] === void 0 && (r[d] = i(fe(e, a + 1, c))), s = c + 1;\n    } while (s < n);\n    return r;\n  }\n  o(jo, \"parseCookie\");\n  function Ma(e, t) {\n    let r = t?.encode || encodeURIComponent, n = [];\n    for (let i of Object.keys(e)) {\n      let s = e[i];\n      if (s === void 0)\n        continue;\n      if (!Mo.test(i))\n        throw new TypeError(`cookie name is invalid: ${i}`);\n      let a = r(s);\n      if (!zo.test(a))\n        throw new TypeError(`cookie val is invalid: ${s}`);\n      n.push(`${i}=${a}`);\n    }\n    return n.join(\"; \");\n  }\n  o(Ma, \"stringifyCookie\");\n  function Pt(e, t, r) {\n    let n = typeof e == \"object\" ? e : { ...r, name: e, value: String(t) }, s = (typeof t == \"object\" ? t : r)?.encode || encodeURIComponent;\n    if (!Mo.test(n.name))\n      throw new TypeError(`argument name is invalid: ${n.name}`);\n    let a = n.value ? s(n.value) : \"\";\n    if (!zo.test(a))\n      throw new TypeError(`argument val is invalid: ${n.value}`);\n    let c = n.name + \"=\" + a;\n    if (n.maxAge !== void 0) {\n      if (!Number.isInteger(n.maxAge))\n        throw new TypeError(`option maxAge is invalid: ${n.maxAge}`);\n      c += \"; Max-Age=\" + n.maxAge;\n    }\n    if (n.domain) {\n      if (!Na.test(n.domain))\n        throw new TypeError(`option domain is invalid: ${n.domain}`);\n      c += \"; Domain=\" + n.domain;\n    }\n    if (n.path) {\n      if (!Wa.test(n.path))\n        throw new TypeError(`option path is invalid: ${n.path}`);\n      c += \"; Path=\" + n.path;\n    }\n    if (n.expires) {\n      if (!ja(n.expires) || !Number.isFinite(n.expires.valueOf()))\n        throw new TypeError(`option expires is invalid: ${n.expires}`);\n      c += \"; Expires=\" + n.expires.toUTCString();\n    }\n    if (n.httpOnly && (c += \"; HttpOnly\"), n.secure && (c += \"; Secure\"), n.partitioned && (c += \"; Partitioned\"), n.priority)\n      switch (typeof n.priority == \"string\" ? n.priority.toLowerCase() : void 0) {\n        case \"low\":\n          c += \"; Priority=Low\";\n          break;\n        case \"medium\":\n          c += \"; Priority=Medium\";\n          break;\n        case \"high\":\n          c += \"; Priority=High\";\n          break;\n        default:\n          throw new TypeError(`option priority is invalid: ${n.priority}`);\n      }\n    if (n.sameSite)\n      switch (typeof n.sameSite == \"string\" ? n.sameSite.toLowerCase() : n.sameSite) {\n        case !0:\n        case \"strict\":\n          c += \"; SameSite=Strict\";\n          break;\n        case \"lax\":\n          c += \"; SameSite=Lax\";\n          break;\n        case \"none\":\n          c += \"; SameSite=None\";\n          break;\n        default:\n          throw new TypeError(`option sameSite is invalid: ${n.sameSite}`);\n      }\n    return c;\n  }\n  o(Pt, \"stringifySetCookie\");\n  function za(e, t) {\n    let r = t?.decode || Vo, n = e.length, i = dn(e, 0, n), s = ln(e, 0, i), a = s === -1 ? { name: \"\", value: r(fe(e, 0, i)) } : {\n      name: fe(e, 0, s),\n      value: r(fe(e, s + 1, i))\n    }, c = i + 1;\n    for (; c < n; ) {\n      let d = dn(e, c, n), u = ln(e, c, d), f = u === -1 ? fe(e, c, d) : fe(e, c, u), l = u === -1 ? void 0 : fe(e, u + 1, d);\n      switch (f.toLowerCase()) {\n        case \"httponly\":\n          a.httpOnly = !0;\n          break;\n        case \"secure\":\n          a.secure = !0;\n          break;\n        case \"partitioned\":\n          a.partitioned = !0;\n          break;\n        case \"domain\":\n          a.domain = l;\n          break;\n        case \"path\":\n          a.path = l;\n          break;\n        case \"max-age\":\n          l && $a.test(l) && (a.maxAge = Number(l));\n          break;\n        case \"expires\":\n          if (!l)\n            break;\n          let y = new Date(l);\n          Number.isFinite(y.valueOf()) && (a.expires = y);\n          break;\n        case \"priority\":\n          if (!l)\n            break;\n          let p = l.toLowerCase();\n          (p === \"low\" || p === \"medium\" || p === \"high\") && (a.priority = p);\n          break;\n        case \"samesite\":\n          if (!l)\n            break;\n          let m = l.toLowerCase();\n          (m === \"lax\" || m === \"strict\" || m === \"none\") && (a.sameSite = m);\n          break;\n      }\n      c = d + 1;\n    }\n    return a;\n  }\n  o(za, \"parseSetCookie\");\n  function dn(e, t, r) {\n    let n = e.indexOf(\";\", t);\n    return n === -1 ? r : n;\n  }\n  o(dn, \"endIndex\");\n  function ln(e, t, r) {\n    let n = e.indexOf(\"=\", t);\n    return n < r ? n : -1;\n  }\n  o(ln, \"eqIndex\");\n  function fe(e, t, r) {\n    let n = t, i = r;\n    do {\n      let s = e.charCodeAt(n);\n      if (s !== 32 && s !== 9)\n        break;\n    } while (++n < i);\n    for (; i > n; ) {\n      let s = e.charCodeAt(i - 1);\n      if (s !== 32 && s !== 9)\n        break;\n      i--;\n    }\n    return e.slice(n, i);\n  }\n  o(fe, \"valueSlice\");\n  function Vo(e) {\n    if (e.indexOf(\"%\") === -1)\n      return e;\n    try {\n      return decodeURIComponent(e);\n    } catch {\n      return e;\n    }\n  }\n  o(Vo, \"decode\");\n  function ja(e) {\n    return Ba.call(e) === \"[object Date]\";\n  }\n  o(ja, \"isDate\");\n});\n\n// node_modules/@convex-dev/auth/dist/server/implementation/index.js\nvar cn = Ka(Fo(), 1);\n\n// node_modules/@convex-dev/auth/dist/server/utils.js\nfunction F(e) {\n  let t = process.env[e];\n  if (t === void 0)\n    throw new Error(`Missing environment variable \\`${e}\\``);\n  return t;\n}\no(F, \"requireEnv\");\nfunction Ut(e) {\n  return /(localhost|127\\.0\\.0\\.1):\\d+/.test(e ?? \"\");\n}\no(Ut, \"isLocalHost\");\n\n// node_modules/@convex-dev/auth/dist/server/cookies.js\nvar oe = {\n  httpOnly: !0,\n  sameSite: \"none\",\n  secure: !0,\n  path: \"/\",\n  partitioned: !0\n}, Va = 900;\nfunction Go(e, t) {\n  return {\n    name: Xo(e),\n    value: t,\n    options: { ...oe, maxAge: Va }\n  };\n}\no(Go, \"redirectToParamCookie\");\nfunction qo(e, t) {\n  let r = Xo(e), n = t[r];\n  if (n === void 0)\n    return null;\n  let i = {\n    name: r,\n    value: \"\",\n    options: { ...oe, maxAge: 0 }\n  };\n  return { redirectTo: n, updatedCookie: i };\n}\no(qo, \"useRedirectToParam\");\nfunction Xo(e) {\n  return (Ut(process.env.CONVEX_SITE_URL) ? \"\" : \"__Host-\") + e + \"RedirectTo\";\n}\no(Xo, \"redirectToParamCookieName\");\n\n// node_modules/@auth/core/lib/utils/cookie.js\nvar De = function(e, t, r, n) {\n  if (r === \"a\" && !n) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof t == \"function\" ? e !== t || !n : !t.has(e)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return r === \"m\" ? n : r === \"a\" ? n.call(e) : n ? n.value : t.get(e);\n}, Fa, nt, Zo, Qo, Ga, qa;\nnt = /* @__PURE__ */ new WeakMap(), Zo = /* @__PURE__ */ new WeakMap(), Qo = /* @__PURE__ */ new WeakMap(), Fa = /* @__PURE__ */ new WeakSet(), Ga = /* @__PURE__ */ o(function(t) {\n  let r = Math.ceil(t.value.length / 3936);\n  if (r === 1)\n    return De(this, nt, \"f\")[t.name] = t.value, [t];\n  let n = [];\n  for (let i = 0; i < r; i++) {\n    let s = `${t.name}.${i}`, a = t.value.substr(i * 3936, 3936);\n    n.push({ ...t, name: s, value: a }), De(this, nt, \"f\")[s] = a;\n  }\n  return De(this, Qo, \"f\").debug(\"CHUNKING_SESSION_COOKIE\", {\n    message: \"Session cookie exceeds allowed 4096 bytes.\",\n    emptyCookieSize: 160,\n    valueSize: t.value.length,\n    chunks: n.map((i) => i.value.length + 160)\n  }), n;\n}, \"_SessionStore_chunk\"), qa = /* @__PURE__ */ o(function() {\n  let t = {};\n  for (let r in De(this, nt, \"f\"))\n    delete De(this, nt, \"f\")?.[r], t[r] = {\n      name: r,\n      value: \"\",\n      options: { ...De(this, Zo, \"f\").options, maxAge: 0 }\n    };\n  return t;\n}, \"_SessionStore_clean\");\n\n// node_modules/@auth/core/errors.js\nvar T = class extends Error {\n  static {\n    o(this, \"AuthError\");\n  }\n  constructor(t, r) {\n    t instanceof Error ? super(void 0, {\n      cause: { err: t, ...t.cause, ...r }\n    }) : typeof t == \"string\" ? (r instanceof Error && (r = { err: r, ...r.cause }), super(t, r)) : super(void 0, t), this.name = this.constructor.name, this.type = this.constructor.type ?? \"AuthError\", this.kind = this.constructor.kind ?? \"error\", Error.captureStackTrace?.(this, this.constructor);\n    let n = `https://errors.authjs.dev#${this.type.toLowerCase()}`;\n    this.message += `${this.message ? \". \" : \"\"}Read more at ${n}`;\n  }\n}, ie = class extends T {\n  static {\n    o(this, \"SignInError\");\n  }\n};\nie.kind = \"signIn\";\nvar ot = class extends T {\n  static {\n    o(this, \"AdapterError\");\n  }\n};\not.type = \"AdapterError\";\nvar it = class extends T {\n  static {\n    o(this, \"AccessDenied\");\n  }\n};\nit.type = \"AccessDenied\";\nvar Ot = class extends T {\n  static {\n    o(this, \"CallbackRouteError\");\n  }\n};\nOt.type = \"CallbackRouteError\";\nvar Lt = class extends T {\n  static {\n    o(this, \"ErrorPageLoop\");\n  }\n};\nLt.type = \"ErrorPageLoop\";\nvar Ht = class extends T {\n  static {\n    o(this, \"EventError\");\n  }\n};\nHt.type = \"EventError\";\nvar Dt = class extends T {\n  static {\n    o(this, \"InvalidCallbackUrl\");\n  }\n};\nDt.type = \"InvalidCallbackUrl\";\nvar st = class extends ie {\n  static {\n    o(this, \"CredentialsSignin\");\n  }\n  constructor() {\n    super(...arguments), this.code = \"credentials\";\n  }\n};\nst.type = \"CredentialsSignin\";\nvar Kt = class extends T {\n  static {\n    o(this, \"InvalidEndpoints\");\n  }\n};\nKt.type = \"InvalidEndpoints\";\nvar pe = class extends T {\n  static {\n    o(this, \"InvalidCheck\");\n  }\n};\npe.type = \"InvalidCheck\";\nvar Nt = class extends T {\n  static {\n    o(this, \"JWTSessionError\");\n  }\n};\nNt.type = \"JWTSessionError\";\nvar at = class extends T {\n  static {\n    o(this, \"MissingAdapter\");\n  }\n};\nat.type = \"MissingAdapter\";\nvar Wt = class extends T {\n  static {\n    o(this, \"MissingAdapterMethods\");\n  }\n};\nWt.type = \"MissingAdapterMethods\";\nvar $t = class extends T {\n  static {\n    o(this, \"MissingAuthorize\");\n  }\n};\n$t.type = \"MissingAuthorize\";\nvar ct = class extends T {\n  static {\n    o(this, \"MissingSecret\");\n  }\n};\nct.type = \"MissingSecret\";\nvar Bt = class extends ie {\n  static {\n    o(this, \"OAuthAccountNotLinked\");\n  }\n};\nBt.type = \"OAuthAccountNotLinked\";\nvar Jt = class extends ie {\n  static {\n    o(this, \"OAuthCallbackError\");\n  }\n};\nJt.type = \"OAuthCallbackError\";\nvar Mt = class extends T {\n  static {\n    o(this, \"OAuthProfileParseError\");\n  }\n};\nMt.type = \"OAuthProfileParseError\";\nvar zt = class extends T {\n  static {\n    o(this, \"SessionTokenError\");\n  }\n};\nzt.type = \"SessionTokenError\";\nvar fn = class extends ie {\n  static {\n    o(this, \"OAuthSignInError\");\n  }\n};\nfn.type = \"OAuthSignInError\";\nvar pn = class extends ie {\n  static {\n    o(this, \"EmailSignInError\");\n  }\n};\npn.type = \"EmailSignInError\";\nvar jt = class extends T {\n  static {\n    o(this, \"SignOutError\");\n  }\n};\njt.type = \"SignOutError\";\nvar Ke = class extends T {\n  static {\n    o(this, \"UnknownAction\");\n  }\n};\nKe.type = \"UnknownAction\";\nvar Vt = class extends T {\n  static {\n    o(this, \"UnsupportedStrategy\");\n  }\n};\nVt.type = \"UnsupportedStrategy\";\nvar ut = class extends T {\n  static {\n    o(this, \"InvalidProvider\");\n  }\n};\nut.type = \"InvalidProvider\";\nvar Ft = class extends T {\n  static {\n    o(this, \"UntrustedHost\");\n  }\n};\nFt.type = \"UntrustedHost\";\nvar Gt = class extends T {\n  static {\n    o(this, \"Verification\");\n  }\n};\nGt.type = \"Verification\";\nvar qt = class extends ie {\n  static {\n    o(this, \"MissingCSRF\");\n  }\n};\nqt.type = \"MissingCSRF\";\nvar Xt = class extends T {\n  static {\n    o(this, \"DuplicateConditionalUI\");\n  }\n};\nXt.type = \"DuplicateConditionalUI\";\nvar Zt = class extends T {\n  static {\n    o(this, \"MissingWebAuthnAutocomplete\");\n  }\n};\nZt.type = \"MissingWebAuthnAutocomplete\";\nvar Qt = class extends T {\n  static {\n    o(this, \"WebAuthnVerificationError\");\n  }\n};\nQt.type = \"WebAuthnVerificationError\";\nvar Yt = class extends ie {\n  static {\n    o(this, \"AccountNotLinked\");\n  }\n};\nYt.type = \"AccountNotLinked\";\nvar er = class extends T {\n  static {\n    o(this, \"ExperimentalFeatureNotEnabled\");\n  }\n};\ner.type = \"ExperimentalFeatureNotEnabled\";\n\n// node_modules/@panva/hkdf/dist/web/runtime/hkdf.js\nvar Za = /* @__PURE__ */ o(() => {\n  if (typeof globalThis < \"u\")\n    return globalThis;\n  if (typeof self < \"u\")\n    return self;\n  if (typeof window < \"u\")\n    return window;\n  throw new Error(\"unable to locate global object\");\n}, \"getGlobal\"), ei = /* @__PURE__ */ o(async (e, t, r, n, i) => {\n  let { crypto: { subtle: s } } = Za();\n  return new Uint8Array(await s.deriveBits({\n    name: \"HKDF\",\n    hash: `SHA-${e.substr(3)}`,\n    salt: r,\n    info: n\n  }, await s.importKey(\"raw\", t, \"HKDF\", !1, [\"deriveBits\"]), i << 3));\n}, \"default\");\n\n// node_modules/@panva/hkdf/dist/web/index.js\nfunction Qa(e) {\n  switch (e) {\n    case \"sha256\":\n    case \"sha384\":\n    case \"sha512\":\n    case \"sha1\":\n      return e;\n    default:\n      throw new TypeError('unsupported \"digest\" value');\n  }\n}\no(Qa, \"normalizeDigest\");\nfunction hn(e, t) {\n  if (typeof e == \"string\")\n    return new TextEncoder().encode(e);\n  if (!(e instanceof Uint8Array))\n    throw new TypeError(`\"${t}\"\" must be an instance of Uint8Array or a string`);\n  return e;\n}\no(hn, \"normalizeUint8Array\");\nfunction Ya(e) {\n  let t = hn(e, \"ikm\");\n  if (!t.byteLength)\n    throw new TypeError('\"ikm\" must be at least one byte in length');\n  return t;\n}\no(Ya, \"normalizeIkm\");\nfunction ec(e) {\n  let t = hn(e, \"info\");\n  if (t.byteLength > 1024)\n    throw TypeError('\"info\" must not contain more than 1024 bytes');\n  return t;\n}\no(ec, \"normalizeInfo\");\nfunction tc(e, t) {\n  if (typeof e != \"number\" || !Number.isInteger(e) || e < 1)\n    throw new TypeError('\"keylen\" must be a positive integer');\n  let r = parseInt(t.substr(3), 10) >> 3 || 20;\n  if (e > 255 * r)\n    throw new TypeError('\"keylen\" too large');\n  return e;\n}\no(tc, \"normalizeKeylen\");\nasync function ti(e, t, r, n, i) {\n  return ei(Qa(e), Ya(t), hn(r, \"salt\"), ec(n), tc(i, e));\n}\no(ti, \"hkdf\");\n\n// node_modules/jose/dist/browser/runtime/webcrypto.js\nvar _ = crypto, K = /* @__PURE__ */ o((e) => e instanceof CryptoKey, \"isCryptoKey\");\n\n// node_modules/jose/dist/browser/runtime/digest.js\nvar rc = /* @__PURE__ */ o(async (e, t) => {\n  let r = `SHA-${e.slice(-3)}`;\n  return new Uint8Array(await _.subtle.digest(r, t));\n}, \"digest\"), tr = rc;\n\n// node_modules/jose/dist/browser/lib/buffer_utils.js\nvar U = new TextEncoder(), Q = new TextDecoder(), rr = 2 ** 32;\nfunction j(...e) {\n  let t = e.reduce((i, { length: s }) => i + s, 0), r = new Uint8Array(t), n = 0;\n  for (let i of e)\n    r.set(i, n), n += i.length;\n  return r;\n}\no(j, \"concat\");\nfunction ri(e, t) {\n  return j(U.encode(e), new Uint8Array([0]), t);\n}\no(ri, \"p2s\");\nfunction mn(e, t, r) {\n  if (t < 0 || t >= rr)\n    throw new RangeError(`value must be >= 0 and <= ${rr - 1}. Received ${t}`);\n  e.set([t >>> 24, t >>> 16, t >>> 8, t & 255], r);\n}\no(mn, \"writeUInt32BE\");\nfunction nr(e) {\n  let t = Math.floor(e / rr), r = e % rr, n = new Uint8Array(8);\n  return mn(n, t, 0), mn(n, r, 4), n;\n}\no(nr, \"uint64be\");\nfunction or(e) {\n  let t = new Uint8Array(4);\n  return mn(t, e), t;\n}\no(or, \"uint32be\");\nfunction ir(e) {\n  return j(or(e.length), e);\n}\no(ir, \"lengthAndInput\");\nasync function ni(e, t, r) {\n  let n = Math.ceil((t >> 3) / 32), i = new Uint8Array(n * 32);\n  for (let s = 0; s < n; s++) {\n    let a = new Uint8Array(4 + e.length + r.length);\n    a.set(or(s + 1)), a.set(e, 4), a.set(r, 4 + e.length), i.set(await tr(\"sha256\", a), s * 32);\n  }\n  return i.slice(0, t >> 3);\n}\no(ni, \"concatKdf\");\n\n// node_modules/jose/dist/browser/runtime/base64url.js\nvar nc = /* @__PURE__ */ o((e) => {\n  let t = e;\n  typeof t == \"string\" && (t = U.encode(t));\n  let r = 32768, n = [];\n  for (let i = 0; i < t.length; i += r)\n    n.push(String.fromCharCode.apply(null, t.subarray(i, i + r)));\n  return btoa(n.join(\"\"));\n}, \"encodeBase64\"), O = /* @__PURE__ */ o((e) => nc(e).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\"), \"encode\"), oc = /* @__PURE__ */ o((e) => {\n  let t = atob(e), r = new Uint8Array(t.length);\n  for (let n = 0; n < t.length; n++)\n    r[n] = t.charCodeAt(n);\n  return r;\n}, \"decodeBase64\"), W = /* @__PURE__ */ o((e) => {\n  let t = e;\n  t instanceof Uint8Array && (t = Q.decode(t)), t = t.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\");\n  try {\n    return oc(t);\n  } catch {\n    throw new TypeError(\"The input to be decoded is not correctly encoded.\");\n  }\n}, \"decode\");\n\n// node_modules/jose/dist/browser/util/errors.js\nvar M = class extends Error {\n  static {\n    o(this, \"JOSEError\");\n  }\n  constructor(t, r) {\n    super(t, r), this.code = \"ERR_JOSE_GENERIC\", this.name = this.constructor.name, Error.captureStackTrace?.(this, this.constructor);\n  }\n};\nM.code = \"ERR_JOSE_GENERIC\";\nvar B = class extends M {\n  static {\n    o(this, \"JWTClaimValidationFailed\");\n  }\n  constructor(t, r, n = \"unspecified\", i = \"unspecified\") {\n    super(t, { cause: { claim: n, reason: i, payload: r } }), this.code = \"ERR_JWT_CLAIM_VALIDATION_FAILED\", this.claim = n, this.reason = i, this.payload = r;\n  }\n};\nB.code = \"ERR_JWT_CLAIM_VALIDATION_FAILED\";\nvar Ne = class extends M {\n  static {\n    o(this, \"JWTExpired\");\n  }\n  constructor(t, r, n = \"unspecified\", i = \"unspecified\") {\n    super(t, { cause: { claim: n, reason: i, payload: r } }), this.code = \"ERR_JWT_EXPIRED\", this.claim = n, this.reason = i, this.payload = r;\n  }\n};\nNe.code = \"ERR_JWT_EXPIRED\";\nvar We = class extends M {\n  static {\n    o(this, \"JOSEAlgNotAllowed\");\n  }\n  constructor() {\n    super(...arguments), this.code = \"ERR_JOSE_ALG_NOT_ALLOWED\";\n  }\n};\nWe.code = \"ERR_JOSE_ALG_NOT_ALLOWED\";\nvar E = class extends M {\n  static {\n    o(this, \"JOSENotSupported\");\n  }\n  constructor() {\n    super(...arguments), this.code = \"ERR_JOSE_NOT_SUPPORTED\";\n  }\n};\nE.code = \"ERR_JOSE_NOT_SUPPORTED\";\nvar Ae = class extends M {\n  static {\n    o(this, \"JWEDecryptionFailed\");\n  }\n  constructor(t = \"decryption operation failed\", r) {\n    super(t, r), this.code = \"ERR_JWE_DECRYPTION_FAILED\";\n  }\n};\nAe.code = \"ERR_JWE_DECRYPTION_FAILED\";\nvar w = class extends M {\n  static {\n    o(this, \"JWEInvalid\");\n  }\n  constructor() {\n    super(...arguments), this.code = \"ERR_JWE_INVALID\";\n  }\n};\nw.code = \"ERR_JWE_INVALID\";\nvar ue = class extends M {\n  static {\n    o(this, \"JWSInvalid\");\n  }\n  constructor() {\n    super(...arguments), this.code = \"ERR_JWS_INVALID\";\n  }\n};\nue.code = \"ERR_JWS_INVALID\";\nvar Ee = class extends M {\n  static {\n    o(this, \"JWTInvalid\");\n  }\n  constructor() {\n    super(...arguments), this.code = \"ERR_JWT_INVALID\";\n  }\n};\nEe.code = \"ERR_JWT_INVALID\";\nvar dt = class extends M {\n  static {\n    o(this, \"JWKInvalid\");\n  }\n  constructor() {\n    super(...arguments), this.code = \"ERR_JWK_INVALID\";\n  }\n};\ndt.code = \"ERR_JWK_INVALID\";\nvar yn = class extends M {\n  static {\n    o(this, \"JWKSInvalid\");\n  }\n  constructor() {\n    super(...arguments), this.code = \"ERR_JWKS_INVALID\";\n  }\n};\nyn.code = \"ERR_JWKS_INVALID\";\nvar wn = class extends M {\n  static {\n    o(this, \"JWKSNoMatchingKey\");\n  }\n  constructor(t = \"no applicable key found in the JSON Web Key Set\", r) {\n    super(t, r), this.code = \"ERR_JWKS_NO_MATCHING_KEY\";\n  }\n};\nwn.code = \"ERR_JWKS_NO_MATCHING_KEY\";\nvar gn = class extends M {\n  static {\n    o(this, \"JWKSMultipleMatchingKeys\");\n  }\n  constructor(t = \"multiple matching keys found in the JSON Web Key Set\", r) {\n    super(t, r), this.code = \"ERR_JWKS_MULTIPLE_MATCHING_KEYS\";\n  }\n};\ngn.code = \"ERR_JWKS_MULTIPLE_MATCHING_KEYS\";\nvar bn = class extends M {\n  static {\n    o(this, \"JWKSTimeout\");\n  }\n  constructor(t = \"request timed out\", r) {\n    super(t, r), this.code = \"ERR_JWKS_TIMEOUT\";\n  }\n};\nbn.code = \"ERR_JWKS_TIMEOUT\";\nvar _n = class extends M {\n  static {\n    o(this, \"JWSSignatureVerificationFailed\");\n  }\n  constructor(t = \"signature verification failed\", r) {\n    super(t, r), this.code = \"ERR_JWS_SIGNATURE_VERIFICATION_FAILED\";\n  }\n};\n_n.code = \"ERR_JWS_SIGNATURE_VERIFICATION_FAILED\";\n\n// node_modules/jose/dist/browser/runtime/random.js\nvar $e = _.getRandomValues.bind(_);\n\n// node_modules/jose/dist/browser/lib/iv.js\nfunction xn(e) {\n  switch (e) {\n    case \"A128GCM\":\n    case \"A128GCMKW\":\n    case \"A192GCM\":\n    case \"A192GCMKW\":\n    case \"A256GCM\":\n    case \"A256GCMKW\":\n      return 96;\n    case \"A128CBC-HS256\":\n    case \"A192CBC-HS384\":\n    case \"A256CBC-HS512\":\n      return 128;\n    default:\n      throw new E(`Unsupported JWE Algorithm: ${e}`);\n  }\n}\no(xn, \"bitLength\");\nvar oi = /* @__PURE__ */ o((e) => $e(new Uint8Array(xn(e) >> 3)), \"default\");\n\n// node_modules/jose/dist/browser/lib/check_iv_length.js\nvar ac = /* @__PURE__ */ o((e, t) => {\n  if (t.length << 3 !== xn(e))\n    throw new w(\"Invalid Initialization Vector length\");\n}, \"checkIvLength\"), sr = ac;\n\n// node_modules/jose/dist/browser/runtime/check_cek_length.js\nvar cc = /* @__PURE__ */ o((e, t) => {\n  let r = e.byteLength << 3;\n  if (r !== t)\n    throw new w(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`);\n}, \"checkCekLength\"), Be = cc;\n\n// node_modules/jose/dist/browser/runtime/timing_safe_equal.js\nvar uc = /* @__PURE__ */ o((e, t) => {\n  if (!(e instanceof Uint8Array))\n    throw new TypeError(\"First argument must be a buffer\");\n  if (!(t instanceof Uint8Array))\n    throw new TypeError(\"Second argument must be a buffer\");\n  if (e.length !== t.length)\n    throw new TypeError(\"Input buffers must have the same length\");\n  let r = e.length, n = 0, i = -1;\n  for (; ++i < r; )\n    n |= e[i] ^ t[i];\n  return n === 0;\n}, \"timingSafeEqual\"), ii = uc;\n\n// node_modules/jose/dist/browser/lib/crypto_key.js\nfunction J(e, t = \"algorithm.name\") {\n  return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`);\n}\no(J, \"unusable\");\nfunction de(e, t) {\n  return e.name === t;\n}\no(de, \"isAlgorithm\");\nfunction ar(e) {\n  return parseInt(e.name.slice(4), 10);\n}\no(ar, \"getHashLength\");\nfunction dc(e) {\n  switch (e) {\n    case \"ES256\":\n      return \"P-256\";\n    case \"ES384\":\n      return \"P-384\";\n    case \"ES512\":\n      return \"P-521\";\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\no(dc, \"getNamedCurve\");\nfunction si(e, t) {\n  if (t.length && !t.some((r) => e.usages.includes(r))) {\n    let r = \"CryptoKey does not support this operation, its usages must include \";\n    if (t.length > 2) {\n      let n = t.pop();\n      r += `one of ${t.join(\", \")}, or ${n}.`;\n    } else t.length === 2 ? r += `one of ${t[0]} or ${t[1]}.` : r += `${t[0]}.`;\n    throw new TypeError(r);\n  }\n}\no(si, \"checkUsage\");\nfunction ai(e, t, ...r) {\n  switch (t) {\n    case \"HS256\":\n    case \"HS384\":\n    case \"HS512\": {\n      if (!de(e.algorithm, \"HMAC\"))\n        throw J(\"HMAC\");\n      let n = parseInt(t.slice(2), 10);\n      if (ar(e.algorithm.hash) !== n)\n        throw J(`SHA-${n}`, \"algorithm.hash\");\n      break;\n    }\n    case \"RS256\":\n    case \"RS384\":\n    case \"RS512\": {\n      if (!de(e.algorithm, \"RSASSA-PKCS1-v1_5\"))\n        throw J(\"RSASSA-PKCS1-v1_5\");\n      let n = parseInt(t.slice(2), 10);\n      if (ar(e.algorithm.hash) !== n)\n        throw J(`SHA-${n}`, \"algorithm.hash\");\n      break;\n    }\n    case \"PS256\":\n    case \"PS384\":\n    case \"PS512\": {\n      if (!de(e.algorithm, \"RSA-PSS\"))\n        throw J(\"RSA-PSS\");\n      let n = parseInt(t.slice(2), 10);\n      if (ar(e.algorithm.hash) !== n)\n        throw J(`SHA-${n}`, \"algorithm.hash\");\n      break;\n    }\n    case \"EdDSA\": {\n      if (e.algorithm.name !== \"Ed25519\" && e.algorithm.name !== \"Ed448\")\n        throw J(\"Ed25519 or Ed448\");\n      break;\n    }\n    case \"Ed25519\": {\n      if (!de(e.algorithm, \"Ed25519\"))\n        throw J(\"Ed25519\");\n      break;\n    }\n    case \"ES256\":\n    case \"ES384\":\n    case \"ES512\": {\n      if (!de(e.algorithm, \"ECDSA\"))\n        throw J(\"ECDSA\");\n      let n = dc(t);\n      if (e.algorithm.namedCurve !== n)\n        throw J(n, \"algorithm.namedCurve\");\n      break;\n    }\n    default:\n      throw new TypeError(\"CryptoKey does not support this operation\");\n  }\n  si(e, r);\n}\no(ai, \"checkSigCryptoKey\");\nfunction G(e, t, ...r) {\n  switch (t) {\n    case \"A128GCM\":\n    case \"A192GCM\":\n    case \"A256GCM\": {\n      if (!de(e.algorithm, \"AES-GCM\"))\n        throw J(\"AES-GCM\");\n      let n = parseInt(t.slice(1, 4), 10);\n      if (e.algorithm.length !== n)\n        throw J(n, \"algorithm.length\");\n      break;\n    }\n    case \"A128KW\":\n    case \"A192KW\":\n    case \"A256KW\": {\n      if (!de(e.algorithm, \"AES-KW\"))\n        throw J(\"AES-KW\");\n      let n = parseInt(t.slice(1, 4), 10);\n      if (e.algorithm.length !== n)\n        throw J(n, \"algorithm.length\");\n      break;\n    }\n    case \"ECDH\": {\n      switch (e.algorithm.name) {\n        case \"ECDH\":\n        case \"X25519\":\n        case \"X448\":\n          break;\n        default:\n          throw J(\"ECDH, X25519, or X448\");\n      }\n      break;\n    }\n    case \"PBES2-HS256+A128KW\":\n    case \"PBES2-HS384+A192KW\":\n    case \"PBES2-HS512+A256KW\":\n      if (!de(e.algorithm, \"PBKDF2\"))\n        throw J(\"PBKDF2\");\n      break;\n    case \"RSA-OAEP\":\n    case \"RSA-OAEP-256\":\n    case \"RSA-OAEP-384\":\n    case \"RSA-OAEP-512\": {\n      if (!de(e.algorithm, \"RSA-OAEP\"))\n        throw J(\"RSA-OAEP\");\n      let n = parseInt(t.slice(9), 10) || 1;\n      if (ar(e.algorithm.hash) !== n)\n        throw J(`SHA-${n}`, \"algorithm.hash\");\n      break;\n    }\n    default:\n      throw new TypeError(\"CryptoKey does not support this operation\");\n  }\n  si(e, r);\n}\no(G, \"checkEncCryptoKey\");\n\n// node_modules/jose/dist/browser/lib/invalid_key_input.js\nfunction ci(e, t, ...r) {\n  if (r = r.filter(Boolean), r.length > 2) {\n    let n = r.pop();\n    e += `one of type ${r.join(\", \")}, or ${n}.`;\n  } else r.length === 2 ? e += `one of type ${r[0]} or ${r[1]}.` : e += `of type ${r[0]}.`;\n  return t == null ? e += ` Received ${t}` : typeof t == \"function\" && t.name ? e += ` Received function ${t.name}` : typeof t == \"object\" && t != null && t.constructor?.name && (e += ` Received an instance of ${t.constructor.name}`), e;\n}\no(ci, \"message\");\nvar N = /* @__PURE__ */ o((e, ...t) => ci(\"Key must be \", e, ...t), \"default\");\nfunction Sn(e, t, ...r) {\n  return ci(`Key for the ${e} algorithm must be `, t, ...r);\n}\no(Sn, \"withAlg\");\n\n// node_modules/jose/dist/browser/runtime/is_key_like.js\nvar vn = /* @__PURE__ */ o((e) => K(e) ? !0 : e?.[Symbol.toStringTag] === \"KeyObject\", \"default\"), H = [\"CryptoKey\"];\n\n// node_modules/jose/dist/browser/runtime/decrypt.js\nasync function lc(e, t, r, n, i, s) {\n  if (!(t instanceof Uint8Array))\n    throw new TypeError(N(t, \"Uint8Array\"));\n  let a = parseInt(e.slice(1, 4), 10), c = await _.subtle.importKey(\"raw\", t.subarray(a >> 3), \"AES-CBC\", !1, [\"decrypt\"]), d = await _.subtle.importKey(\"raw\", t.subarray(0, a >> 3), {\n    hash: `SHA-${a << 1}`,\n    name: \"HMAC\"\n  }, !1, [\"sign\"]), u = j(s, n, r, nr(s.length << 3)), f = new Uint8Array((await _.subtle.sign(\"HMAC\", d, u)).slice(0, a >> 3)), l;\n  try {\n    l = ii(i, f);\n  } catch {\n  }\n  if (!l)\n    throw new Ae();\n  let y;\n  try {\n    y = new Uint8Array(await _.subtle.decrypt({ iv: n, name: \"AES-CBC\" }, c, r));\n  } catch {\n  }\n  if (!y)\n    throw new Ae();\n  return y;\n}\no(lc, \"cbcDecrypt\");\nasync function fc(e, t, r, n, i, s) {\n  let a;\n  t instanceof Uint8Array ? a = await _.subtle.importKey(\"raw\", t, \"AES-GCM\", !1, [\"decrypt\"]) : (G(t, e, \"decrypt\"), a = t);\n  try {\n    return new Uint8Array(await _.subtle.decrypt({\n      additionalData: s,\n      iv: n,\n      name: \"AES-GCM\",\n      tagLength: 128\n    }, a, j(r, i)));\n  } catch {\n    throw new Ae();\n  }\n}\no(fc, \"gcmDecrypt\");\nvar pc = /* @__PURE__ */ o(async (e, t, r, n, i, s) => {\n  if (!K(t) && !(t instanceof Uint8Array))\n    throw new TypeError(N(t, ...H, \"Uint8Array\"));\n  if (!n)\n    throw new w(\"JWE Initialization Vector missing\");\n  if (!i)\n    throw new w(\"JWE Authentication Tag missing\");\n  switch (sr(e, n), e) {\n    case \"A128CBC-HS256\":\n    case \"A192CBC-HS384\":\n    case \"A256CBC-HS512\":\n      return t instanceof Uint8Array && Be(t, parseInt(e.slice(-3), 10)), lc(e, t, r, n, i, s);\n    case \"A128GCM\":\n    case \"A192GCM\":\n    case \"A256GCM\":\n      return t instanceof Uint8Array && Be(t, parseInt(e.slice(1, 4), 10)), fc(e, t, r, n, i, s);\n    default:\n      throw new E(\"Unsupported JWE Content Encryption Algorithm\");\n  }\n}, \"decrypt\"), cr = pc;\n\n// node_modules/jose/dist/browser/lib/is_disjoint.js\nvar hc = /* @__PURE__ */ o((...e) => {\n  let t = e.filter(Boolean);\n  if (t.length === 0 || t.length === 1)\n    return !0;\n  let r;\n  for (let n of t) {\n    let i = Object.keys(n);\n    if (!r || r.size === 0) {\n      r = new Set(i);\n      continue;\n    }\n    for (let s of i) {\n      if (r.has(s))\n        return !1;\n      r.add(s);\n    }\n  }\n  return !0;\n}, \"isDisjoint\"), Je = hc;\n\n// node_modules/jose/dist/browser/lib/is_object.js\nfunction mc(e) {\n  return typeof e == \"object\" && e !== null;\n}\no(mc, \"isObjectLike\");\nfunction z(e) {\n  if (!mc(e) || Object.prototype.toString.call(e) !== \"[object Object]\")\n    return !1;\n  if (Object.getPrototypeOf(e) === null)\n    return !0;\n  let t = e;\n  for (; Object.getPrototypeOf(t) !== null; )\n    t = Object.getPrototypeOf(t);\n  return Object.getPrototypeOf(e) === t;\n}\no(z, \"isObject\");\n\n// node_modules/jose/dist/browser/runtime/bogus.js\nvar yc = [\n  { hash: \"SHA-256\", name: \"HMAC\" },\n  !0,\n  [\"sign\"]\n], Me = yc;\n\n// node_modules/jose/dist/browser/runtime/aeskw.js\nfunction ui(e, t) {\n  if (e.algorithm.length !== parseInt(t.slice(1, 4), 10))\n    throw new TypeError(`Invalid key size for alg: ${t}`);\n}\no(ui, \"checkKeySize\");\nfunction di(e, t, r) {\n  if (K(e))\n    return G(e, t, r), e;\n  if (e instanceof Uint8Array)\n    return _.subtle.importKey(\"raw\", e, \"AES-KW\", !0, [r]);\n  throw new TypeError(N(e, ...H, \"Uint8Array\"));\n}\no(di, \"getCryptoKey\");\nvar lt = /* @__PURE__ */ o(async (e, t, r) => {\n  let n = await di(t, e, \"wrapKey\");\n  ui(n, e);\n  let i = await _.subtle.importKey(\"raw\", r, ...Me);\n  return new Uint8Array(await _.subtle.wrapKey(\"raw\", i, n, \"AES-KW\"));\n}, \"wrap\"), ft = /* @__PURE__ */ o(async (e, t, r) => {\n  let n = await di(t, e, \"unwrapKey\");\n  ui(n, e);\n  let i = await _.subtle.unwrapKey(\"raw\", r, n, \"AES-KW\", ...Me);\n  return new Uint8Array(await _.subtle.exportKey(\"raw\", i));\n}, \"unwrap\");\n\n// node_modules/jose/dist/browser/runtime/ecdhes.js\nasync function ur(e, t, r, n, i = new Uint8Array(0), s = new Uint8Array(0)) {\n  if (!K(e))\n    throw new TypeError(N(e, ...H));\n  if (G(e, \"ECDH\"), !K(t))\n    throw new TypeError(N(t, ...H));\n  G(t, \"ECDH\", \"deriveBits\");\n  let a = j(ir(U.encode(r)), ir(i), ir(s), or(n)), c;\n  e.algorithm.name === \"X25519\" ? c = 256 : e.algorithm.name === \"X448\" ? c = 448 : c = Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3), 10) / 8) << 3;\n  let d = new Uint8Array(await _.subtle.deriveBits({\n    name: e.algorithm.name,\n    public: e\n  }, t, c));\n  return ni(d, n, a);\n}\no(ur, \"deriveKey\");\nasync function li(e) {\n  if (!K(e))\n    throw new TypeError(N(e, ...H));\n  return _.subtle.generateKey(e.algorithm, !0, [\"deriveBits\"]);\n}\no(li, \"generateEpk\");\nfunction dr(e) {\n  if (!K(e))\n    throw new TypeError(N(e, ...H));\n  return [\"P-256\", \"P-384\", \"P-521\"].includes(e.algorithm.namedCurve) || e.algorithm.name === \"X25519\" || e.algorithm.name === \"X448\";\n}\no(dr, \"ecdhAllowed\");\n\n// node_modules/jose/dist/browser/lib/check_p2s.js\nfunction An(e) {\n  if (!(e instanceof Uint8Array) || e.length < 8)\n    throw new w(\"PBES2 Salt Input must be 8 or more octets\");\n}\no(An, \"checkP2s\");\n\n// node_modules/jose/dist/browser/runtime/pbes2kw.js\nfunction wc(e, t) {\n  if (e instanceof Uint8Array)\n    return _.subtle.importKey(\"raw\", e, \"PBKDF2\", !1, [\"deriveBits\"]);\n  if (K(e))\n    return G(e, t, \"deriveBits\", \"deriveKey\"), e;\n  throw new TypeError(N(e, ...H, \"Uint8Array\"));\n}\no(wc, \"getCryptoKey\");\nasync function pi(e, t, r, n) {\n  An(e);\n  let i = ri(t, e), s = parseInt(t.slice(13, 16), 10), a = {\n    hash: `SHA-${t.slice(8, 11)}`,\n    iterations: r,\n    name: \"PBKDF2\",\n    salt: i\n  }, c = {\n    length: s,\n    name: \"AES-KW\"\n  }, d = await wc(n, t);\n  if (d.usages.includes(\"deriveBits\"))\n    return new Uint8Array(await _.subtle.deriveBits(a, d, s));\n  if (d.usages.includes(\"deriveKey\"))\n    return _.subtle.deriveKey(a, d, c, !1, [\"wrapKey\", \"unwrapKey\"]);\n  throw new TypeError('PBKDF2 key \"usages\" must include \"deriveBits\" or \"deriveKey\"');\n}\no(pi, \"deriveKey\");\nvar hi = /* @__PURE__ */ o(async (e, t, r, n = 2048, i = $e(new Uint8Array(16))) => {\n  let s = await pi(i, e, n, t);\n  return { encryptedKey: await lt(e.slice(-6), s, r), p2c: n, p2s: O(i) };\n}, \"encrypt\"), mi = /* @__PURE__ */ o(async (e, t, r, n, i) => {\n  let s = await pi(i, e, n, t);\n  return ft(e.slice(-6), s, r);\n}, \"decrypt\");\n\n// node_modules/jose/dist/browser/runtime/subtle_rsaes.js\nfunction ze(e) {\n  switch (e) {\n    case \"RSA-OAEP\":\n    case \"RSA-OAEP-256\":\n    case \"RSA-OAEP-384\":\n    case \"RSA-OAEP-512\":\n      return \"RSA-OAEP\";\n    default:\n      throw new E(`alg ${e} is not supported either by JOSE or your javascript runtime`);\n  }\n}\no(ze, \"subtleRsaEs\");\n\n// node_modules/jose/dist/browser/runtime/check_key_length.js\nvar pt = /* @__PURE__ */ o((e, t) => {\n  if (e.startsWith(\"RS\") || e.startsWith(\"PS\")) {\n    let { modulusLength: r } = t.algorithm;\n    if (typeof r != \"number\" || r < 2048)\n      throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`);\n  }\n}, \"default\");\n\n// node_modules/jose/dist/browser/runtime/rsaes.js\nvar yi = /* @__PURE__ */ o(async (e, t, r) => {\n  if (!K(t))\n    throw new TypeError(N(t, ...H));\n  if (G(t, e, \"encrypt\", \"wrapKey\"), pt(e, t), t.usages.includes(\"encrypt\"))\n    return new Uint8Array(await _.subtle.encrypt(ze(e), t, r));\n  if (t.usages.includes(\"wrapKey\")) {\n    let n = await _.subtle.importKey(\"raw\", r, ...Me);\n    return new Uint8Array(await _.subtle.wrapKey(\"raw\", n, t, ze(e)));\n  }\n  throw new TypeError('RSA-OAEP key \"usages\" must include \"encrypt\" or \"wrapKey\" for this operation');\n}, \"encrypt\"), wi = /* @__PURE__ */ o(async (e, t, r) => {\n  if (!K(t))\n    throw new TypeError(N(t, ...H));\n  if (G(t, e, \"decrypt\", \"unwrapKey\"), pt(e, t), t.usages.includes(\"decrypt\"))\n    return new Uint8Array(await _.subtle.decrypt(ze(e), t, r));\n  if (t.usages.includes(\"unwrapKey\")) {\n    let n = await _.subtle.unwrapKey(\"raw\", r, t, ze(e), ...Me);\n    return new Uint8Array(await _.subtle.exportKey(\"raw\", n));\n  }\n  throw new TypeError('RSA-OAEP key \"usages\" must include \"decrypt\" or \"unwrapKey\" for this operation');\n}, \"decrypt\");\n\n// node_modules/jose/dist/browser/lib/is_jwk.js\nfunction ke(e) {\n  return z(e) && typeof e.kty == \"string\";\n}\no(ke, \"isJWK\");\nfunction gi(e) {\n  return e.kty !== \"oct\" && typeof e.d == \"string\";\n}\no(gi, \"isPrivateJWK\");\nfunction bi(e) {\n  return e.kty !== \"oct\" && typeof e.d > \"u\";\n}\no(bi, \"isPublicJWK\");\nfunction _i(e) {\n  return ke(e) && e.kty === \"oct\" && typeof e.k == \"string\";\n}\no(_i, \"isSecretJWK\");\n\n// node_modules/jose/dist/browser/runtime/jwk_to_key.js\nfunction bc(e) {\n  let t, r;\n  switch (e.kty) {\n    case \"RSA\": {\n      switch (e.alg) {\n        case \"PS256\":\n        case \"PS384\":\n        case \"PS512\":\n          t = { name: \"RSA-PSS\", hash: `SHA-${e.alg.slice(-3)}` }, r = e.d ? [\"sign\"] : [\"verify\"];\n          break;\n        case \"RS256\":\n        case \"RS384\":\n        case \"RS512\":\n          t = { name: \"RSASSA-PKCS1-v1_5\", hash: `SHA-${e.alg.slice(-3)}` }, r = e.d ? [\"sign\"] : [\"verify\"];\n          break;\n        case \"RSA-OAEP\":\n        case \"RSA-OAEP-256\":\n        case \"RSA-OAEP-384\":\n        case \"RSA-OAEP-512\":\n          t = {\n            name: \"RSA-OAEP\",\n            hash: `SHA-${parseInt(e.alg.slice(-3), 10) || 1}`\n          }, r = e.d ? [\"decrypt\", \"unwrapKey\"] : [\"encrypt\", \"wrapKey\"];\n          break;\n        default:\n          throw new E('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n      }\n      break;\n    }\n    case \"EC\": {\n      switch (e.alg) {\n        case \"ES256\":\n          t = { name: \"ECDSA\", namedCurve: \"P-256\" }, r = e.d ? [\"sign\"] : [\"verify\"];\n          break;\n        case \"ES384\":\n          t = { name: \"ECDSA\", namedCurve: \"P-384\" }, r = e.d ? [\"sign\"] : [\"verify\"];\n          break;\n        case \"ES512\":\n          t = { name: \"ECDSA\", namedCurve: \"P-521\" }, r = e.d ? [\"sign\"] : [\"verify\"];\n          break;\n        case \"ECDH-ES\":\n        case \"ECDH-ES+A128KW\":\n        case \"ECDH-ES+A192KW\":\n        case \"ECDH-ES+A256KW\":\n          t = { name: \"ECDH\", namedCurve: e.crv }, r = e.d ? [\"deriveBits\"] : [];\n          break;\n        default:\n          throw new E('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n      }\n      break;\n    }\n    case \"OKP\": {\n      switch (e.alg) {\n        case \"Ed25519\":\n          t = { name: \"Ed25519\" }, r = e.d ? [\"sign\"] : [\"verify\"];\n          break;\n        case \"EdDSA\":\n          t = { name: e.crv }, r = e.d ? [\"sign\"] : [\"verify\"];\n          break;\n        case \"ECDH-ES\":\n        case \"ECDH-ES+A128KW\":\n        case \"ECDH-ES+A192KW\":\n        case \"ECDH-ES+A256KW\":\n          t = { name: e.crv }, r = e.d ? [\"deriveBits\"] : [];\n          break;\n        default:\n          throw new E('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n      }\n      break;\n    }\n    default:\n      throw new E('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n  }\n  return { algorithm: t, keyUsages: r };\n}\no(bc, \"subtleMapping\");\nvar _c = /* @__PURE__ */ o(async (e) => {\n  if (!e.alg)\n    throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n  let { algorithm: t, keyUsages: r } = bc(e), n = [\n    t,\n    e.ext ?? !1,\n    e.key_ops ?? r\n  ], i = { ...e };\n  return delete i.alg, delete i.use, _.subtle.importKey(\"jwk\", i, ...n);\n}, \"parse\"), lr = _c;\n\n// node_modules/jose/dist/browser/runtime/normalize_key.js\nvar xi = /* @__PURE__ */ o((e) => W(e), \"exportKeyValue\"), je, Ve, Si = /* @__PURE__ */ o((e) => e?.[Symbol.toStringTag] === \"KeyObject\", \"isKeyObject\"), fr = /* @__PURE__ */ o(async (e, t, r, n, i = !1) => {\n  let s = e.get(t);\n  if (s?.[n])\n    return s[n];\n  let a = await lr({ ...r, alg: n });\n  return i && Object.freeze(t), s ? s[n] = a : e.set(t, { [n]: a }), a;\n}, \"importAndCache\"), xc = /* @__PURE__ */ o((e, t) => {\n  if (Si(e)) {\n    let r = e.export({ format: \"jwk\" });\n    return delete r.d, delete r.dp, delete r.dq, delete r.p, delete r.q, delete r.qi, r.k ? xi(r.k) : (Ve || (Ve = /* @__PURE__ */ new WeakMap()), fr(Ve, e, r, t));\n  }\n  return ke(e) ? e.k ? W(e.k) : (Ve || (Ve = /* @__PURE__ */ new WeakMap()), fr(Ve, e, e, t, !0)) : e;\n}, \"normalizePublicKey\"), Sc = /* @__PURE__ */ o((e, t) => {\n  if (Si(e)) {\n    let r = e.export({ format: \"jwk\" });\n    return r.k ? xi(r.k) : (je || (je = /* @__PURE__ */ new WeakMap()), fr(je, e, r, t));\n  }\n  return ke(e) ? e.k ? W(e.k) : (je || (je = /* @__PURE__ */ new WeakMap()), fr(je, e, e, t, !0)) : e;\n}, \"normalizePrivateKey\"), Ie = { normalizePublicKey: xc, normalizePrivateKey: Sc };\n\n// node_modules/jose/dist/browser/lib/cek.js\nfunction ht(e) {\n  switch (e) {\n    case \"A128GCM\":\n      return 128;\n    case \"A192GCM\":\n      return 192;\n    case \"A256GCM\":\n    case \"A128CBC-HS256\":\n      return 256;\n    case \"A192CBC-HS384\":\n      return 384;\n    case \"A256CBC-HS512\":\n      return 512;\n    default:\n      throw new E(`Unsupported JWE Algorithm: ${e}`);\n  }\n}\no(ht, \"bitLength\");\nvar he = /* @__PURE__ */ o((e) => $e(new Uint8Array(ht(e) >> 3)), \"default\");\n\n// node_modules/jose/dist/browser/runtime/asn1.js\nvar me = /* @__PURE__ */ o((e, t, r = 0) => {\n  r === 0 && (t.unshift(t.length), t.unshift(6));\n  let n = e.indexOf(t[0], r);\n  if (n === -1)\n    return !1;\n  let i = e.subarray(n, n + t.length);\n  return i.length !== t.length ? !1 : i.every((s, a) => s === t[a]) || me(e, t, n + 1);\n}, \"findOid\"), vi = /* @__PURE__ */ o((e) => {\n  switch (!0) {\n    case me(e, [42, 134, 72, 206, 61, 3, 1, 7]):\n      return \"P-256\";\n    case me(e, [43, 129, 4, 0, 34]):\n      return \"P-384\";\n    case me(e, [43, 129, 4, 0, 35]):\n      return \"P-521\";\n    case me(e, [43, 101, 110]):\n      return \"X25519\";\n    case me(e, [43, 101, 111]):\n      return \"X448\";\n    case me(e, [43, 101, 112]):\n      return \"Ed25519\";\n    case me(e, [43, 101, 113]):\n      return \"Ed448\";\n    default:\n      throw new E(\"Invalid or unsupported EC Key Curve or OKP Key Sub Type\");\n  }\n}, \"getNamedCurve\"), vc = /* @__PURE__ */ o(async (e, t, r, n, i) => {\n  let s, a, c = new Uint8Array(atob(r.replace(e, \"\")).split(\"\").map((u) => u.charCodeAt(0))), d = t === \"spki\";\n  switch (n) {\n    case \"PS256\":\n    case \"PS384\":\n    case \"PS512\":\n      s = { name: \"RSA-PSS\", hash: `SHA-${n.slice(-3)}` }, a = d ? [\"verify\"] : [\"sign\"];\n      break;\n    case \"RS256\":\n    case \"RS384\":\n    case \"RS512\":\n      s = { name: \"RSASSA-PKCS1-v1_5\", hash: `SHA-${n.slice(-3)}` }, a = d ? [\"verify\"] : [\"sign\"];\n      break;\n    case \"RSA-OAEP\":\n    case \"RSA-OAEP-256\":\n    case \"RSA-OAEP-384\":\n    case \"RSA-OAEP-512\":\n      s = {\n        name: \"RSA-OAEP\",\n        hash: `SHA-${parseInt(n.slice(-3), 10) || 1}`\n      }, a = d ? [\"encrypt\", \"wrapKey\"] : [\"decrypt\", \"unwrapKey\"];\n      break;\n    case \"ES256\":\n      s = { name: \"ECDSA\", namedCurve: \"P-256\" }, a = d ? [\"verify\"] : [\"sign\"];\n      break;\n    case \"ES384\":\n      s = { name: \"ECDSA\", namedCurve: \"P-384\" }, a = d ? [\"verify\"] : [\"sign\"];\n      break;\n    case \"ES512\":\n      s = { name: \"ECDSA\", namedCurve: \"P-521\" }, a = d ? [\"verify\"] : [\"sign\"];\n      break;\n    case \"ECDH-ES\":\n    case \"ECDH-ES+A128KW\":\n    case \"ECDH-ES+A192KW\":\n    case \"ECDH-ES+A256KW\": {\n      let u = vi(c);\n      s = u.startsWith(\"P-\") ? { name: \"ECDH\", namedCurve: u } : { name: u }, a = d ? [] : [\"deriveBits\"];\n      break;\n    }\n    case \"Ed25519\":\n      s = { name: \"Ed25519\" }, a = d ? [\"verify\"] : [\"sign\"];\n      break;\n    case \"EdDSA\":\n      s = { name: vi(c) }, a = d ? [\"verify\"] : [\"sign\"];\n      break;\n    default:\n      throw new E('Invalid or unsupported \"alg\" (Algorithm) value');\n  }\n  return _.subtle.importKey(t, c, s, i?.extractable ?? !1, a);\n}, \"genericImport\"), Ai = /* @__PURE__ */ o((e, t, r) => vc(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, \"pkcs8\", e, t, r), \"fromPKCS8\");\n\n// node_modules/jose/dist/browser/key/import.js\nasync function En(e, t, r) {\n  if (typeof e != \"string\" || e.indexOf(\"-----BEGIN PRIVATE KEY-----\") !== 0)\n    throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n  return Ai(e, t, r);\n}\no(En, \"importPKCS8\");\nasync function kn(e, t) {\n  if (!z(e))\n    throw new TypeError(\"JWK must be an object\");\n  switch (t || (t = e.alg), e.kty) {\n    case \"oct\":\n      if (typeof e.k != \"string\" || !e.k)\n        throw new TypeError('missing \"k\" (Key Value) Parameter value');\n      return W(e.k);\n    case \"RSA\":\n      if (\"oth\" in e && e.oth !== void 0)\n        throw new E('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n    case \"EC\":\n    case \"OKP\":\n      return lr({ ...e, alg: t });\n    default:\n      throw new E('Unsupported \"kty\" (Key Type) Parameter value');\n  }\n}\no(kn, \"importJWK\");\n\n// node_modules/jose/dist/browser/lib/check_key_type.js\nvar Fe = /* @__PURE__ */ o((e) => e?.[Symbol.toStringTag], \"tag\"), In = /* @__PURE__ */ o((e, t, r) => {\n  if (t.use !== void 0 && t.use !== \"sig\")\n    throw new TypeError(\"Invalid key for this operation, when present its use must be sig\");\n  if (t.key_ops !== void 0 && t.key_ops.includes?.(r) !== !0)\n    throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${r}`);\n  if (t.alg !== void 0 && t.alg !== e)\n    throw new TypeError(`Invalid key for this operation, when present its alg must be ${e}`);\n  return !0;\n}, \"jwkMatchesOp\"), Ac = /* @__PURE__ */ o((e, t, r, n) => {\n  if (!(t instanceof Uint8Array)) {\n    if (n && ke(t)) {\n      if (_i(t) && In(e, t, r))\n        return;\n      throw new TypeError('JSON Web Key for symmetric algorithms must have JWK \"kty\" (Key Type) equal to \"oct\" and the JWK \"k\" (Key Value) present');\n    }\n    if (!vn(t))\n      throw new TypeError(Sn(e, t, ...H, \"Uint8Array\", n ? \"JSON Web Key\" : null));\n    if (t.type !== \"secret\")\n      throw new TypeError(`${Fe(t)} instances for symmetric algorithms must be of type \"secret\"`);\n  }\n}, \"symmetricTypeCheck\"), Ec = /* @__PURE__ */ o((e, t, r, n) => {\n  if (n && ke(t))\n    switch (r) {\n      case \"sign\":\n        if (gi(t) && In(e, t, r))\n          return;\n        throw new TypeError(\"JSON Web Key for this operation be a private JWK\");\n      case \"verify\":\n        if (bi(t) && In(e, t, r))\n          return;\n        throw new TypeError(\"JSON Web Key for this operation be a public JWK\");\n    }\n  if (!vn(t))\n    throw new TypeError(Sn(e, t, ...H, n ? \"JSON Web Key\" : null));\n  if (t.type === \"secret\")\n    throw new TypeError(`${Fe(t)} instances for asymmetric algorithms must not be of type \"secret\"`);\n  if (r === \"sign\" && t.type === \"public\")\n    throw new TypeError(`${Fe(t)} instances for asymmetric algorithm signing must be of type \"private\"`);\n  if (r === \"decrypt\" && t.type === \"public\")\n    throw new TypeError(`${Fe(t)} instances for asymmetric algorithm decryption must be of type \"private\"`);\n  if (t.algorithm && r === \"verify\" && t.type === \"private\")\n    throw new TypeError(`${Fe(t)} instances for asymmetric algorithm verifying must be of type \"public\"`);\n  if (t.algorithm && r === \"encrypt\" && t.type === \"private\")\n    throw new TypeError(`${Fe(t)} instances for asymmetric algorithm encryption must be of type \"public\"`);\n}, \"asymmetricTypeCheck\");\nfunction Ei(e, t, r, n) {\n  t.startsWith(\"HS\") || t === \"dir\" || t.startsWith(\"PBES2\") || /^A\\d{3}(?:GCM)?KW$/.test(t) ? Ac(t, r, n, e) : Ec(t, r, n, e);\n}\no(Ei, \"checkKeyType\");\nvar pr = Ei.bind(void 0, !1), ki = Ei.bind(void 0, !0);\n\n// node_modules/jose/dist/browser/runtime/encrypt.js\nasync function kc(e, t, r, n, i) {\n  if (!(r instanceof Uint8Array))\n    throw new TypeError(N(r, \"Uint8Array\"));\n  let s = parseInt(e.slice(1, 4), 10), a = await _.subtle.importKey(\"raw\", r.subarray(s >> 3), \"AES-CBC\", !1, [\"encrypt\"]), c = await _.subtle.importKey(\"raw\", r.subarray(0, s >> 3), {\n    hash: `SHA-${s << 1}`,\n    name: \"HMAC\"\n  }, !1, [\"sign\"]), d = new Uint8Array(await _.subtle.encrypt({\n    iv: n,\n    name: \"AES-CBC\"\n  }, a, t)), u = j(i, n, d, nr(i.length << 3)), f = new Uint8Array((await _.subtle.sign(\"HMAC\", c, u)).slice(0, s >> 3));\n  return { ciphertext: d, tag: f, iv: n };\n}\no(kc, \"cbcEncrypt\");\nasync function Ic(e, t, r, n, i) {\n  let s;\n  r instanceof Uint8Array ? s = await _.subtle.importKey(\"raw\", r, \"AES-GCM\", !1, [\"encrypt\"]) : (G(r, e, \"encrypt\"), s = r);\n  let a = new Uint8Array(await _.subtle.encrypt({\n    additionalData: i,\n    iv: n,\n    name: \"AES-GCM\",\n    tagLength: 128\n  }, s, t)), c = a.slice(-16);\n  return { ciphertext: a.slice(0, -16), tag: c, iv: n };\n}\no(Ic, \"gcmEncrypt\");\nvar Tc = /* @__PURE__ */ o(async (e, t, r, n, i) => {\n  if (!K(r) && !(r instanceof Uint8Array))\n    throw new TypeError(N(r, ...H, \"Uint8Array\"));\n  switch (n ? sr(e, n) : n = oi(e), e) {\n    case \"A128CBC-HS256\":\n    case \"A192CBC-HS384\":\n    case \"A256CBC-HS512\":\n      return r instanceof Uint8Array && Be(r, parseInt(e.slice(-3), 10)), kc(e, t, r, n, i);\n    case \"A128GCM\":\n    case \"A192GCM\":\n    case \"A256GCM\":\n      return r instanceof Uint8Array && Be(r, parseInt(e.slice(1, 4), 10)), Ic(e, t, r, n, i);\n    default:\n      throw new E(\"Unsupported JWE Content Encryption Algorithm\");\n  }\n}, \"encrypt\"), hr = Tc;\n\n// node_modules/jose/dist/browser/lib/aesgcmkw.js\nasync function Ii(e, t, r, n) {\n  let i = e.slice(0, 7), s = await hr(i, r, t, n, new Uint8Array(0));\n  return {\n    encryptedKey: s.ciphertext,\n    iv: O(s.iv),\n    tag: O(s.tag)\n  };\n}\no(Ii, \"wrap\");\nasync function Ti(e, t, r, n, i) {\n  let s = e.slice(0, 7);\n  return cr(s, t, r, n, i, new Uint8Array(0));\n}\no(Ti, \"unwrap\");\n\n// node_modules/jose/dist/browser/lib/decrypt_key_management.js\nasync function Rc(e, t, r, n, i) {\n  switch (pr(e, t, \"decrypt\"), t = await Ie.normalizePrivateKey?.(t, e) || t, e) {\n    case \"dir\": {\n      if (r !== void 0)\n        throw new w(\"Encountered unexpected JWE Encrypted Key\");\n      return t;\n    }\n    case \"ECDH-ES\":\n      if (r !== void 0)\n        throw new w(\"Encountered unexpected JWE Encrypted Key\");\n    case \"ECDH-ES+A128KW\":\n    case \"ECDH-ES+A192KW\":\n    case \"ECDH-ES+A256KW\": {\n      if (!z(n.epk))\n        throw new w('JOSE Header \"epk\" (Ephemeral Public Key) missing or invalid');\n      if (!dr(t))\n        throw new E(\"ECDH with the provided key is not allowed or not supported by your javascript runtime\");\n      let s = await kn(n.epk, e), a, c;\n      if (n.apu !== void 0) {\n        if (typeof n.apu != \"string\")\n          throw new w('JOSE Header \"apu\" (Agreement PartyUInfo) invalid');\n        try {\n          a = W(n.apu);\n        } catch {\n          throw new w(\"Failed to base64url decode the apu\");\n        }\n      }\n      if (n.apv !== void 0) {\n        if (typeof n.apv != \"string\")\n          throw new w('JOSE Header \"apv\" (Agreement PartyVInfo) invalid');\n        try {\n          c = W(n.apv);\n        } catch {\n          throw new w(\"Failed to base64url decode the apv\");\n        }\n      }\n      let d = await ur(s, t, e === \"ECDH-ES\" ? n.enc : e, e === \"ECDH-ES\" ? ht(n.enc) : parseInt(e.slice(-5, -2), 10), a, c);\n      if (e === \"ECDH-ES\")\n        return d;\n      if (r === void 0)\n        throw new w(\"JWE Encrypted Key missing\");\n      return ft(e.slice(-6), d, r);\n    }\n    case \"RSA1_5\":\n    case \"RSA-OAEP\":\n    case \"RSA-OAEP-256\":\n    case \"RSA-OAEP-384\":\n    case \"RSA-OAEP-512\": {\n      if (r === void 0)\n        throw new w(\"JWE Encrypted Key missing\");\n      return wi(e, t, r);\n    }\n    case \"PBES2-HS256+A128KW\":\n    case \"PBES2-HS384+A192KW\":\n    case \"PBES2-HS512+A256KW\": {\n      if (r === void 0)\n        throw new w(\"JWE Encrypted Key missing\");\n      if (typeof n.p2c != \"number\")\n        throw new w('JOSE Header \"p2c\" (PBES2 Count) missing or invalid');\n      let s = i?.maxPBES2Count || 1e4;\n      if (n.p2c > s)\n        throw new w('JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds');\n      if (typeof n.p2s != \"string\")\n        throw new w('JOSE Header \"p2s\" (PBES2 Salt) missing or invalid');\n      let a;\n      try {\n        a = W(n.p2s);\n      } catch {\n        throw new w(\"Failed to base64url decode the p2s\");\n      }\n      return mi(e, t, r, n.p2c, a);\n    }\n    case \"A128KW\":\n    case \"A192KW\":\n    case \"A256KW\": {\n      if (r === void 0)\n        throw new w(\"JWE Encrypted Key missing\");\n      return ft(e, t, r);\n    }\n    case \"A128GCMKW\":\n    case \"A192GCMKW\":\n    case \"A256GCMKW\": {\n      if (r === void 0)\n        throw new w(\"JWE Encrypted Key missing\");\n      if (typeof n.iv != \"string\")\n        throw new w('JOSE Header \"iv\" (Initialization Vector) missing or invalid');\n      if (typeof n.tag != \"string\")\n        throw new w('JOSE Header \"tag\" (Authentication Tag) missing or invalid');\n      let s;\n      try {\n        s = W(n.iv);\n      } catch {\n        throw new w(\"Failed to base64url decode the iv\");\n      }\n      let a;\n      try {\n        a = W(n.tag);\n      } catch {\n        throw new w(\"Failed to base64url decode the tag\");\n      }\n      return Ti(e, t, r, s, a);\n    }\n    default:\n      throw new E('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n  }\n}\no(Rc, \"decryptKeyManagement\");\nvar Ri = Rc;\n\n// node_modules/jose/dist/browser/lib/validate_crit.js\nfunction Cc(e, t, r, n, i) {\n  if (i.crit !== void 0 && n?.crit === void 0)\n    throw new e('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n  if (!n || n.crit === void 0)\n    return /* @__PURE__ */ new Set();\n  if (!Array.isArray(n.crit) || n.crit.length === 0 || n.crit.some((a) => typeof a != \"string\" || a.length === 0))\n    throw new e('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n  let s;\n  r !== void 0 ? s = new Map([...Object.entries(r), ...t.entries()]) : s = t;\n  for (let a of n.crit) {\n    if (!s.has(a))\n      throw new E(`Extension Header Parameter \"${a}\" is not recognized`);\n    if (i[a] === void 0)\n      throw new e(`Extension Header Parameter \"${a}\" is missing`);\n    if (s.get(a) && n[a] === void 0)\n      throw new e(`Extension Header Parameter \"${a}\" MUST be integrity protected`);\n  }\n  return new Set(n.crit);\n}\no(Cc, \"validateCrit\");\nvar Ge = Cc;\n\n// node_modules/jose/dist/browser/lib/validate_algorithms.js\nvar Pc = /* @__PURE__ */ o((e, t) => {\n  if (t !== void 0 && (!Array.isArray(t) || t.some((r) => typeof r != \"string\")))\n    throw new TypeError(`\"${e}\" option must be an array of strings`);\n  if (t)\n    return new Set(t);\n}, \"validateAlgorithms\"), Tn = Pc;\n\n// node_modules/jose/dist/browser/jwe/flattened/decrypt.js\nasync function Ci(e, t, r) {\n  if (!z(e))\n    throw new w(\"Flattened JWE must be an object\");\n  if (e.protected === void 0 && e.header === void 0 && e.unprotected === void 0)\n    throw new w(\"JOSE Header missing\");\n  if (e.iv !== void 0 && typeof e.iv != \"string\")\n    throw new w(\"JWE Initialization Vector incorrect type\");\n  if (typeof e.ciphertext != \"string\")\n    throw new w(\"JWE Ciphertext missing or incorrect type\");\n  if (e.tag !== void 0 && typeof e.tag != \"string\")\n    throw new w(\"JWE Authentication Tag incorrect type\");\n  if (e.protected !== void 0 && typeof e.protected != \"string\")\n    throw new w(\"JWE Protected Header incorrect type\");\n  if (e.encrypted_key !== void 0 && typeof e.encrypted_key != \"string\")\n    throw new w(\"JWE Encrypted Key incorrect type\");\n  if (e.aad !== void 0 && typeof e.aad != \"string\")\n    throw new w(\"JWE AAD incorrect type\");\n  if (e.header !== void 0 && !z(e.header))\n    throw new w(\"JWE Shared Unprotected Header incorrect type\");\n  if (e.unprotected !== void 0 && !z(e.unprotected))\n    throw new w(\"JWE Per-Recipient Unprotected Header incorrect type\");\n  let n;\n  if (e.protected)\n    try {\n      let k = W(e.protected);\n      n = JSON.parse(Q.decode(k));\n    } catch {\n      throw new w(\"JWE Protected Header is invalid\");\n    }\n  if (!Je(n, e.header, e.unprotected))\n    throw new w(\"JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint\");\n  let i = {\n    ...n,\n    ...e.header,\n    ...e.unprotected\n  };\n  if (Ge(w, /* @__PURE__ */ new Map(), r?.crit, n, i), i.zip !== void 0)\n    throw new E('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n  let { alg: s, enc: a } = i;\n  if (typeof s != \"string\" || !s)\n    throw new w(\"missing JWE Algorithm (alg) in JWE Header\");\n  if (typeof a != \"string\" || !a)\n    throw new w(\"missing JWE Encryption Algorithm (enc) in JWE Header\");\n  let c = r && Tn(\"keyManagementAlgorithms\", r.keyManagementAlgorithms), d = r && Tn(\"contentEncryptionAlgorithms\", r.contentEncryptionAlgorithms);\n  if (c && !c.has(s) || !c && s.startsWith(\"PBES2\"))\n    throw new We('\"alg\" (Algorithm) Header Parameter value not allowed');\n  if (d && !d.has(a))\n    throw new We('\"enc\" (Encryption Algorithm) Header Parameter value not allowed');\n  let u;\n  if (e.encrypted_key !== void 0)\n    try {\n      u = W(e.encrypted_key);\n    } catch {\n      throw new w(\"Failed to base64url decode the encrypted_key\");\n    }\n  let f = !1;\n  typeof t == \"function\" && (t = await t(n, e), f = !0);\n  let l;\n  try {\n    l = await Ri(s, t, u, i, r);\n  } catch (k) {\n    if (k instanceof TypeError || k instanceof w || k instanceof E)\n      throw k;\n    l = he(a);\n  }\n  let y, p;\n  if (e.iv !== void 0)\n    try {\n      y = W(e.iv);\n    } catch {\n      throw new w(\"Failed to base64url decode the iv\");\n    }\n  if (e.tag !== void 0)\n    try {\n      p = W(e.tag);\n    } catch {\n      throw new w(\"Failed to base64url decode the tag\");\n    }\n  let m = U.encode(e.protected ?? \"\"), S;\n  e.aad !== void 0 ? S = j(m, U.encode(\".\"), U.encode(e.aad)) : S = m;\n  let I;\n  try {\n    I = W(e.ciphertext);\n  } catch {\n    throw new w(\"Failed to base64url decode the ciphertext\");\n  }\n  let b = { plaintext: await cr(a, l, I, y, p, S) };\n  if (e.protected !== void 0 && (b.protectedHeader = n), e.aad !== void 0)\n    try {\n      b.additionalAuthenticatedData = W(e.aad);\n    } catch {\n      throw new w(\"Failed to base64url decode the aad\");\n    }\n  return e.unprotected !== void 0 && (b.sharedUnprotectedHeader = e.unprotected), e.header !== void 0 && (b.unprotectedHeader = e.header), f ? { ...b, key: t } : b;\n}\no(Ci, \"flattenedDecrypt\");\n\n// node_modules/jose/dist/browser/jwe/compact/decrypt.js\nasync function Pi(e, t, r) {\n  if (e instanceof Uint8Array && (e = Q.decode(e)), typeof e != \"string\")\n    throw new w(\"Compact JWE must be a string or Uint8Array\");\n  let { 0: n, 1: i, 2: s, 3: a, 4: c, length: d } = e.split(\".\");\n  if (d !== 5)\n    throw new w(\"Invalid Compact JWE\");\n  let u = await Ci({\n    ciphertext: a,\n    iv: s || void 0,\n    protected: n,\n    tag: c || void 0,\n    encrypted_key: i || void 0\n  }, t, r), f = { plaintext: u.plaintext, protectedHeader: u.protectedHeader };\n  return typeof t == \"function\" ? { ...f, key: u.key } : f;\n}\no(Pi, \"compactDecrypt\");\n\n// node_modules/jose/dist/browser/lib/private_symbols.js\nvar Ui = Symbol();\n\n// node_modules/jose/dist/browser/runtime/key_to_jwk.js\nvar Uc = /* @__PURE__ */ o(async (e) => {\n  if (e instanceof Uint8Array)\n    return {\n      kty: \"oct\",\n      k: O(e)\n    };\n  if (!K(e))\n    throw new TypeError(N(e, ...H, \"Uint8Array\"));\n  if (!e.extractable)\n    throw new TypeError(\"non-extractable CryptoKey cannot be exported as a JWK\");\n  let { ext: t, key_ops: r, alg: n, use: i, ...s } = await _.subtle.exportKey(\"jwk\", e);\n  return s;\n}, \"keyToJWK\"), Oi = Uc;\n\n// node_modules/jose/dist/browser/key/export.js\nasync function Li(e) {\n  return Oi(e);\n}\no(Li, \"exportJWK\");\n\n// node_modules/jose/dist/browser/lib/encrypt_key_management.js\nasync function Oc(e, t, r, n, i = {}) {\n  let s, a, c;\n  switch (pr(e, r, \"encrypt\"), r = await Ie.normalizePublicKey?.(r, e) || r, e) {\n    case \"dir\": {\n      c = r;\n      break;\n    }\n    case \"ECDH-ES\":\n    case \"ECDH-ES+A128KW\":\n    case \"ECDH-ES+A192KW\":\n    case \"ECDH-ES+A256KW\": {\n      if (!dr(r))\n        throw new E(\"ECDH with the provided key is not allowed or not supported by your javascript runtime\");\n      let { apu: d, apv: u } = i, { epk: f } = i;\n      f || (f = (await li(r)).privateKey);\n      let { x: l, y, crv: p, kty: m } = await Li(f), S = await ur(r, f, e === \"ECDH-ES\" ? t : e, e === \"ECDH-ES\" ? ht(t) : parseInt(e.slice(-5, -2), 10), d, u);\n      if (a = { epk: { x: l, crv: p, kty: m } }, m === \"EC\" && (a.epk.y = y), d && (a.apu = O(d)), u && (a.apv = O(u)), e === \"ECDH-ES\") {\n        c = S;\n        break;\n      }\n      c = n || he(t);\n      let I = e.slice(-6);\n      s = await lt(I, S, c);\n      break;\n    }\n    case \"RSA1_5\":\n    case \"RSA-OAEP\":\n    case \"RSA-OAEP-256\":\n    case \"RSA-OAEP-384\":\n    case \"RSA-OAEP-512\": {\n      c = n || he(t), s = await yi(e, r, c);\n      break;\n    }\n    case \"PBES2-HS256+A128KW\":\n    case \"PBES2-HS384+A192KW\":\n    case \"PBES2-HS512+A256KW\": {\n      c = n || he(t);\n      let { p2c: d, p2s: u } = i;\n      ({ encryptedKey: s, ...a } = await hi(e, r, c, d, u));\n      break;\n    }\n    case \"A128KW\":\n    case \"A192KW\":\n    case \"A256KW\": {\n      c = n || he(t), s = await lt(e, r, c);\n      break;\n    }\n    case \"A128GCMKW\":\n    case \"A192GCMKW\":\n    case \"A256GCMKW\": {\n      c = n || he(t);\n      let { iv: d } = i;\n      ({ encryptedKey: s, ...a } = await Ii(e, r, c, d));\n      break;\n    }\n    default:\n      throw new E('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n  }\n  return { cek: c, encryptedKey: s, parameters: a };\n}\no(Oc, \"encryptKeyManagement\");\nvar Hi = Oc;\n\n// node_modules/jose/dist/browser/jwe/flattened/encrypt.js\nvar mr = class {\n  static {\n    o(this, \"FlattenedEncrypt\");\n  }\n  constructor(t) {\n    if (!(t instanceof Uint8Array))\n      throw new TypeError(\"plaintext must be an instance of Uint8Array\");\n    this._plaintext = t;\n  }\n  setKeyManagementParameters(t) {\n    if (this._keyManagementParameters)\n      throw new TypeError(\"setKeyManagementParameters can only be called once\");\n    return this._keyManagementParameters = t, this;\n  }\n  setProtectedHeader(t) {\n    if (this._protectedHeader)\n      throw new TypeError(\"setProtectedHeader can only be called once\");\n    return this._protectedHeader = t, this;\n  }\n  setSharedUnprotectedHeader(t) {\n    if (this._sharedUnprotectedHeader)\n      throw new TypeError(\"setSharedUnprotectedHeader can only be called once\");\n    return this._sharedUnprotectedHeader = t, this;\n  }\n  setUnprotectedHeader(t) {\n    if (this._unprotectedHeader)\n      throw new TypeError(\"setUnprotectedHeader can only be called once\");\n    return this._unprotectedHeader = t, this;\n  }\n  setAdditionalAuthenticatedData(t) {\n    return this._aad = t, this;\n  }\n  setContentEncryptionKey(t) {\n    if (this._cek)\n      throw new TypeError(\"setContentEncryptionKey can only be called once\");\n    return this._cek = t, this;\n  }\n  setInitializationVector(t) {\n    if (this._iv)\n      throw new TypeError(\"setInitializationVector can only be called once\");\n    return this._iv = t, this;\n  }\n  async encrypt(t, r) {\n    if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader)\n      throw new w(\"either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()\");\n    if (!Je(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader))\n      throw new w(\"JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint\");\n    let n = {\n      ...this._protectedHeader,\n      ...this._unprotectedHeader,\n      ...this._sharedUnprotectedHeader\n    };\n    if (Ge(w, /* @__PURE__ */ new Map(), r?.crit, this._protectedHeader, n), n.zip !== void 0)\n      throw new E('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n    let { alg: i, enc: s } = n;\n    if (typeof i != \"string\" || !i)\n      throw new w('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n    if (typeof s != \"string\" || !s)\n      throw new w('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n    let a;\n    if (this._cek && (i === \"dir\" || i === \"ECDH-ES\"))\n      throw new TypeError(`setContentEncryptionKey cannot be called with JWE \"alg\" (Algorithm) Header ${i}`);\n    let c;\n    {\n      let S;\n      ({ cek: c, encryptedKey: a, parameters: S } = await Hi(i, s, t, this._cek, this._keyManagementParameters)), S && (r && Ui in r ? this._unprotectedHeader ? this._unprotectedHeader = { ...this._unprotectedHeader, ...S } : this.setUnprotectedHeader(S) : this._protectedHeader ? this._protectedHeader = { ...this._protectedHeader, ...S } : this.setProtectedHeader(S));\n    }\n    let d, u, f;\n    this._protectedHeader ? u = U.encode(O(JSON.stringify(this._protectedHeader))) : u = U.encode(\"\"), this._aad ? (f = O(this._aad), d = j(u, U.encode(\".\"), U.encode(f))) : d = u;\n    let { ciphertext: l, tag: y, iv: p } = await hr(s, this._plaintext, c, this._iv, d), m = {\n      ciphertext: O(l)\n    };\n    return p && (m.iv = O(p)), y && (m.tag = O(y)), a && (m.encrypted_key = O(a)), f && (m.aad = f), this._protectedHeader && (m.protected = Q.decode(u)), this._sharedUnprotectedHeader && (m.unprotected = this._sharedUnprotectedHeader), this._unprotectedHeader && (m.header = this._unprotectedHeader), m;\n  }\n};\n\n// node_modules/jose/dist/browser/runtime/subtle_dsa.js\nfunction Rn(e, t) {\n  let r = `SHA-${e.slice(-3)}`;\n  switch (e) {\n    case \"HS256\":\n    case \"HS384\":\n    case \"HS512\":\n      return { hash: r, name: \"HMAC\" };\n    case \"PS256\":\n    case \"PS384\":\n    case \"PS512\":\n      return { hash: r, name: \"RSA-PSS\", saltLength: e.slice(-3) >> 3 };\n    case \"RS256\":\n    case \"RS384\":\n    case \"RS512\":\n      return { hash: r, name: \"RSASSA-PKCS1-v1_5\" };\n    case \"ES256\":\n    case \"ES384\":\n    case \"ES512\":\n      return { hash: r, name: \"ECDSA\", namedCurve: t.namedCurve };\n    case \"Ed25519\":\n      return { name: \"Ed25519\" };\n    case \"EdDSA\":\n      return { name: t.name };\n    default:\n      throw new E(`alg ${e} is not supported either by JOSE or your javascript runtime`);\n  }\n}\no(Rn, \"subtleDsa\");\n\n// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js\nasync function Cn(e, t, r) {\n  if (r === \"sign\" && (t = await Ie.normalizePrivateKey(t, e)), r === \"verify\" && (t = await Ie.normalizePublicKey(t, e)), K(t))\n    return ai(t, e, r), t;\n  if (t instanceof Uint8Array) {\n    if (!e.startsWith(\"HS\"))\n      throw new TypeError(N(t, ...H));\n    return _.subtle.importKey(\"raw\", t, { hash: `SHA-${e.slice(-3)}`, name: \"HMAC\" }, !1, [r]);\n  }\n  throw new TypeError(N(t, ...H, \"Uint8Array\", \"JSON Web Key\"));\n}\no(Cn, \"getCryptoKey\");\n\n// node_modules/jose/dist/browser/lib/epoch.js\nvar se = /* @__PURE__ */ o((e) => Math.floor(e.getTime() / 1e3), \"default\");\n\n// node_modules/jose/dist/browser/lib/secs.js\nvar Lc = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i, Te = /* @__PURE__ */ o((e) => {\n  let t = Lc.exec(e);\n  if (!t || t[4] && t[1])\n    throw new TypeError(\"Invalid time period format\");\n  let r = parseFloat(t[2]), n = t[3].toLowerCase(), i;\n  switch (n) {\n    case \"sec\":\n    case \"secs\":\n    case \"second\":\n    case \"seconds\":\n    case \"s\":\n      i = Math.round(r);\n      break;\n    case \"minute\":\n    case \"minutes\":\n    case \"min\":\n    case \"mins\":\n    case \"m\":\n      i = Math.round(r * 60);\n      break;\n    case \"hour\":\n    case \"hours\":\n    case \"hr\":\n    case \"hrs\":\n    case \"h\":\n      i = Math.round(r * 3600);\n      break;\n    case \"day\":\n    case \"days\":\n    case \"d\":\n      i = Math.round(r * 86400);\n      break;\n    case \"week\":\n    case \"weeks\":\n    case \"w\":\n      i = Math.round(r * 604800);\n      break;\n    default:\n      i = Math.round(r * 31557600);\n      break;\n  }\n  return t[1] === \"-\" || t[4] === \"ago\" ? -i : i;\n}, \"default\");\n\n// node_modules/jose/dist/browser/lib/jwt_claims_set.js\nvar Di = /* @__PURE__ */ o((e) => e.toLowerCase().replace(/^application\\//, \"\"), \"normalizeTyp\"), Hc = /* @__PURE__ */ o((e, t) => typeof e == \"string\" ? t.includes(e) : Array.isArray(e) ? t.some(Set.prototype.has.bind(new Set(e))) : !1, \"checkAudiencePresence\"), Ki = /* @__PURE__ */ o((e, t, r = {}) => {\n  let n;\n  try {\n    n = JSON.parse(Q.decode(t));\n  } catch {\n  }\n  if (!z(n))\n    throw new Ee(\"JWT Claims Set must be a top-level JSON object\");\n  let { typ: i } = r;\n  if (i && (typeof e.typ != \"string\" || Di(e.typ) !== Di(i)))\n    throw new B('unexpected \"typ\" JWT header value', n, \"typ\", \"check_failed\");\n  let { requiredClaims: s = [], issuer: a, subject: c, audience: d, maxTokenAge: u } = r, f = [...s];\n  u !== void 0 && f.push(\"iat\"), d !== void 0 && f.push(\"aud\"), c !== void 0 && f.push(\"sub\"), a !== void 0 && f.push(\"iss\");\n  for (let m of new Set(f.reverse()))\n    if (!(m in n))\n      throw new B(`missing required \"${m}\" claim`, n, m, \"missing\");\n  if (a && !(Array.isArray(a) ? a : [a]).includes(n.iss))\n    throw new B('unexpected \"iss\" claim value', n, \"iss\", \"check_failed\");\n  if (c && n.sub !== c)\n    throw new B('unexpected \"sub\" claim value', n, \"sub\", \"check_failed\");\n  if (d && !Hc(n.aud, typeof d == \"string\" ? [d] : d))\n    throw new B('unexpected \"aud\" claim value', n, \"aud\", \"check_failed\");\n  let l;\n  switch (typeof r.clockTolerance) {\n    case \"string\":\n      l = Te(r.clockTolerance);\n      break;\n    case \"number\":\n      l = r.clockTolerance;\n      break;\n    case \"undefined\":\n      l = 0;\n      break;\n    default:\n      throw new TypeError(\"Invalid clockTolerance option type\");\n  }\n  let { currentDate: y } = r, p = se(y || /* @__PURE__ */ new Date());\n  if ((n.iat !== void 0 || u) && typeof n.iat != \"number\")\n    throw new B('\"iat\" claim must be a number', n, \"iat\", \"invalid\");\n  if (n.nbf !== void 0) {\n    if (typeof n.nbf != \"number\")\n      throw new B('\"nbf\" claim must be a number', n, \"nbf\", \"invalid\");\n    if (n.nbf > p + l)\n      throw new B('\"nbf\" claim timestamp check failed', n, \"nbf\", \"check_failed\");\n  }\n  if (n.exp !== void 0) {\n    if (typeof n.exp != \"number\")\n      throw new B('\"exp\" claim must be a number', n, \"exp\", \"invalid\");\n    if (n.exp <= p - l)\n      throw new Ne('\"exp\" claim timestamp check failed', n, \"exp\", \"check_failed\");\n  }\n  if (u) {\n    let m = p - n.iat, S = typeof u == \"number\" ? u : Te(u);\n    if (m - l > S)\n      throw new Ne('\"iat\" claim timestamp check failed (too far in the past)', n, \"iat\", \"check_failed\");\n    if (m < 0 - l)\n      throw new B('\"iat\" claim timestamp check failed (it should be in the past)', n, \"iat\", \"check_failed\");\n  }\n  return n;\n}, \"default\");\n\n// node_modules/jose/dist/browser/jwt/decrypt.js\nasync function Pn(e, t, r) {\n  let n = await Pi(e, t, r), i = Ki(n.protectedHeader, n.plaintext, r), { protectedHeader: s } = n;\n  if (s.iss !== void 0 && s.iss !== i.iss)\n    throw new B('replicated \"iss\" claim header parameter mismatch', i, \"iss\", \"mismatch\");\n  if (s.sub !== void 0 && s.sub !== i.sub)\n    throw new B('replicated \"sub\" claim header parameter mismatch', i, \"sub\", \"mismatch\");\n  if (s.aud !== void 0 && JSON.stringify(s.aud) !== JSON.stringify(i.aud))\n    throw new B('replicated \"aud\" claim header parameter mismatch', i, \"aud\", \"mismatch\");\n  let a = { payload: i, protectedHeader: s };\n  return typeof t == \"function\" ? { ...a, key: n.key } : a;\n}\no(Pn, \"jwtDecrypt\");\n\n// node_modules/jose/dist/browser/jwe/compact/encrypt.js\nvar yr = class {\n  static {\n    o(this, \"CompactEncrypt\");\n  }\n  constructor(t) {\n    this._flattened = new mr(t);\n  }\n  setContentEncryptionKey(t) {\n    return this._flattened.setContentEncryptionKey(t), this;\n  }\n  setInitializationVector(t) {\n    return this._flattened.setInitializationVector(t), this;\n  }\n  setProtectedHeader(t) {\n    return this._flattened.setProtectedHeader(t), this;\n  }\n  setKeyManagementParameters(t) {\n    return this._flattened.setKeyManagementParameters(t), this;\n  }\n  async encrypt(t, r) {\n    let n = await this._flattened.encrypt(t, r);\n    return [n.protected, n.encrypted_key, n.iv, n.ciphertext, n.tag].join(\".\");\n  }\n};\n\n// node_modules/jose/dist/browser/runtime/sign.js\nvar Dc = /* @__PURE__ */ o(async (e, t, r) => {\n  let n = await Cn(e, t, \"sign\");\n  pt(e, n);\n  let i = await _.subtle.sign(Rn(e, n.algorithm), n, r);\n  return new Uint8Array(i);\n}, \"sign\"), Ni = Dc;\n\n// node_modules/jose/dist/browser/jws/flattened/sign.js\nvar wr = class {\n  static {\n    o(this, \"FlattenedSign\");\n  }\n  constructor(t) {\n    if (!(t instanceof Uint8Array))\n      throw new TypeError(\"payload must be an instance of Uint8Array\");\n    this._payload = t;\n  }\n  setProtectedHeader(t) {\n    if (this._protectedHeader)\n      throw new TypeError(\"setProtectedHeader can only be called once\");\n    return this._protectedHeader = t, this;\n  }\n  setUnprotectedHeader(t) {\n    if (this._unprotectedHeader)\n      throw new TypeError(\"setUnprotectedHeader can only be called once\");\n    return this._unprotectedHeader = t, this;\n  }\n  async sign(t, r) {\n    if (!this._protectedHeader && !this._unprotectedHeader)\n      throw new ue(\"either setProtectedHeader or setUnprotectedHeader must be called before #sign()\");\n    if (!Je(this._protectedHeader, this._unprotectedHeader))\n      throw new ue(\"JWS Protected and JWS Unprotected Header Parameter names must be disjoint\");\n    let n = {\n      ...this._protectedHeader,\n      ...this._unprotectedHeader\n    }, i = Ge(ue, /* @__PURE__ */ new Map([[\"b64\", !0]]), r?.crit, this._protectedHeader, n), s = !0;\n    if (i.has(\"b64\") && (s = this._protectedHeader.b64, typeof s != \"boolean\"))\n      throw new ue('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n    let { alg: a } = n;\n    if (typeof a != \"string\" || !a)\n      throw new ue('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    ki(a, t, \"sign\");\n    let c = this._payload;\n    s && (c = U.encode(O(c)));\n    let d;\n    this._protectedHeader ? d = U.encode(O(JSON.stringify(this._protectedHeader))) : d = U.encode(\"\");\n    let u = j(d, U.encode(\".\"), c), f = await Ni(a, t, u), l = {\n      signature: O(f),\n      payload: \"\"\n    };\n    return s && (l.payload = Q.decode(c)), this._unprotectedHeader && (l.header = this._unprotectedHeader), this._protectedHeader && (l.protected = Q.decode(d)), l;\n  }\n};\n\n// node_modules/jose/dist/browser/jws/compact/sign.js\nvar gr = class {\n  static {\n    o(this, \"CompactSign\");\n  }\n  constructor(t) {\n    this._flattened = new wr(t);\n  }\n  setProtectedHeader(t) {\n    return this._flattened.setProtectedHeader(t), this;\n  }\n  async sign(t, r) {\n    let n = await this._flattened.sign(t, r);\n    if (n.payload === void 0)\n      throw new TypeError(\"use the flattened module for creating JWS with b64: false\");\n    return `${n.protected}.${n.payload}.${n.signature}`;\n  }\n};\n\n// node_modules/jose/dist/browser/jwt/produce.js\nfunction Re(e, t) {\n  if (!Number.isFinite(t))\n    throw new TypeError(`Invalid ${e} input`);\n  return t;\n}\no(Re, \"validateInput\");\nvar qe = class {\n  static {\n    o(this, \"ProduceJWT\");\n  }\n  constructor(t = {}) {\n    if (!z(t))\n      throw new TypeError(\"JWT Claims Set MUST be an object\");\n    this._payload = t;\n  }\n  setIssuer(t) {\n    return this._payload = { ...this._payload, iss: t }, this;\n  }\n  setSubject(t) {\n    return this._payload = { ...this._payload, sub: t }, this;\n  }\n  setAudience(t) {\n    return this._payload = { ...this._payload, aud: t }, this;\n  }\n  setJti(t) {\n    return this._payload = { ...this._payload, jti: t }, this;\n  }\n  setNotBefore(t) {\n    return typeof t == \"number\" ? this._payload = { ...this._payload, nbf: Re(\"setNotBefore\", t) } : t instanceof Date ? this._payload = { ...this._payload, nbf: Re(\"setNotBefore\", se(t)) } : this._payload = { ...this._payload, nbf: se(/* @__PURE__ */ new Date()) + Te(t) }, this;\n  }\n  setExpirationTime(t) {\n    return typeof t == \"number\" ? this._payload = { ...this._payload, exp: Re(\"setExpirationTime\", t) } : t instanceof Date ? this._payload = { ...this._payload, exp: Re(\"setExpirationTime\", se(t)) } : this._payload = { ...this._payload, exp: se(/* @__PURE__ */ new Date()) + Te(t) }, this;\n  }\n  setIssuedAt(t) {\n    return typeof t > \"u\" ? this._payload = { ...this._payload, iat: se(/* @__PURE__ */ new Date()) } : t instanceof Date ? this._payload = { ...this._payload, iat: Re(\"setIssuedAt\", se(t)) } : typeof t == \"string\" ? this._payload = {\n      ...this._payload,\n      iat: Re(\"setIssuedAt\", se(/* @__PURE__ */ new Date()) + Te(t))\n    } : this._payload = { ...this._payload, iat: Re(\"setIssuedAt\", t) }, this;\n  }\n};\n\n// node_modules/jose/dist/browser/jwt/sign.js\nvar mt = class extends qe {\n  static {\n    o(this, \"SignJWT\");\n  }\n  setProtectedHeader(t) {\n    return this._protectedHeader = t, this;\n  }\n  async sign(t, r) {\n    let n = new gr(U.encode(JSON.stringify(this._payload)));\n    if (n.setProtectedHeader(this._protectedHeader), Array.isArray(this._protectedHeader?.crit) && this._protectedHeader.crit.includes(\"b64\") && this._protectedHeader.b64 === !1)\n      throw new Ee(\"JWTs MUST NOT use unencoded payload\");\n    return n.sign(t, r);\n  }\n};\n\n// node_modules/jose/dist/browser/jwt/encrypt.js\nvar yt = class extends qe {\n  static {\n    o(this, \"EncryptJWT\");\n  }\n  setProtectedHeader(t) {\n    if (this._protectedHeader)\n      throw new TypeError(\"setProtectedHeader can only be called once\");\n    return this._protectedHeader = t, this;\n  }\n  setKeyManagementParameters(t) {\n    if (this._keyManagementParameters)\n      throw new TypeError(\"setKeyManagementParameters can only be called once\");\n    return this._keyManagementParameters = t, this;\n  }\n  setContentEncryptionKey(t) {\n    if (this._cek)\n      throw new TypeError(\"setContentEncryptionKey can only be called once\");\n    return this._cek = t, this;\n  }\n  setInitializationVector(t) {\n    if (this._iv)\n      throw new TypeError(\"setInitializationVector can only be called once\");\n    return this._iv = t, this;\n  }\n  replicateIssuerAsHeader() {\n    return this._replicateIssuerAsHeader = !0, this;\n  }\n  replicateSubjectAsHeader() {\n    return this._replicateSubjectAsHeader = !0, this;\n  }\n  replicateAudienceAsHeader() {\n    return this._replicateAudienceAsHeader = !0, this;\n  }\n  async encrypt(t, r) {\n    let n = new yr(U.encode(JSON.stringify(this._payload)));\n    return this._replicateIssuerAsHeader && (this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss }), this._replicateSubjectAsHeader && (this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub }), this._replicateAudienceAsHeader && (this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud }), n.setProtectedHeader(this._protectedHeader), this._iv && n.setInitializationVector(this._iv), this._cek && n.setContentEncryptionKey(this._cek), this._keyManagementParameters && n.setKeyManagementParameters(this._keyManagementParameters), n.encrypt(t, r);\n  }\n};\n\n// node_modules/jose/dist/browser/jwk/thumbprint.js\nvar ye = /* @__PURE__ */ o((e, t) => {\n  if (typeof e != \"string\" || !e)\n    throw new dt(`${t} missing or invalid`);\n}, \"check\");\nasync function br(e, t) {\n  if (!z(e))\n    throw new TypeError(\"JWK must be an object\");\n  if (t ?? (t = \"sha256\"), t !== \"sha256\" && t !== \"sha384\" && t !== \"sha512\")\n    throw new TypeError('digestAlgorithm must one of \"sha256\", \"sha384\", or \"sha512\"');\n  let r;\n  switch (e.kty) {\n    case \"EC\":\n      ye(e.crv, '\"crv\" (Curve) Parameter'), ye(e.x, '\"x\" (X Coordinate) Parameter'), ye(e.y, '\"y\" (Y Coordinate) Parameter'), r = { crv: e.crv, kty: e.kty, x: e.x, y: e.y };\n      break;\n    case \"OKP\":\n      ye(e.crv, '\"crv\" (Subtype of Key Pair) Parameter'), ye(e.x, '\"x\" (Public Key) Parameter'), r = { crv: e.crv, kty: e.kty, x: e.x };\n      break;\n    case \"RSA\":\n      ye(e.e, '\"e\" (Exponent) Parameter'), ye(e.n, '\"n\" (Modulus) Parameter'), r = { e: e.e, kty: e.kty, n: e.n };\n      break;\n    case \"oct\":\n      ye(e.k, '\"k\" (Key Value) Parameter'), r = { k: e.k, kty: e.kty };\n      break;\n    default:\n      throw new E('\"kty\" (Key Type) Parameter missing or unsupported');\n  }\n  let n = U.encode(JSON.stringify(r));\n  return O(await tr(t, n));\n}\no(br, \"calculateJwkThumbprint\");\n\n// node_modules/jose/dist/browser/util/base64url.js\nvar wt = {};\nWo(wt, {\n  decode: () => Nc,\n  encode: () => Kc\n});\nvar Kc = O, Nc = W;\n\n// node_modules/@auth/core/lib/vendored/cookie.js\nvar gt = {};\nWo(gt, {\n  parse: () => jc,\n  serialize: () => Vc\n});\nvar Wc = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/, $c = /^(\"?)[\\u0021\\u0023-\\u002B\\u002D-\\u003A\\u003C-\\u005B\\u005D-\\u007E]*\\1$/, Bc = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, Jc = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/, Mc = Object.prototype.toString, zc = /* @__PURE__ */ (() => {\n  let e = /* @__PURE__ */ o(function() {\n  }, \"C\");\n  return e.prototype = /* @__PURE__ */ Object.create(null), e;\n})();\nfunction jc(e, t) {\n  let r = new zc(), n = e.length;\n  if (n < 2)\n    return r;\n  let i = t?.decode || Fc, s = 0;\n  do {\n    let a = e.indexOf(\"=\", s);\n    if (a === -1)\n      break;\n    let c = e.indexOf(\";\", s), d = c === -1 ? n : c;\n    if (a > d) {\n      s = e.lastIndexOf(\";\", a - 1) + 1;\n      continue;\n    }\n    let u = Wi(e, s, a), f = $i(e, a, u), l = e.slice(u, f);\n    if (r[l] === void 0) {\n      let y = Wi(e, a + 1, d), p = $i(e, d, y), m = i(e.slice(y, p));\n      r[l] = m;\n    }\n    s = d + 1;\n  } while (s < n);\n  return r;\n}\no(jc, \"parse\");\nfunction Wi(e, t, r) {\n  do {\n    let n = e.charCodeAt(t);\n    if (n !== 32 && n !== 9)\n      return t;\n  } while (++t < r);\n  return r;\n}\no(Wi, \"startIndex\");\nfunction $i(e, t, r) {\n  for (; t > r; ) {\n    let n = e.charCodeAt(--t);\n    if (n !== 32 && n !== 9)\n      return t + 1;\n  }\n  return r;\n}\no($i, \"endIndex\");\nfunction Vc(e, t, r) {\n  let n = r?.encode || encodeURIComponent;\n  if (!Wc.test(e))\n    throw new TypeError(`argument name is invalid: ${e}`);\n  let i = n(t);\n  if (!$c.test(i))\n    throw new TypeError(`argument val is invalid: ${t}`);\n  let s = e + \"=\" + i;\n  if (!r)\n    return s;\n  if (r.maxAge !== void 0) {\n    if (!Number.isInteger(r.maxAge))\n      throw new TypeError(`option maxAge is invalid: ${r.maxAge}`);\n    s += \"; Max-Age=\" + r.maxAge;\n  }\n  if (r.domain) {\n    if (!Bc.test(r.domain))\n      throw new TypeError(`option domain is invalid: ${r.domain}`);\n    s += \"; Domain=\" + r.domain;\n  }\n  if (r.path) {\n    if (!Jc.test(r.path))\n      throw new TypeError(`option path is invalid: ${r.path}`);\n    s += \"; Path=\" + r.path;\n  }\n  if (r.expires) {\n    if (!Gc(r.expires) || !Number.isFinite(r.expires.valueOf()))\n      throw new TypeError(`option expires is invalid: ${r.expires}`);\n    s += \"; Expires=\" + r.expires.toUTCString();\n  }\n  if (r.httpOnly && (s += \"; HttpOnly\"), r.secure && (s += \"; Secure\"), r.partitioned && (s += \"; Partitioned\"), r.priority)\n    switch (typeof r.priority == \"string\" ? r.priority.toLowerCase() : void 0) {\n      case \"low\":\n        s += \"; Priority=Low\";\n        break;\n      case \"medium\":\n        s += \"; Priority=Medium\";\n        break;\n      case \"high\":\n        s += \"; Priority=High\";\n        break;\n      default:\n        throw new TypeError(`option priority is invalid: ${r.priority}`);\n    }\n  if (r.sameSite)\n    switch (typeof r.sameSite == \"string\" ? r.sameSite.toLowerCase() : r.sameSite) {\n      case !0:\n      case \"strict\":\n        s += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        s += \"; SameSite=Lax\";\n        break;\n      case \"none\":\n        s += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(`option sameSite is invalid: ${r.sameSite}`);\n    }\n  return s;\n}\no(Vc, \"serialize\");\nfunction Fc(e) {\n  if (e.indexOf(\"%\") === -1)\n    return e;\n  try {\n    return decodeURIComponent(e);\n  } catch {\n    return e;\n  }\n}\no(Fc, \"decode\");\nfunction Gc(e) {\n  return Mc.call(e) === \"[object Date]\";\n}\no(Gc, \"isDate\");\n\n// node_modules/@auth/core/jwt.js\nvar { parse: Xy } = gt, Xc = 720 * 60 * 60, Zc = /* @__PURE__ */ o(() => Date.now() / 1e3 | 0, \"now\"), Bi = \"dir\", Un = \"A256CBC-HS512\";\nasync function _r(e) {\n  let { token: t = {}, secret: r, maxAge: n = Xc, salt: i } = e, s = Array.isArray(r) ? r : [r], a = await Ji(Un, s[0], i), c = await br({ kty: \"oct\", k: wt.encode(a) }, `sha${a.byteLength << 3}`);\n  return await new yt(t).setProtectedHeader({ alg: Bi, enc: Un, kid: c }).setIssuedAt().setExpirationTime(Zc() + n).setJti(crypto.randomUUID()).encrypt(a);\n}\no(_r, \"encode\");\nasync function xr(e) {\n  let { token: t, secret: r, salt: n } = e, i = Array.isArray(r) ? r : [r];\n  if (!t)\n    return null;\n  let { payload: s } = await Pn(t, async ({ kid: a, enc: c }) => {\n    for (let d of i) {\n      let u = await Ji(c, d, n);\n      if (a === void 0)\n        return u;\n      let f = await br({ kty: \"oct\", k: wt.encode(u) }, `sha${u.byteLength << 3}`);\n      if (a === f)\n        return u;\n    }\n    throw new Error(\"no matching decryption secret\");\n  }, {\n    clockTolerance: 15,\n    keyManagementAlgorithms: [Bi],\n    contentEncryptionAlgorithms: [Un, \"A256GCM\"]\n  });\n  return s;\n}\no(xr, \"decode\");\nasync function Ji(e, t, r) {\n  let n;\n  switch (e) {\n    case \"A256CBC-HS512\":\n      n = 64;\n      break;\n    case \"A256GCM\":\n      n = 32;\n      break;\n    default:\n      throw new Error(\"Unsupported JWT Content Encryption Algorithm\");\n  }\n  return await ti(\"sha256\", t, r, `Auth.js Generated Encryption Key (${r})`, n);\n}\no(Ji, \"getDerivedEncryptionKey\");\n\n// node_modules/@auth/core/lib/utils/logger.js\nvar On = \"\\x1B[31m\", Yc = \"\\x1B[33m\", eu = \"\\x1B[90m\", bt = \"\\x1B[0m\", tu = {\n  error(e) {\n    let t = e instanceof T ? e.type : e.name;\n    if (console.error(`${On}[auth][error]${bt} ${t}: ${e.message}`), e.cause && typeof e.cause == \"object\" && \"err\" in e.cause && e.cause.err instanceof Error) {\n      let { err: r, ...n } = e.cause;\n      console.error(`${On}[auth][cause]${bt}:`, r.stack), n && console.error(`${On}[auth][details]${bt}:`, JSON.stringify(n, null, 2));\n    } else e.stack && console.error(e.stack.replace(/.*/, \"\").substring(1));\n  },\n  warn(e) {\n    let t = `https://warnings.authjs.dev#${e}`;\n    console.warn(`${Yc}[auth][warn][${e}]${bt}`, `Read more: ${t}`);\n  },\n  debug(e, t) {\n    console.log(`${eu}[auth][debug]:${bt} ${e}`, JSON.stringify(t, null, 2));\n  }\n};\nfunction _t(e) {\n  let t = {\n    ...tu\n  };\n  return e.debug || (t.debug = () => {\n  }), e.logger?.error && (t.error = e.logger.error), e.logger?.warn && (t.warn = e.logger.warn), e.logger?.debug && (t.debug = e.logger.debug), e.logger ?? (e.logger = t), t;\n}\no(_t, \"setLogger\");\n\n// node_modules/@auth/core/lib/utils/web.js\nvar { parse: cw, serialize: uw } = gt;\n\n// node_modules/@auth/core/lib/symbols.js\nvar Ln = Symbol(\"skip-csrf-check\"), ji = Symbol(\"return-type-raw\"), we = Symbol(\"custom-fetch\"), nu = Symbol(\"conform-internal\");\n\n// node_modules/preact/dist/preact.module.js\nvar Xi, D, Zi, iu, Ce, Vi, Qi, Dn, $n, Kn, Nn, su, Wn = {}, Yi = [], au = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Bn = Array.isArray;\nfunction ge(e, t) {\n  for (var r in t) e[r] = t[r];\n  return e;\n}\no(ge, \"d\");\nfunction es(e) {\n  e && e.parentNode && e.parentNode.removeChild(e);\n}\no(es, \"w\");\nfunction Hn(e, t, r, n, i) {\n  var s = { type: e, props: t, key: r, ref: n, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: i ?? ++Zi, __i: -1, __u: 0 };\n  return i == null && D.vnode != null && D.vnode(s), s;\n}\no(Hn, \"g\");\nfunction Pe(e) {\n  return e.children;\n}\no(Pe, \"b\");\nfunction vr(e, t) {\n  this.props = e, this.context = t;\n}\no(vr, \"k\");\nfunction Xe(e, t) {\n  if (t == null) return e.__ ? Xe(e.__, e.__i + 1) : null;\n  for (var r; t < e.__k.length; t++) if ((r = e.__k[t]) != null && r.__e != null) return r.__e;\n  return typeof e.type == \"function\" ? Xe(e) : null;\n}\no(Xe, \"x\");\nfunction ts(e) {\n  var t, r;\n  if ((e = e.__) != null && e.__c != null) {\n    for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++) if ((r = e.__k[t]) != null && r.__e != null) {\n      e.__e = e.__c.base = r.__e;\n      break;\n    }\n    return ts(e);\n  }\n}\no(ts, \"C\");\nfunction Fi(e) {\n  (!e.__d && (e.__d = !0) && Ce.push(e) && !Ar.__r++ || Vi !== D.debounceRendering) && ((Vi = D.debounceRendering) || Qi)(Ar);\n}\no(Fi, \"S\");\nfunction Ar() {\n  var e, t, r, n, i, s, a, c;\n  for (Ce.sort(Dn); e = Ce.shift(); ) e.__d && (t = Ce.length, n = void 0, s = (i = (r = e).__v).__e, a = [], c = [], r.__P && ((n = ge({}, i)).__v = i.__v + 1, D.vnode && D.vnode(n), os(r.__P, n, i, r.__n, r.__P.namespaceURI, 32 & i.__u ? [s] : null, a, s ?? Xe(i), !!(32 & i.__u), c), n.__v = i.__v, n.__.__k[n.__i] = n, du(a, n, c), n.__e != s && ts(n)), Ce.length > t && Ce.sort(Dn));\n  Ar.__r = 0;\n}\no(Ar, \"M\");\nfunction rs(e, t, r, n, i, s, a, c, d, u, f) {\n  var l, y, p, m, S, I = n && n.__k || Yi, A = t.length;\n  for (r.__d = d, cu(r, t, I), d = r.__d, l = 0; l < A; l++) (p = r.__k[l]) != null && (y = p.__i === -1 ? Wn : I[p.__i] || Wn, p.__i = l, os(e, p, y, i, s, a, c, d, u, f), m = p.__e, p.ref && y.ref != p.ref && (y.ref && Jn(y.ref, null, p), f.push(p.ref, p.__c || m, p)), S == null && m != null && (S = m), 65536 & p.__u || y.__k === p.__k ? d = ns(p, d, e) : typeof p.type == \"function\" && p.__d !== void 0 ? d = p.__d : m && (d = m.nextSibling), p.__d = void 0, p.__u &= -196609);\n  r.__d = d, r.__e = S;\n}\no(rs, \"P\");\nfunction cu(e, t, r) {\n  var n, i, s, a, c, d = t.length, u = r.length, f = u, l = 0;\n  for (e.__k = [], n = 0; n < d; n++) (i = t[n]) != null && typeof i != \"boolean\" && typeof i != \"function\" ? (a = n + l, (i = e.__k[n] = typeof i == \"string\" || typeof i == \"number\" || typeof i == \"bigint\" || i.constructor == String ? Hn(null, i, null, null, null) : Bn(i) ? Hn(Pe, { children: i }, null, null, null) : i.constructor === void 0 && i.__b > 0 ? Hn(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i).__ = e, i.__b = e.__b + 1, s = null, (c = i.__i = uu(i, r, a, f)) !== -1 && (f--, (s = r[c]) && (s.__u |= 131072)), s == null || s.__v === null ? (c == -1 && l--, typeof i.type != \"function\" && (i.__u |= 65536)) : c !== a && (c == a - 1 ? l-- : c == a + 1 ? l++ : (c > a ? l-- : l++, i.__u |= 65536))) : i = e.__k[n] = null;\n  if (f) for (n = 0; n < u; n++) (s = r[n]) != null && (131072 & s.__u) == 0 && (s.__e == e.__d && (e.__d = Xe(s)), is(s, s));\n}\no(cu, \"$\");\nfunction ns(e, t, r) {\n  var n, i;\n  if (typeof e.type == \"function\") {\n    for (n = e.__k, i = 0; n && i < n.length; i++) n[i] && (n[i].__ = e, t = ns(n[i], t, r));\n    return t;\n  }\n  e.__e != t && (t && e.type && !r.contains(t) && (t = Xe(e)), r.insertBefore(e.__e, t || null), t = e.__e);\n  do\n    t = t && t.nextSibling;\n  while (t != null && t.nodeType === 8);\n  return t;\n}\no(ns, \"I\");\nfunction uu(e, t, r, n) {\n  var i = e.key, s = e.type, a = r - 1, c = r + 1, d = t[r];\n  if (d === null || d && i == d.key && s === d.type && (131072 & d.__u) == 0) return r;\n  if (n > (d != null && (131072 & d.__u) == 0 ? 1 : 0)) for (; a >= 0 || c < t.length; ) {\n    if (a >= 0) {\n      if ((d = t[a]) && (131072 & d.__u) == 0 && i == d.key && s === d.type) return a;\n      a--;\n    }\n    if (c < t.length) {\n      if ((d = t[c]) && (131072 & d.__u) == 0 && i == d.key && s === d.type) return c;\n      c++;\n    }\n  }\n  return -1;\n}\no(uu, \"L\");\nfunction Gi(e, t, r) {\n  t[0] === \"-\" ? e.setProperty(t, r ?? \"\") : e[t] = r == null ? \"\" : typeof r != \"number\" || au.test(t) ? r : r + \"px\";\n}\no(Gi, \"T\");\nfunction Sr(e, t, r, n, i) {\n  var s;\n  e: if (t === \"style\") if (typeof r == \"string\") e.style.cssText = r;\n  else {\n    if (typeof n == \"string\" && (e.style.cssText = n = \"\"), n) for (t in n) r && t in r || Gi(e.style, t, \"\");\n    if (r) for (t in r) n && r[t] === n[t] || Gi(e.style, t, r[t]);\n  }\n  else if (t[0] === \"o\" && t[1] === \"n\") s = t !== (t = t.replace(/(PointerCapture)$|Capture$/i, \"$1\")), t = t.toLowerCase() in e || t === \"onFocusOut\" || t === \"onFocusIn\" ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + s] = r, r ? n ? r.u = n.u : (r.u = $n, e.addEventListener(t, s ? Nn : Kn, s)) : e.removeEventListener(t, s ? Nn : Kn, s);\n  else {\n    if (i == \"http://www.w3.org/2000/svg\") t = t.replace(/xlink(H|:h)/, \"h\").replace(/sName$/, \"s\");\n    else if (t != \"width\" && t != \"height\" && t != \"href\" && t != \"list\" && t != \"form\" && t != \"tabIndex\" && t != \"download\" && t != \"rowSpan\" && t != \"colSpan\" && t != \"role\" && t != \"popover\" && t in e) try {\n      e[t] = r ?? \"\";\n      break e;\n    } catch {\n    }\n    typeof r == \"function\" || (r == null || r === !1 && t[4] !== \"-\" ? e.removeAttribute(t) : e.setAttribute(t, t == \"popover\" && r == 1 ? \"\" : r));\n  }\n}\no(Sr, \"A\");\nfunction qi(e) {\n  return function(t) {\n    if (this.l) {\n      var r = this.l[t.type + e];\n      if (t.t == null) t.t = $n++;\n      else if (t.t < r.u) return;\n      return r(D.event ? D.event(t) : t);\n    }\n  };\n}\no(qi, \"F\");\nfunction os(e, t, r, n, i, s, a, c, d, u) {\n  var f, l, y, p, m, S, I, A, b, k, P, Z, V, ve, He, tt, re = t.type;\n  if (t.constructor !== void 0) return null;\n  128 & r.__u && (d = !!(32 & r.__u), s = [c = t.__e = r.__e]), (f = D.__b) && f(t);\n  e: if (typeof re == \"function\") try {\n    if (A = t.props, b = \"prototype\" in re && re.prototype.render, k = (f = re.contextType) && n[f.__c], P = f ? k ? k.props.value : f.__ : n, r.__c ? I = (l = t.__c = r.__c).__ = l.__E : (b ? t.__c = l = new re(A, P) : (t.__c = l = new vr(A, P), l.constructor = re, l.render = fu), k && k.sub(l), l.props = A, l.state || (l.state = {}), l.context = P, l.__n = n, y = l.__d = !0, l.__h = [], l._sb = []), b && l.__s == null && (l.__s = l.state), b && re.getDerivedStateFromProps != null && (l.__s == l.state && (l.__s = ge({}, l.__s)), ge(l.__s, re.getDerivedStateFromProps(A, l.__s))), p = l.props, m = l.state, l.__v = t, y) b && re.getDerivedStateFromProps == null && l.componentWillMount != null && l.componentWillMount(), b && l.componentDidMount != null && l.__h.push(l.componentDidMount);\n    else {\n      if (b && re.getDerivedStateFromProps == null && A !== p && l.componentWillReceiveProps != null && l.componentWillReceiveProps(A, P), !l.__e && (l.shouldComponentUpdate != null && l.shouldComponentUpdate(A, l.__s, P) === !1 || t.__v === r.__v)) {\n        for (t.__v !== r.__v && (l.props = A, l.state = l.__s, l.__d = !1), t.__e = r.__e, t.__k = r.__k, t.__k.some(function(Ct) {\n          Ct && (Ct.__ = t);\n        }), Z = 0; Z < l._sb.length; Z++) l.__h.push(l._sb[Z]);\n        l._sb = [], l.__h.length && a.push(l);\n        break e;\n      }\n      l.componentWillUpdate != null && l.componentWillUpdate(A, l.__s, P), b && l.componentDidUpdate != null && l.__h.push(function() {\n        l.componentDidUpdate(p, m, S);\n      });\n    }\n    if (l.context = P, l.props = A, l.__P = e, l.__e = !1, V = D.__r, ve = 0, b) {\n      for (l.state = l.__s, l.__d = !1, V && V(t), f = l.render(l.props, l.state, l.context), He = 0; He < l._sb.length; He++) l.__h.push(l._sb[He]);\n      l._sb = [];\n    } else do\n      l.__d = !1, V && V(t), f = l.render(l.props, l.state, l.context), l.state = l.__s;\n    while (l.__d && ++ve < 25);\n    l.state = l.__s, l.getChildContext != null && (n = ge(ge({}, n), l.getChildContext())), b && !y && l.getSnapshotBeforeUpdate != null && (S = l.getSnapshotBeforeUpdate(p, m)), rs(e, Bn(tt = f != null && f.type === Pe && f.key == null ? f.props.children : f) ? tt : [tt], t, r, n, i, s, a, c, d, u), l.base = t.__e, t.__u &= -161, l.__h.length && a.push(l), I && (l.__E = l.__ = null);\n  } catch (Ct) {\n    if (t.__v = null, d || s != null) {\n      for (t.__u |= d ? 160 : 128; c && c.nodeType === 8 && c.nextSibling; ) c = c.nextSibling;\n      s[s.indexOf(c)] = null, t.__e = c;\n    } else t.__e = r.__e, t.__k = r.__k;\n    D.__e(Ct, t, r);\n  }\n  else s == null && t.__v === r.__v ? (t.__k = r.__k, t.__e = r.__e) : t.__e = lu(r.__e, t, r, n, i, s, a, d, u);\n  (f = D.diffed) && f(t);\n}\no(os, \"O\");\nfunction du(e, t, r) {\n  t.__d = void 0;\n  for (var n = 0; n < r.length; n++) Jn(r[n], r[++n], r[++n]);\n  D.__c && D.__c(t, e), e.some(function(i) {\n    try {\n      e = i.__h, i.__h = [], e.some(function(s) {\n        s.call(i);\n      });\n    } catch (s) {\n      D.__e(s, i.__v);\n    }\n  });\n}\no(du, \"j\");\nfunction lu(e, t, r, n, i, s, a, c, d) {\n  var u, f, l, y, p, m, S, I = r.props, A = t.props, b = t.type;\n  if (b === \"svg\" ? i = \"http://www.w3.org/2000/svg\" : b === \"math\" ? i = \"http://www.w3.org/1998/Math/MathML\" : i || (i = \"http://www.w3.org/1999/xhtml\"), s != null) {\n    for (u = 0; u < s.length; u++) if ((p = s[u]) && \"setAttribute\" in p == !!b && (b ? p.localName === b : p.nodeType === 3)) {\n      e = p, s[u] = null;\n      break;\n    }\n  }\n  if (e == null) {\n    if (b === null) return document.createTextNode(A);\n    e = document.createElementNS(i, b, A.is && A), c && (D.__m && D.__m(t, s), c = !1), s = null;\n  }\n  if (b === null) I === A || c && e.data === A || (e.data = A);\n  else {\n    if (s = s && Xi.call(e.childNodes), I = r.props || Wn, !c && s != null) for (I = {}, u = 0; u < e.attributes.length; u++) I[(p = e.attributes[u]).name] = p.value;\n    for (u in I) if (p = I[u], u != \"children\") {\n      if (u == \"dangerouslySetInnerHTML\") l = p;\n      else if (!(u in A)) {\n        if (u == \"value\" && \"defaultValue\" in A || u == \"checked\" && \"defaultChecked\" in A) continue;\n        Sr(e, u, null, p, i);\n      }\n    }\n    for (u in A) p = A[u], u == \"children\" ? y = p : u == \"dangerouslySetInnerHTML\" ? f = p : u == \"value\" ? m = p : u == \"checked\" ? S = p : c && typeof p != \"function\" || I[u] === p || Sr(e, u, p, I[u], i);\n    if (f) c || l && (f.__html === l.__html || f.__html === e.innerHTML) || (e.innerHTML = f.__html), t.__k = [];\n    else if (l && (e.innerHTML = \"\"), rs(e, Bn(y) ? y : [y], t, r, n, b === \"foreignObject\" ? \"http://www.w3.org/1999/xhtml\" : i, s, a, s ? s[0] : r.__k && Xe(r, 0), c, d), s != null) for (u = s.length; u--; ) es(s[u]);\n    c || (u = \"value\", b === \"progress\" && m == null ? e.removeAttribute(\"value\") : m !== void 0 && (m !== e[u] || b === \"progress\" && !m || b === \"option\" && m !== I[u]) && Sr(e, u, m, I[u], i), u = \"checked\", S !== void 0 && S !== e[u] && Sr(e, u, S, I[u], i));\n  }\n  return e;\n}\no(lu, \"z\");\nfunction Jn(e, t, r) {\n  try {\n    if (typeof e == \"function\") {\n      var n = typeof e.__u == \"function\";\n      n && e.__u(), n && t == null || (e.__u = e(t));\n    } else e.current = t;\n  } catch (i) {\n    D.__e(i, r);\n  }\n}\no(Jn, \"N\");\nfunction is(e, t, r) {\n  var n, i;\n  if (D.unmount && D.unmount(e), (n = e.ref) && (n.current && n.current !== e.__e || Jn(n, null, t)), (n = e.__c) != null) {\n    if (n.componentWillUnmount) try {\n      n.componentWillUnmount();\n    } catch (s) {\n      D.__e(s, t);\n    }\n    n.base = n.__P = null;\n  }\n  if (n = e.__k) for (i = 0; i < n.length; i++) n[i] && is(n[i], t, r || typeof e.type != \"function\");\n  r || es(e.__e), e.__c = e.__ = e.__e = e.__d = void 0;\n}\no(is, \"V\");\nfunction fu(e, t, r) {\n  return this.constructor(e, r);\n}\no(fu, \"q\");\nXi = Yi.slice, D = { __e: /* @__PURE__ */ o(function(e, t, r, n) {\n  for (var i, s, a; t = t.__; ) if ((i = t.__c) && !i.__) try {\n    if ((s = i.constructor) && s.getDerivedStateFromError != null && (i.setState(s.getDerivedStateFromError(e)), a = i.__d), i.componentDidCatch != null && (i.componentDidCatch(e, n || {}), a = i.__d), a) return i.__E = i;\n  } catch (c) {\n    e = c;\n  }\n  throw e;\n}, \"__e\") }, Zi = 0, iu = /* @__PURE__ */ o(function(e) {\n  return e != null && e.constructor == null;\n}, \"t\"), vr.prototype.setState = function(e, t) {\n  var r;\n  r = this.__s != null && this.__s !== this.state ? this.__s : this.__s = ge({}, this.state), typeof e == \"function\" && (e = e(ge({}, r), this.props)), e && ge(r, e), e != null && this.__v && (t && this._sb.push(t), Fi(this));\n}, vr.prototype.forceUpdate = function(e) {\n  this.__v && (this.__e = !0, e && this.__h.push(e), Fi(this));\n}, vr.prototype.render = Pe, Ce = [], Qi = typeof Promise == \"function\" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, Dn = /* @__PURE__ */ o(function(e, t) {\n  return e.__v.__b - t.__v.__b;\n}, \"f\"), Ar.__r = 0, $n = 0, Kn = qi(!1), Nn = qi(!0), su = 0;\n\n// node_modules/oauth4webapi/build/index.js\nvar jn;\n(typeof navigator > \"u\" || !navigator.userAgent?.startsWith?.(\"Mozilla/5.0 \")) && (jn = \"oauth4webapi/v3.8.3\");\nfunction vt(e, t) {\n  if (e == null)\n    return !1;\n  try {\n    return e instanceof t || Object.getPrototypeOf(e)[Symbol.toStringTag] === t.prototype[Symbol.toStringTag];\n  } catch {\n    return !1;\n  }\n}\no(vt, \"looseInstanceOf\");\nvar Y = \"ERR_INVALID_ARG_VALUE\", q = \"ERR_INVALID_ARG_TYPE\";\nfunction C(e, t, r) {\n  let n = new TypeError(e, { cause: r });\n  return Object.assign(n, { code: t }), n;\n}\no(C, \"CodedTypeError\");\nvar le = Symbol(), us = Symbol(), hu = Symbol(), _e = Symbol(), Tr = Symbol(), Vn = Symbol(), Tg = Symbol(), mu = new TextEncoder(), yu = new TextDecoder();\nfunction ae(e) {\n  return typeof e == \"string\" ? mu.encode(e) : yu.decode(e);\n}\no(ae, \"buf\");\nvar Fn;\nUint8Array.prototype.toBase64 ? Fn = /* @__PURE__ */ o((e) => (e instanceof ArrayBuffer && (e = new Uint8Array(e)), e.toBase64({ alphabet: \"base64url\", omitPadding: !0 })), \"encodeBase64Url\") : Fn = /* @__PURE__ */ o((t) => {\n  t instanceof ArrayBuffer && (t = new Uint8Array(t));\n  let r = [];\n  for (let n = 0; n < t.byteLength; n += 32768)\n    r.push(String.fromCharCode.apply(null, t.subarray(n, n + 32768)));\n  return btoa(r.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}, \"encodeBase64Url\");\nvar Gn;\nUint8Array.fromBase64 ? Gn = /* @__PURE__ */ o((e) => {\n  try {\n    return Uint8Array.fromBase64(e, { alphabet: \"base64url\" });\n  } catch (t) {\n    throw C(\"The input to be decoded is not correctly encoded.\", Y, t);\n  }\n}, \"decodeBase64Url\") : Gn = /* @__PURE__ */ o((e) => {\n  try {\n    let t = atob(e.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\")), r = new Uint8Array(t.length);\n    for (let n = 0; n < t.length; n++)\n      r[n] = t.charCodeAt(n);\n    return r;\n  } catch (t) {\n    throw C(\"The input to be decoded is not correctly encoded.\", Y, t);\n  }\n}, \"decodeBase64Url\");\nfunction ce(e) {\n  return typeof e == \"string\" ? Gn(e) : Fn(e);\n}\no(ce, \"b64u\");\nvar X = class extends Error {\n  static {\n    o(this, \"UnsupportedOperationError\");\n  }\n  code;\n  constructor(t, r) {\n    super(t, r), this.name = this.constructor.name, this.code = rd, Error.captureStackTrace?.(this, this.constructor);\n  }\n}, qn = class extends Error {\n  static {\n    o(this, \"OperationProcessingError\");\n  }\n  code;\n  constructor(t, r) {\n    super(t, r), this.name = this.constructor.name, r?.code && (this.code = r?.code), Error.captureStackTrace?.(this, this.constructor);\n  }\n};\nfunction x(e, t, r) {\n  return new qn(e, { code: t, cause: r });\n}\no(x, \"OPE\");\nfunction wu(e, t) {\n  if (!(e instanceof CryptoKey))\n    throw C(`${t} must be a CryptoKey`, q);\n}\no(wu, \"assertCryptoKey\");\nfunction gu(e, t) {\n  if (wu(e, t), e.type !== \"private\")\n    throw C(`${t} must be a private CryptoKey`, Y);\n}\no(gu, \"assertPrivateKey\");\nfunction Er(e) {\n  return !(e === null || typeof e != \"object\" || Array.isArray(e));\n}\no(Er, \"isJsonObject\");\nfunction Rr(e) {\n  vt(e, Headers) && (e = Object.fromEntries(e.entries()));\n  let t = new Headers(e ?? {});\n  if (jn && !t.has(\"user-agent\") && t.set(\"user-agent\", jn), t.has(\"authorization\"))\n    throw C('\"options.headers\" must not include the \"authorization\" header name', Y);\n  return t;\n}\no(Rr, \"prepareHeaders\");\nfunction Yn(e, t) {\n  if (t !== void 0) {\n    if (typeof t == \"function\" && (t = t(e.href)), !(t instanceof AbortSignal))\n      throw C('\"options.signal\" must return or be an instance of AbortSignal', q);\n    return t;\n  }\n}\no(Yn, \"signal\");\nfunction ds(e) {\n  return e.includes(\"//\") ? e.replace(\"//\", \"/\") : e;\n}\no(ds, \"replaceDoubleSlash\");\nfunction bu(e, t, r = !1) {\n  return e.pathname === \"/\" ? e.pathname = t : e.pathname = ds(`${t}/${r ? e.pathname : e.pathname.replace(/(\\/)$/, \"\")}`), e;\n}\no(bu, \"prependWellKnown\");\nfunction _u(e, t) {\n  return e.pathname = ds(`${e.pathname}/${t}`), e;\n}\no(_u, \"appendWellKnown\");\nasync function xu(e, t, r, n) {\n  if (!(e instanceof URL))\n    throw C(`\"${t}\" must be an instance of URL`, q);\n  eo(e, n?.[le] !== !0);\n  let i = r(new URL(e.href)), s = Rr(n?.headers);\n  return s.set(\"accept\", \"application/json\"), (n?.[_e] || fetch)(i.href, {\n    body: void 0,\n    headers: Object.fromEntries(s.entries()),\n    method: \"GET\",\n    redirect: \"manual\",\n    signal: Yn(i, n?.signal)\n  });\n}\no(xu, \"performDiscovery\");\nasync function ls(e, t) {\n  return xu(e, \"issuerIdentifier\", (r) => {\n    switch (t?.algorithm) {\n      case void 0:\n      case \"oidc\":\n        _u(r, \".well-known/openid-configuration\");\n        break;\n      case \"oauth2\":\n        bu(r, \".well-known/oauth-authorization-server\");\n        break;\n      default:\n        throw C('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"', Y);\n    }\n    return r;\n  }, t);\n}\no(ls, \"discoveryRequest\");\nfunction xt(e, t, r, n, i) {\n  try {\n    if (typeof e != \"number\" || !Number.isFinite(e))\n      throw C(`${r} must be a number`, q, i);\n    if (e > 0)\n      return;\n    if (t) {\n      if (e !== 0)\n        throw C(`${r} must be a non-negative number`, Y, i);\n      return;\n    }\n    throw C(`${r} must be a positive number`, Y, i);\n  } catch (s) {\n    throw n ? x(s.message, n, i) : s;\n  }\n}\no(xt, \"assertNumber\");\nfunction $(e, t, r, n) {\n  try {\n    if (typeof e != \"string\")\n      throw C(`${t} must be a string`, q, n);\n    if (e.length === 0)\n      throw C(`${t} must not be empty`, Y, n);\n  } catch (i) {\n    throw r ? x(i.message, r, n) : i;\n  }\n}\no($, \"assertString\");\nasync function fs(e, t) {\n  let r = e;\n  if (!(r instanceof URL) && r !== cs)\n    throw C('\"expectedIssuerIdentifier\" must be an instance of URL', q);\n  if (!vt(t, Response))\n    throw C('\"response\" must be an instance of Response', q);\n  if (t.status !== 200)\n    throw x('\"response\" is not a conform Authorization Server Metadata response (unexpected HTTP status code)', no, t);\n  Nr(t);\n  let n = await io(t);\n  if ($(n.issuer, '\"response\" body \"issuer\" property', R, { body: n }), r !== cs && new URL(n.issuer).href !== r.href)\n    throw x('\"response\" body \"issuer\" property does not match the expected value', Cs, { expected: r.href, body: n, attribute: \"issuer\" });\n  return n;\n}\no(fs, \"processDiscoveryResponse\");\nfunction ps(e) {\n  vu(e, \"application/json\");\n}\no(ps, \"assertApplicationJson\");\nfunction Su(e, ...t) {\n  let r = '\"response\" content-type must be ';\n  if (t.length > 2) {\n    let n = t.pop();\n    r += `${t.join(\", \")}, or ${n}`;\n  } else t.length === 2 ? r += `${t[0]} or ${t[1]}` : r += t[0];\n  return x(r, id, e);\n}\no(Su, \"notJson\");\nfunction vu(e, t) {\n  if (_s(e) !== t)\n    throw Su(e, t);\n}\no(vu, \"assertContentType\");\nfunction Cr() {\n  return ce(crypto.getRandomValues(new Uint8Array(32)));\n}\no(Cr, \"randomBytes\");\nfunction Pr() {\n  return Cr();\n}\no(Pr, \"generateRandomCodeVerifier\");\nfunction Ur() {\n  return Cr();\n}\no(Ur, \"generateRandomState\");\nfunction Or() {\n  return Cr();\n}\no(Or, \"generateRandomNonce\");\nasync function Lr(e) {\n  return $(e, \"codeVerifier\"), ce(await crypto.subtle.digest(\"SHA-256\", ae(e)));\n}\no(Lr, \"calculatePKCECodeChallenge\");\nfunction Au(e) {\n  return e instanceof CryptoKey ? { key: e } : e?.key instanceof CryptoKey ? (e.kid !== void 0 && $(e.kid, '\"kid\"'), {\n    key: e.key,\n    kid: e.kid\n  }) : {};\n}\no(Au, \"getKeyAndKid\");\nfunction Eu(e) {\n  switch (e.algorithm.hash.name) {\n    case \"SHA-256\":\n      return \"PS256\";\n    case \"SHA-384\":\n      return \"PS384\";\n    case \"SHA-512\":\n      return \"PS512\";\n    default:\n      throw new X(\"unsupported RsaHashedKeyAlgorithm hash name\", {\n        cause: e\n      });\n  }\n}\no(Eu, \"psAlg\");\nfunction ku(e) {\n  switch (e.algorithm.hash.name) {\n    case \"SHA-256\":\n      return \"RS256\";\n    case \"SHA-384\":\n      return \"RS384\";\n    case \"SHA-512\":\n      return \"RS512\";\n    default:\n      throw new X(\"unsupported RsaHashedKeyAlgorithm hash name\", {\n        cause: e\n      });\n  }\n}\no(ku, \"rsAlg\");\nfunction Iu(e) {\n  switch (e.algorithm.namedCurve) {\n    case \"P-256\":\n      return \"ES256\";\n    case \"P-384\":\n      return \"ES384\";\n    case \"P-521\":\n      return \"ES512\";\n    default:\n      throw new X(\"unsupported EcKeyAlgorithm namedCurve\", { cause: e });\n  }\n}\no(Iu, \"esAlg\");\nfunction Tu(e) {\n  switch (e.algorithm.name) {\n    case \"RSA-PSS\":\n      return Eu(e);\n    case \"RSASSA-PKCS1-v1_5\":\n      return ku(e);\n    case \"ECDSA\":\n      return Iu(e);\n    case \"Ed25519\":\n    case \"ML-DSA-44\":\n    case \"ML-DSA-65\":\n    case \"ML-DSA-87\":\n      return e.algorithm.name;\n    case \"EdDSA\":\n      return \"Ed25519\";\n    default:\n      throw new X(\"unsupported CryptoKey algorithm name\", { cause: e });\n  }\n}\no(Tu, \"keyToJws\");\nfunction Ze(e) {\n  let t = e?.[us];\n  return typeof t == \"number\" && Number.isFinite(t) ? t : 0;\n}\no(Ze, \"getClockSkew\");\nfunction Hr(e) {\n  let t = e?.[hu];\n  return typeof t == \"number\" && Number.isFinite(t) && Math.sign(t) !== -1 ? t : 30;\n}\no(Hr, \"getClockTolerance\");\nfunction Dr() {\n  return Math.floor(Date.now() / 1e3);\n}\no(Dr, \"epochTime\");\nfunction At(e) {\n  if (typeof e != \"object\" || e === null)\n    throw C('\"as\" must be an object', q);\n  $(e.issuer, '\"as.issuer\"');\n}\no(At, \"assertAs\");\nfunction Et(e) {\n  if (typeof e != \"object\" || e === null)\n    throw C('\"client\" must be an object', q);\n  $(e.client_id, '\"client.client_id\"');\n}\no(Et, \"assertClient\");\nfunction hs(e) {\n  return $(e, '\"clientSecret\"'), (t, r, n, i) => {\n    n.set(\"client_id\", r.client_id), n.set(\"client_secret\", e);\n  };\n}\no(hs, \"ClientSecretPost\");\nfunction ms(e, t) {\n  let r = Dr() + Ze(t);\n  return {\n    jti: Cr(),\n    aud: e.issuer,\n    exp: r + 60,\n    iat: r,\n    nbf: r,\n    iss: t.client_id,\n    sub: t.client_id\n  };\n}\no(ms, \"clientAssertionPayload\");\nfunction ys(e, t) {\n  let { key: r, kid: n } = Au(e);\n  return gu(r, '\"clientPrivateKey.key\"'), async (i, s, a, c) => {\n    let d = { alg: Tu(r), kid: n }, u = ms(i, s);\n    t?.[Tr]?.(d, u), a.set(\"client_id\", s.client_id), a.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"), a.set(\"client_assertion\", await Ru(d, u, r));\n  };\n}\no(ys, \"PrivateKeyJwt\");\nfunction ws(e, t) {\n  $(e, '\"clientSecret\"');\n  let r = t?.[Tr], n;\n  return async (i, s, a, c) => {\n    n ||= await crypto.subtle.importKey(\"raw\", ae(e), { hash: \"SHA-256\", name: \"HMAC\" }, !1, [\"sign\"]);\n    let d = { alg: \"HS256\" }, u = ms(i, s);\n    r?.(d, u);\n    let f = `${ce(ae(JSON.stringify(d)))}.${ce(ae(JSON.stringify(u)))}`, l = await crypto.subtle.sign(n.algorithm, n, ae(f));\n    a.set(\"client_id\", s.client_id), a.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"), a.set(\"client_assertion\", `${f}.${ce(new Uint8Array(l))}`);\n  };\n}\no(ws, \"ClientSecretJwt\");\nasync function Ru(e, t, r) {\n  if (!r.usages.includes(\"sign\"))\n    throw C('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"', Y);\n  let n = `${ce(ae(JSON.stringify(e)))}.${ce(ae(JSON.stringify(t)))}`, i = ce(await crypto.subtle.sign(ld(r), r, ae(n)));\n  return `${n}.${i}`;\n}\no(Ru, \"signJwt\");\nvar Cu = URL.parse ? (e, t) => URL.parse(e, t) : (e, t) => {\n  try {\n    return new URL(e, t);\n  } catch {\n    return null;\n  }\n};\nfunction eo(e, t) {\n  if (t && e.protocol !== \"https:\")\n    throw x(\"only requests to HTTPS are allowed\", sd, e);\n  if (e.protocol !== \"https:\" && e.protocol !== \"http:\")\n    throw x(\"only HTTP and HTTPS requests are allowed\", ad, e);\n}\no(eo, \"checkProtocol\");\nfunction ss(e, t, r, n) {\n  let i;\n  if (typeof e != \"string\" || !(i = Cu(e)))\n    throw x(`authorization server metadata does not contain a valid ${r ? `\"as.mtls_endpoint_aliases.${t}\"` : `\"as.${t}\"`}`, e === void 0 ? cd : ud, { attribute: r ? `mtls_endpoint_aliases.${t}` : t });\n  return eo(i, n), i;\n}\no(ss, \"validateEndpoint\");\nfunction gs(e, t, r, n) {\n  return r && e.mtls_endpoint_aliases && t in e.mtls_endpoint_aliases ? ss(e.mtls_endpoint_aliases[t], t, r, n) : ss(e[t], t, r, n);\n}\no(gs, \"resolveEndpoint\");\nvar Xn = class extends Error {\n  static {\n    o(this, \"ResponseBodyError\");\n  }\n  cause;\n  code;\n  error;\n  status;\n  error_description;\n  response;\n  constructor(t, r) {\n    super(t, r), this.name = this.constructor.name, this.code = td, this.cause = r.cause, this.error = r.cause.error, this.status = r.response.status, this.error_description = r.cause.error_description, Object.defineProperty(this, \"response\", { enumerable: !1, value: r.response }), Error.captureStackTrace?.(this, this.constructor);\n  }\n}, St = class extends Error {\n  static {\n    o(this, \"AuthorizationResponseError\");\n  }\n  cause;\n  code;\n  error;\n  error_description;\n  constructor(t, r) {\n    super(t, r), this.name = this.constructor.name, this.code = nd, this.cause = r.cause, this.error = r.cause.get(\"error\"), this.error_description = r.cause.get(\"error_description\") ?? void 0, Error.captureStackTrace?.(this, this.constructor);\n  }\n}, Zn = class extends Error {\n  static {\n    o(this, \"WWWAuthenticateChallengeError\");\n  }\n  cause;\n  code;\n  response;\n  status;\n  constructor(t, r) {\n    super(t, r), this.name = this.constructor.name, this.code = ed, this.cause = r.cause, this.status = r.response.status, this.response = r.response, Object.defineProperty(this, \"response\", { enumerable: !1 }), Error.captureStackTrace?.(this, this.constructor);\n  }\n}, kr = \"[a-zA-Z0-9!#$%&\\\\'\\\\*\\\\+\\\\-\\\\.\\\\^_`\\\\|~]+\", Pu = \"[a-zA-Z0-9\\\\-\\\\._\\\\~\\\\+\\\\/]+={0,2}\", Uu = '\"((?:[^\"\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])*)\"', Ou = \"(\" + kr + \")\\\\s*=\\\\s*\" + Uu, Lu = \"(\" + kr + \")\\\\s*=\\\\s*(\" + kr + \")\", Hu = new RegExp(\"^[,\\\\s]*(\" + kr + \")\"), Du = new RegExp(\"^[,\\\\s]*\" + Ou + \"[,\\\\s]*(.*)\"), Ku = new RegExp(\"^[,\\\\s]*\" + Lu + \"[,\\\\s]*(.*)\"), Nu = new RegExp(\"^(\" + Pu + \")(?:$|[,\\\\s])(.*)\");\nfunction Wu(e) {\n  if (!vt(e, Response))\n    throw C('\"response\" must be an instance of Response', q);\n  let t = e.headers.get(\"www-authenticate\");\n  if (t === null)\n    return;\n  let r = [], n = t;\n  for (; n; ) {\n    let i = n.match(Hu), s = i?.[1].toLowerCase();\n    if (!s)\n      return;\n    let a = n.substring(i[0].length);\n    if (a && !a.match(/^[\\s,]/))\n      return;\n    let c = a.match(/^\\s+(.*)$/), d = !!c;\n    n = c ? c[1] : void 0;\n    let u = {}, f;\n    if (d)\n      for (; n; ) {\n        let y, p;\n        if (i = n.match(Du)) {\n          if ([, y, p, n] = i, p.includes(\"\\\\\"))\n            try {\n              p = JSON.parse(`\"${p}\"`);\n            } catch {\n            }\n          u[y.toLowerCase()] = p;\n          continue;\n        }\n        if (i = n.match(Ku)) {\n          [, y, p, n] = i, u[y.toLowerCase()] = p;\n          continue;\n        }\n        if (i = n.match(Nu)) {\n          if (Object.keys(u).length)\n            break;\n          [, f, n] = i;\n          break;\n        }\n        return;\n      }\n    else\n      n = a || void 0;\n    let l = { scheme: s, parameters: u };\n    f && (l.token68 = f), r.push(l);\n  }\n  if (r.length)\n    return r;\n}\no(Wu, \"parseWwwAuthenticateChallenges\");\nasync function $u(e) {\n  if (e.status > 399 && e.status < 500) {\n    Nr(e), ps(e);\n    try {\n      let t = await e.clone().json();\n      if (Er(t) && typeof t.error == \"string\" && t.error.length)\n        return t;\n    } catch {\n    }\n  }\n}\no($u, \"parseOAuthResponseErrorBody\");\nasync function Bu(e, t, r) {\n  if (e.status !== t) {\n    Es(e);\n    let n;\n    throw (n = await $u(e)) ? (await e.body?.cancel(), new Xn(\"server responded with an error in the response body\", {\n      cause: n,\n      response: e\n    })) : x(`\"response\" is not a conform ${r} response (unexpected HTTP status code)`, no, e);\n  }\n}\no(Bu, \"checkOAuthBodyError\");\nfunction bs(e) {\n  if (!ro.has(e))\n    throw C('\"options.DPoP\" is not a valid DPoPHandle', Y);\n}\no(bs, \"assertDPoP\");\nasync function Ju(e, t, r, n, i, s) {\n  if ($(e, '\"accessToken\"'), !(r instanceof URL))\n    throw C('\"url\" must be an instance of URL', q);\n  eo(r, s?.[le] !== !0), n = Rr(n), s?.DPoP && (bs(s.DPoP), await s.DPoP.addProof(r, n, t.toUpperCase(), e)), n.set(\"authorization\", `${n.has(\"dpop\") ? \"DPoP\" : \"Bearer\"} ${e}`);\n  let a = await (s?.[_e] || fetch)(r.href, {\n    body: i,\n    headers: Object.fromEntries(n.entries()),\n    method: t,\n    redirect: \"manual\",\n    signal: Yn(r, s?.signal)\n  });\n  return s?.DPoP?.cacheNonce(a, r), a;\n}\no(Ju, \"resourceRequest\");\nasync function to(e, t, r, n) {\n  At(e), Et(t);\n  let i = gs(e, \"userinfo_endpoint\", t.use_mtls_endpoint_aliases, n?.[le] !== !0), s = Rr(n?.headers);\n  return t.userinfo_signed_response_alg ? s.set(\"accept\", \"application/jwt\") : (s.set(\"accept\", \"application/json\"), s.append(\"accept\", \"application/jwt\")), Ju(r, \"GET\", i, s, null, {\n    ...n,\n    [us]: Ze(t)\n  });\n}\no(to, \"userInfoRequest\");\nvar Mu = Symbol();\nfunction _s(e) {\n  return e.headers.get(\"content-type\")?.split(\";\")[0];\n}\no(_s, \"getContentType\");\nasync function xs(e, t, r, n, i) {\n  if (At(e), Et(t), !vt(n, Response))\n    throw C('\"response\" must be an instance of Response', q);\n  if (Es(n), n.status !== 200)\n    throw x('\"response\" is not a conform UserInfo Endpoint response (unexpected HTTP status code)', no, n);\n  Nr(n);\n  let s;\n  if (_s(n) === \"application/jwt\") {\n    let { claims: a, jwt: c } = await Ps(await n.text(), Us.bind(void 0, t.userinfo_signed_response_alg, e.userinfo_signing_alg_values_supported, void 0), Ze(t), Hr(t), i?.[Vn]).then(Vu.bind(void 0, t.client_id)).then(Fu.bind(void 0, e));\n    vs.set(n, c), s = a;\n  } else {\n    if (t.userinfo_signed_response_alg)\n      throw x(\"JWT UserInfo Response expected\", od, n);\n    s = await io(n);\n  }\n  switch ($(s.sub, '\"response\" body \"sub\" property', R, { body: s }), r) {\n    case Mu:\n      break;\n    default:\n      if ($(r, '\"expectedSubject\"'), s.sub !== r)\n        throw x('unexpected \"response\" body \"sub\" property value', Cs, {\n          expected: r,\n          body: s,\n          attribute: \"sub\"\n        });\n  }\n  return s;\n}\no(xs, \"processUserInfoResponse\");\nasync function zu(e, t, r, n, i, s, a) {\n  return await r(e, t, i, s), s.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"), (a?.[_e] || fetch)(n.href, {\n    body: i,\n    headers: Object.fromEntries(s.entries()),\n    method: \"POST\",\n    redirect: \"manual\",\n    signal: Yn(n, a?.signal)\n  });\n}\no(zu, \"authenticatedRequest\");\nasync function ju(e, t, r, n, i, s) {\n  let a = gs(e, \"token_endpoint\", t.use_mtls_endpoint_aliases, s?.[le] !== !0);\n  i.set(\"grant_type\", n);\n  let c = Rr(s?.headers);\n  c.set(\"accept\", \"application/json\"), s?.DPoP !== void 0 && (bs(s.DPoP), await s.DPoP.addProof(a, c, \"POST\"));\n  let d = await zu(e, t, r, a, i, c, s);\n  return s?.DPoP?.cacheNonce(d, a), d;\n}\no(ju, \"tokenEndpointRequest\");\nvar Ss = /* @__PURE__ */ new WeakMap(), vs = /* @__PURE__ */ new WeakMap();\nfunction Kr(e) {\n  if (!e.id_token)\n    return;\n  let t = Ss.get(e);\n  if (!t)\n    throw C('\"ref\" was already garbage collected or did not resolve from the proper sources', Y);\n  return t;\n}\no(Kr, \"getValidatedIdTokenClaims\");\nasync function As(e, t, r, n, i, s) {\n  if (At(e), Et(t), !vt(r, Response))\n    throw C('\"response\" must be an instance of Response', q);\n  await Bu(r, 200, \"Token Endpoint\"), Nr(r);\n  let a = await io(r);\n  if ($(a.access_token, '\"response\" body \"access_token\" property', R, {\n    body: a\n  }), $(a.token_type, '\"response\" body \"token_type\" property', R, {\n    body: a\n  }), a.token_type = a.token_type.toLowerCase(), a.expires_in !== void 0) {\n    let c = typeof a.expires_in != \"number\" ? parseFloat(a.expires_in) : a.expires_in;\n    xt(c, !0, '\"response\" body \"expires_in\" property', R, {\n      body: a\n    }), a.expires_in = c;\n  }\n  if (a.refresh_token !== void 0 && $(a.refresh_token, '\"response\" body \"refresh_token\" property', R, {\n    body: a\n  }), a.scope !== void 0 && typeof a.scope != \"string\")\n    throw x('\"response\" body \"scope\" property must be a string', R, { body: a });\n  if (a.id_token !== void 0) {\n    $(a.id_token, '\"response\" body \"id_token\" property', R, {\n      body: a\n    });\n    let c = [\"aud\", \"exp\", \"iat\", \"iss\", \"sub\"];\n    t.require_auth_time === !0 && c.push(\"auth_time\"), t.default_max_age !== void 0 && (xt(t.default_max_age, !0, '\"client.default_max_age\"'), c.push(\"auth_time\")), n?.length && c.push(...n);\n    let { claims: d, jwt: u } = await Ps(a.id_token, Us.bind(void 0, t.id_token_signed_response_alg, e.id_token_signing_alg_values_supported, \"RS256\"), Ze(t), Hr(t), i).then(Zu.bind(void 0, c)).then(Is.bind(void 0, e)).then(ks.bind(void 0, t.client_id));\n    if (Array.isArray(d.aud) && d.aud.length !== 1) {\n      if (d.azp === void 0)\n        throw x('ID Token \"aud\" (audience) claim includes additional untrusted audiences', be, { claims: d, claim: \"aud\" });\n      if (d.azp !== t.client_id)\n        throw x('unexpected ID Token \"azp\" (authorized party) claim value', be, { expected: t.client_id, claims: d, claim: \"azp\" });\n    }\n    d.auth_time !== void 0 && xt(d.auth_time, !0, 'ID Token \"auth_time\" (authentication time)', R, { claims: d }), vs.set(r, u), Ss.set(a, d);\n  }\n  if (s?.[a.token_type] !== void 0)\n    s[a.token_type](r, a);\n  else if (a.token_type !== \"dpop\" && a.token_type !== \"bearer\")\n    throw new X(\"unsupported `token_type` value\", { cause: { body: a } });\n  return a;\n}\no(As, \"processGenericAccessTokenResponse\");\nfunction Es(e) {\n  let t;\n  if (t = Wu(e))\n    throw new Zn(\"server responded with a challenge in the WWW-Authenticate HTTP Header\", { cause: t, response: e });\n}\no(Es, \"checkAuthenticationChallenges\");\nfunction Vu(e, t) {\n  return t.claims.aud !== void 0 ? ks(e, t) : t;\n}\no(Vu, \"validateOptionalAudience\");\nfunction ks(e, t) {\n  if (Array.isArray(t.claims.aud)) {\n    if (!t.claims.aud.includes(e))\n      throw x('unexpected JWT \"aud\" (audience) claim value', be, {\n        expected: e,\n        claims: t.claims,\n        claim: \"aud\"\n      });\n  } else if (t.claims.aud !== e)\n    throw x('unexpected JWT \"aud\" (audience) claim value', be, {\n      expected: e,\n      claims: t.claims,\n      claim: \"aud\"\n    });\n  return t;\n}\no(ks, \"validateAudience\");\nfunction Fu(e, t) {\n  return t.claims.iss !== void 0 ? Is(e, t) : t;\n}\no(Fu, \"validateOptionalIssuer\");\nfunction Is(e, t) {\n  let r = e[pd]?.(t) ?? e.issuer;\n  if (t.claims.iss !== r)\n    throw x('unexpected JWT \"iss\" (issuer) claim value', be, {\n      expected: r,\n      claims: t.claims,\n      claim: \"iss\"\n    });\n  return t;\n}\no(Is, \"validateIssuer\");\nvar ro = /* @__PURE__ */ new WeakSet();\nfunction Gu(e) {\n  return ro.add(e), e;\n}\no(Gu, \"brand\");\nvar qu = Symbol();\nasync function Ts(e, t, r, n, i, s, a) {\n  if (At(e), Et(t), !ro.has(n))\n    throw C('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()', Y);\n  $(i, '\"redirectUri\"');\n  let c = Oe(n, \"code\");\n  if (!c)\n    throw x('no authorization code in \"callbackParameters\"', R);\n  let d = new URLSearchParams(a?.additionalParameters);\n  return d.set(\"redirect_uri\", i), d.set(\"code\", c), s !== qu && ($(s, '\"codeVerifier\"'), d.set(\"code_verifier\", s)), ju(e, t, r, \"authorization_code\", d, a);\n}\no(Ts, \"authorizationCodeGrantRequest\");\nvar Xu = {\n  aud: \"audience\",\n  c_hash: \"code hash\",\n  client_id: \"client id\",\n  exp: \"expiration time\",\n  iat: \"issued at\",\n  iss: \"issuer\",\n  jti: \"jwt id\",\n  nonce: \"nonce\",\n  s_hash: \"state hash\",\n  sub: \"subject\",\n  ath: \"access token hash\",\n  htm: \"http method\",\n  htu: \"http uri\",\n  cnf: \"confirmation\",\n  auth_time: \"authentication time\"\n};\nfunction Zu(e, t) {\n  for (let r of e)\n    if (t.claims[r] === void 0)\n      throw x(`JWT \"${r}\" (${Xu[r]}) claim missing`, R, {\n        claims: t.claims\n      });\n  return t;\n}\no(Zu, \"validatePresence\");\nvar Mn = Symbol(), zn = Symbol();\nasync function Rs(e, t, r, n) {\n  return typeof n?.expectedNonce == \"string\" || typeof n?.maxAge == \"number\" || n?.requireIdToken ? Qu(e, t, r, n.expectedNonce, n.maxAge, n[Vn], n.recognizedTokenTypes) : Yu(e, t, r, n?.[Vn], n?.recognizedTokenTypes);\n}\no(Rs, \"processAuthorizationCodeResponse\");\nasync function Qu(e, t, r, n, i, s, a) {\n  let c = [];\n  switch (n) {\n    case void 0:\n      n = Mn;\n      break;\n    case Mn:\n      break;\n    default:\n      $(n, '\"expectedNonce\" argument'), c.push(\"nonce\");\n  }\n  switch (i ??= t.default_max_age, i) {\n    case void 0:\n      i = zn;\n      break;\n    case zn:\n      break;\n    default:\n      xt(i, !0, '\"maxAge\" argument'), c.push(\"auth_time\");\n  }\n  let d = await As(e, t, r, c, s, a);\n  $(d.id_token, '\"response\" body \"id_token\" property', R, {\n    body: d\n  });\n  let u = Kr(d);\n  if (i !== zn) {\n    let f = Dr() + Ze(t), l = Hr(t);\n    if (u.auth_time + i < f - l)\n      throw x(\"too much time has elapsed since the last End-User authentication\", Ir, { claims: u, now: f, tolerance: l, claim: \"auth_time\" });\n  }\n  if (n === Mn) {\n    if (u.nonce !== void 0)\n      throw x('unexpected ID Token \"nonce\" claim value', be, {\n        expected: void 0,\n        claims: u,\n        claim: \"nonce\"\n      });\n  } else if (u.nonce !== n)\n    throw x('unexpected ID Token \"nonce\" claim value', be, {\n      expected: n,\n      claims: u,\n      claim: \"nonce\"\n    });\n  return d;\n}\no(Qu, \"processAuthorizationCodeOpenIDResponse\");\nasync function Yu(e, t, r, n, i) {\n  let s = await As(e, t, r, void 0, n, i), a = Kr(s);\n  if (a) {\n    if (t.default_max_age !== void 0) {\n      xt(t.default_max_age, !0, '\"client.default_max_age\"');\n      let c = Dr() + Ze(t), d = Hr(t);\n      if (a.auth_time + t.default_max_age < c - d)\n        throw x(\"too much time has elapsed since the last End-User authentication\", Ir, { claims: a, now: c, tolerance: d, claim: \"auth_time\" });\n    }\n    if (a.nonce !== void 0)\n      throw x('unexpected ID Token \"nonce\" claim value', be, {\n        expected: void 0,\n        claims: a,\n        claim: \"nonce\"\n      });\n  }\n  return s;\n}\no(Yu, \"processAuthorizationCodeOAuth2Response\");\nvar ed = \"OAUTH_WWW_AUTHENTICATE_CHALLENGE\", td = \"OAUTH_RESPONSE_BODY_ERROR\", rd = \"OAUTH_UNSUPPORTED_OPERATION\", nd = \"OAUTH_AUTHORIZATION_RESPONSE_ERROR\", od = \"OAUTH_JWT_USERINFO_EXPECTED\", Qn = \"OAUTH_PARSE_ERROR\", R = \"OAUTH_INVALID_RESPONSE\";\nvar id = \"OAUTH_RESPONSE_IS_NOT_JSON\", no = \"OAUTH_RESPONSE_IS_NOT_CONFORM\", sd = \"OAUTH_HTTP_REQUEST_FORBIDDEN\", ad = \"OAUTH_REQUEST_PROTOCOL_FORBIDDEN\", Ir = \"OAUTH_JWT_TIMESTAMP_CHECK_FAILED\", be = \"OAUTH_JWT_CLAIM_COMPARISON_FAILED\", Cs = \"OAUTH_JSON_ATTRIBUTE_COMPARISON_FAILED\";\nvar cd = \"OAUTH_MISSING_SERVER_METADATA\", ud = \"OAUTH_INVALID_SERVER_METADATA\";\nfunction Nr(e) {\n  if (e.bodyUsed)\n    throw C('\"response\" body has been used already', Y);\n}\no(Nr, \"assertReadableResponse\");\nfunction as(e) {\n  let { algorithm: t } = e;\n  if (typeof t.modulusLength != \"number\" || t.modulusLength < 2048)\n    throw new X(`unsupported ${t.name} modulusLength`, {\n      cause: e\n    });\n}\no(as, \"checkRsaKeyAlgorithm\");\nfunction dd(e) {\n  let { algorithm: t } = e;\n  switch (t.namedCurve) {\n    case \"P-256\":\n      return \"SHA-256\";\n    case \"P-384\":\n      return \"SHA-384\";\n    case \"P-521\":\n      return \"SHA-512\";\n    default:\n      throw new X(\"unsupported ECDSA namedCurve\", { cause: e });\n  }\n}\no(dd, \"ecdsaHashName\");\nfunction ld(e) {\n  switch (e.algorithm.name) {\n    case \"ECDSA\":\n      return {\n        name: e.algorithm.name,\n        hash: dd(e)\n      };\n    case \"RSA-PSS\":\n      switch (as(e), e.algorithm.hash.name) {\n        case \"SHA-256\":\n        case \"SHA-384\":\n        case \"SHA-512\":\n          return {\n            name: e.algorithm.name,\n            saltLength: parseInt(e.algorithm.hash.name.slice(-3), 10) >> 3\n          };\n        default:\n          throw new X(\"unsupported RSA-PSS hash name\", { cause: e });\n      }\n    case \"RSASSA-PKCS1-v1_5\":\n      return as(e), e.algorithm.name;\n    case \"ML-DSA-44\":\n    case \"ML-DSA-65\":\n    case \"ML-DSA-87\":\n    case \"Ed25519\":\n      return e.algorithm.name;\n  }\n  throw new X(\"unsupported CryptoKey algorithm name\", { cause: e });\n}\no(ld, \"keyToSubtle\");\nasync function Ps(e, t, r, n, i) {\n  let { 0: s, 1: a, length: c } = e.split(\".\");\n  if (c === 5)\n    if (i !== void 0)\n      e = await i(e), { 0: s, 1: a, length: c } = e.split(\".\");\n    else\n      throw new X(\"JWE decryption is not configured\", { cause: e });\n  if (c !== 3)\n    throw x(\"Invalid JWT\", R, e);\n  let d;\n  try {\n    d = JSON.parse(ae(ce(s)));\n  } catch (l) {\n    throw x(\"failed to parse JWT Header body as base64url encoded JSON\", Qn, l);\n  }\n  if (!Er(d))\n    throw x(\"JWT Header must be a top level object\", R, e);\n  if (t(d), d.crit !== void 0)\n    throw new X('no JWT \"crit\" header parameter extensions are supported', {\n      cause: { header: d }\n    });\n  let u;\n  try {\n    u = JSON.parse(ae(ce(a)));\n  } catch (l) {\n    throw x(\"failed to parse JWT Payload body as base64url encoded JSON\", Qn, l);\n  }\n  if (!Er(u))\n    throw x(\"JWT Payload must be a top level object\", R, e);\n  let f = Dr() + r;\n  if (u.exp !== void 0) {\n    if (typeof u.exp != \"number\")\n      throw x('unexpected JWT \"exp\" (expiration time) claim type', R, { claims: u });\n    if (u.exp <= f - n)\n      throw x('unexpected JWT \"exp\" (expiration time) claim value, expiration is past current timestamp', Ir, { claims: u, now: f, tolerance: n, claim: \"exp\" });\n  }\n  if (u.iat !== void 0 && typeof u.iat != \"number\")\n    throw x('unexpected JWT \"iat\" (issued at) claim type', R, { claims: u });\n  if (u.iss !== void 0 && typeof u.iss != \"string\")\n    throw x('unexpected JWT \"iss\" (issuer) claim type', R, { claims: u });\n  if (u.nbf !== void 0) {\n    if (typeof u.nbf != \"number\")\n      throw x('unexpected JWT \"nbf\" (not before) claim type', R, { claims: u });\n    if (u.nbf > f + n)\n      throw x('unexpected JWT \"nbf\" (not before) claim value', Ir, {\n        claims: u,\n        now: f,\n        tolerance: n,\n        claim: \"nbf\"\n      });\n  }\n  if (u.aud !== void 0 && typeof u.aud != \"string\" && !Array.isArray(u.aud))\n    throw x('unexpected JWT \"aud\" (audience) claim type', R, { claims: u });\n  return { header: d, claims: u, jwt: e };\n}\no(Ps, \"validateJwt\");\nfunction Us(e, t, r, n) {\n  if (e !== void 0) {\n    if (typeof e == \"string\" ? n.alg !== e : !e.includes(n.alg))\n      throw x('unexpected JWT \"alg\" header parameter', R, {\n        header: n,\n        expected: e,\n        reason: \"client configuration\"\n      });\n    return;\n  }\n  if (Array.isArray(t)) {\n    if (!t.includes(n.alg))\n      throw x('unexpected JWT \"alg\" header parameter', R, {\n        header: n,\n        expected: t,\n        reason: \"authorization server metadata\"\n      });\n    return;\n  }\n  if (r !== void 0) {\n    if (typeof r == \"string\" ? n.alg !== r : typeof r == \"function\" ? !r(n.alg) : !r.includes(n.alg))\n      throw x('unexpected JWT \"alg\" header parameter', R, {\n        header: n,\n        expected: r,\n        reason: \"default value\"\n      });\n    return;\n  }\n  throw x('missing client or server configuration to verify used JWT \"alg\" header parameter', void 0, { client: e, issuer: t, fallback: r });\n}\no(Us, \"checkSigningAlgorithm\");\nfunction Oe(e, t) {\n  let { 0: r, length: n } = e.getAll(t);\n  if (n > 1)\n    throw x(`\"${t}\" parameter must be provided only once`, R);\n  return r;\n}\no(Oe, \"getURLSearchParameter\");\nvar oo = Symbol(), fd = Symbol();\nfunction Os(e, t, r, n) {\n  if (At(e), Et(t), r instanceof URL && (r = r.searchParams), !(r instanceof URLSearchParams))\n    throw C('\"parameters\" must be an instance of URLSearchParams, or URL', q);\n  if (Oe(r, \"response\"))\n    throw x('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()', R, { parameters: r });\n  let i = Oe(r, \"iss\"), s = Oe(r, \"state\");\n  if (!i && e.authorization_response_iss_parameter_supported)\n    throw x('response parameter \"iss\" (issuer) missing', R, { parameters: r });\n  if (i && i !== e.issuer)\n    throw x('unexpected \"iss\" (issuer) response parameter value', R, {\n      expected: e.issuer,\n      parameters: r\n    });\n  switch (n) {\n    case void 0:\n    case fd:\n      if (s !== void 0)\n        throw x('unexpected \"state\" response parameter encountered', R, {\n          expected: void 0,\n          parameters: r\n        });\n      break;\n    case oo:\n      break;\n    default:\n      if ($(n, '\"expectedState\" argument'), s !== n)\n        throw x(s === void 0 ? 'response parameter \"state\" missing' : 'unexpected \"state\" response parameter value', R, { expected: n, parameters: r });\n  }\n  if (Oe(r, \"error\"))\n    throw new St(\"authorization response from the server is an error\", {\n      cause: r\n    });\n  let c = Oe(r, \"id_token\"), d = Oe(r, \"token\");\n  if (c !== void 0 || d !== void 0)\n    throw new X(\"implicit and hybrid flows are not supported\");\n  return Gu(new URLSearchParams(r));\n}\no(Os, \"validateAuthResponse\");\nasync function io(e, t = ps) {\n  let r;\n  try {\n    r = await e.json();\n  } catch (n) {\n    throw t(e), x('failed to parse \"response\" body as JSON', Qn, n);\n  }\n  if (!Er(r))\n    throw x('\"response\" body must be a top level object', R, { body: r });\n  return r;\n}\no(io, \"getResponseJsonBody\");\nvar cs = Symbol(), pd = Symbol();\n\n// node_modules/@auth/core/lib/actions/callback/oauth/checks.js\nvar so = 900;\nasync function ao(e, t, r) {\n  let { cookies: n, logger: i } = r, s = n[e], a = /* @__PURE__ */ new Date();\n  a.setTime(a.getTime() + so * 1e3), i.debug(`CREATE_${e.toUpperCase()}`, {\n    name: s.name,\n    payload: t,\n    COOKIE_TTL: so,\n    expires: a\n  });\n  let c = await _r({\n    ...r.jwt,\n    maxAge: so,\n    token: { value: t },\n    salt: s.name\n  }), d = { ...s.options, expires: a };\n  return { name: s.name, value: c, options: d };\n}\no(ao, \"sealCookie\");\nasync function hd(e, t, r) {\n  try {\n    let { logger: n, cookies: i, jwt: s } = r;\n    if (n.debug(`PARSE_${e.toUpperCase()}`, { cookie: t }), !t)\n      throw new pe(`${e} cookie was missing`);\n    let a = await xr({\n      ...s,\n      token: t,\n      salt: i[e].name\n    });\n    if (a?.value)\n      return a.value;\n    throw new Error(\"Invalid cookie\");\n  } catch (n) {\n    throw new pe(`${e} value could not be parsed`, {\n      cause: n\n    });\n  }\n}\no(hd, \"parseCookie\");\nfunction md(e, t, r) {\n  let { logger: n, cookies: i } = t, s = i[e];\n  n.debug(`CLEAR_${e.toUpperCase()}`, { cookie: s }), r.push({\n    name: s.name,\n    value: \"\",\n    options: { ...i[e].options, maxAge: 0 }\n  });\n}\no(md, \"clearCookie\");\nfunction co(e, t) {\n  return async function(r, n, i) {\n    let { provider: s, logger: a } = i;\n    if (!s?.checks?.includes(e))\n      return;\n    let c = r?.[i.cookies[t].name];\n    a.debug(`USE_${t.toUpperCase()}`, { value: c });\n    let d = await hd(t, c, i);\n    return md(t, i, n), d;\n  };\n}\no(co, \"useCookie\");\nvar Hs = {\n  /** Creates a PKCE code challenge and verifier pair. The verifier in stored in the cookie. */\n  async create(e) {\n    let t = Pr(), r = await Lr(t);\n    return { cookie: await ao(\"pkceCodeVerifier\", t, e), value: r };\n  },\n  /**\n   * Returns code_verifier if the provider is configured to use PKCE,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the code_verifier is missing or invalid.\n   */\n  use: co(\"pkce\", \"pkceCodeVerifier\")\n}, yd = 900, Ls = \"encodedState\", uo = {\n  /** Creates a state cookie with an optionally encoded body. */\n  async create(e, t) {\n    let { provider: r } = e;\n    if (!r.checks.includes(\"state\")) {\n      if (t)\n        throw new pe(\"State data was provided but the provider is not configured to use state\");\n      return;\n    }\n    let n = {\n      origin: t,\n      random: Ur()\n    }, i = await _r({\n      secret: e.jwt.secret,\n      token: n,\n      salt: Ls,\n      maxAge: yd\n    });\n    return { cookie: await ao(\"state\", i, e), value: i };\n  },\n  /**\n   * Returns state if the provider is configured to use state,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the state is missing or invalid.\n   */\n  use: co(\"state\", \"state\"),\n  /** Decodes the state. If it could not be decoded, it throws an error. */\n  async decode(e, t) {\n    try {\n      t.logger.debug(\"DECODE_STATE\", { state: e });\n      let r = await xr({\n        secret: t.jwt.secret,\n        token: e,\n        salt: Ls\n      });\n      if (r)\n        return r;\n      throw new Error(\"Invalid state\");\n    } catch (r) {\n      throw new pe(\"State could not be decoded\", { cause: r });\n    }\n  }\n}, Ds = {\n  async create(e) {\n    if (!e.provider.checks.includes(\"nonce\"))\n      return;\n    let t = Or();\n    return { cookie: await ao(\"nonce\", t, e), value: t };\n  },\n  /**\n   * Returns nonce if the provider is configured to use nonce,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the nonce is missing or invalid.\n   * @see https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes\n   * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#nonce\n   */\n  use: co(\"nonce\", \"nonce\")\n};\n\n// node_modules/@auth/core/lib/utils/env.js\nfunction lo(e, t, r = !1) {\n  try {\n    let n = e.AUTH_URL;\n    n && (t.basePath ? r || _t(t).warn(\"env-url-basepath-redundant\") : t.basePath = new URL(n).pathname);\n  } catch {\n  } finally {\n    t.basePath ?? (t.basePath = \"/auth\");\n  }\n  if (!t.secret?.length) {\n    t.secret = [];\n    let n = e.AUTH_SECRET;\n    n && t.secret.push(n);\n    for (let i of [1, 2, 3]) {\n      let s = e[`AUTH_SECRET_${i}`];\n      s && t.secret.unshift(s);\n    }\n  }\n  t.redirectProxyUrl ?? (t.redirectProxyUrl = e.AUTH_REDIRECT_PROXY_URL), t.trustHost ?? (t.trustHost = !!(e.AUTH_URL ?? e.AUTH_TRUST_HOST ?? e.VERCEL ?? e.CF_PAGES ?? e.NODE_ENV !== \"production\")), t.providers = t.providers.map((n) => {\n    let { id: i } = typeof n == \"function\" ? n({}) : n, s = i.toUpperCase().replace(/-/g, \"_\"), a = e[`AUTH_${s}_ID`], c = e[`AUTH_${s}_SECRET`], d = e[`AUTH_${s}_ISSUER`], u = e[`AUTH_${s}_KEY`], f = typeof n == \"function\" ? n({ clientId: a, clientSecret: c, issuer: d, apiKey: u }) : n;\n    return f.type === \"oauth\" || f.type === \"oidc\" ? (f.clientId ?? (f.clientId = a), f.clientSecret ?? (f.clientSecret = c), f.issuer ?? (f.issuer = d)) : f.type === \"email\" && (f.apiKey ?? (f.apiKey = u)), f;\n  });\n}\no(lo, \"setEnvDefaults\");\n\n// node_modules/@convex-dev/auth/dist/server/provider_utils.js\nfunction Ns(e) {\n  let t = ho(e), r = t.providers.filter((n) => n.type === \"credentials\").map((n) => n.extraProviders).flat().filter((n) => n !== void 0);\n  return {\n    ...t,\n    extraProviders: Ed(r),\n    theme: t.theme ?? {\n      colorScheme: \"auto\",\n      logo: \"\",\n      brandColor: \"\",\n      buttonText: \"\"\n    }\n  };\n}\no(Ns, \"configDefaults\");\nfunction Ws(e) {\n  let t = { providers: [e] };\n  return ho(t), t.providers[0];\n}\no(Ws, \"materializeProvider\");\nfunction Ed(e) {\n  let t = { providers: e };\n  return ho(t), t.providers;\n}\no(Ed, \"materializeProviders\");\nfunction ho(e) {\n  let t = e.providers.map((n) => kd(typeof n == \"function\" ? n() : n)), r = { ...e, providers: t };\n  return lo(process.env, r), r.providers.forEach((n) => {\n    if (n.type === \"phone\") {\n      let i = n.id.toUpperCase().replace(/-/g, \"_\");\n      n.apiKey ??= process.env[`AUTH_${i}_KEY`];\n    }\n  }), r;\n}\no(ho, \"materializeAndDefaultProviders\");\nfunction kd(e) {\n  let t = po(e, e.options);\n  return t.type === \"oauth\" || t.type === \"oidc\" ? Rd(t) : t;\n}\no(kd, \"providerDefaults\");\nvar Id = /* @__PURE__ */ o((e) => $s({\n  id: e.sub ?? e.id ?? crypto.randomUUID(),\n  name: e.name ?? e.nickname ?? e.preferred_username,\n  email: e.email ?? void 0,\n  image: e.picture ?? void 0\n}), \"defaultProfile\"), Td = /* @__PURE__ */ o((e) => $s({\n  access_token: e.access_token,\n  id_token: e.id_token,\n  refresh_token: e.refresh_token,\n  expires_at: e.expires_at,\n  scope: e.scope,\n  token_type: e.token_type,\n  session_state: e.session_state\n}), \"defaultAccount\");\nfunction $s(e) {\n  let t = {};\n  for (let [r, n] of Object.entries(e))\n    n !== void 0 && (t[r] = n);\n  return t;\n}\no($s, \"stripUndefined\");\nfunction Rd(e) {\n  e.issuer && (e.wellKnown ??= `${e.issuer}/.well-known/openid-configuration`);\n  let t = e.checks ?? [\"pkce\"];\n  return e.redirectProxyUrl && (t.includes(\"state\") || t.push(\"state\"), e.redirectProxyUrl = `${e.redirectProxyUrl}/callback/${e.id}`), {\n    ...e,\n    checks: t,\n    profile: e.profile ?? Id,\n    account: e.account ?? Td\n  };\n}\no(Rd, \"normalizeOAuth\");\nvar Cd = \"convexauth.mumbojumbo\", Pd = `https://${Cd}`;\nfunction Le(e, t) {\n  if (!e && t)\n    return;\n  if (typeof e == \"string\")\n    return { url: new URL(e) };\n  let r = new URL(e?.url ?? Pd);\n  if (e?.params != null)\n    for (let [n, i] of Object.entries(e.params))\n      r.searchParams.set(n, String(n === \"claims\" ? JSON.stringify(i) : i));\n  return { url: r, request: e?.request, conform: e?.conform };\n}\no(Le, \"normalizeEndpoint\");\nfunction po(e, ...t) {\n  if (!t.length)\n    return e;\n  let r = t.shift();\n  if (fo(e) && fo(r))\n    for (let n in r)\n      fo(r[n]) ? (e[n] || Object.assign(e, { [n]: {} }), po(e[n], r[n])) : Object.assign(e, { [n]: r[n] });\n  return po(e, ...t);\n}\no(po, \"merge\");\nfunction fo(e) {\n  return e && typeof e == \"object\" && !Array.isArray(e);\n}\no(fo, \"isObject\");\nfunction Bs(e, t) {\n  let r = e.providers.concat(t ? e.extraProviders : []).map((n) => `\\`${n.id}\\``);\n  return r.length > 0 ? r.join(\", \") : \"no providers have been configured\";\n}\no(Bs, \"listAvailableProviders\");\n\n// node_modules/@oslojs/binary/dist/uint.js\nvar mo = class {\n  static {\n    o(this, \"BigEndian\");\n  }\n  uint8(t, r) {\n    if (t.byteLength < r + 1)\n      throw new TypeError(\"Insufficient bytes\");\n    return t[r];\n  }\n  uint16(t, r) {\n    if (t.byteLength < r + 2)\n      throw new TypeError(\"Insufficient bytes\");\n    return t[r] << 8 | t[r + 1];\n  }\n  uint32(t, r) {\n    if (t.byteLength < r + 4)\n      throw new TypeError(\"Insufficient bytes\");\n    let n = 0;\n    for (let i = 0; i < 4; i++)\n      n |= t[r + i] << 24 - i * 8;\n    return n;\n  }\n  uint64(t, r) {\n    if (t.byteLength < r + 8)\n      throw new TypeError(\"Insufficient bytes\");\n    let n = 0n;\n    for (let i = 0; i < 8; i++)\n      n |= BigInt(t[r + i]) << BigInt(56 - i * 8);\n    return n;\n  }\n  putUint8(t, r, n) {\n    if (t.length < n + 1)\n      throw new TypeError(\"Not enough space\");\n    if (r < 0 || r > 255)\n      throw new TypeError(\"Invalid uint8 value\");\n    t[n] = r;\n  }\n  putUint16(t, r, n) {\n    if (t.length < n + 2)\n      throw new TypeError(\"Not enough space\");\n    if (r < 0 || r > 65535)\n      throw new TypeError(\"Invalid uint16 value\");\n    t[n] = r >> 8, t[n + 1] = r & 255;\n  }\n  putUint32(t, r, n) {\n    if (t.length < n + 4)\n      throw new TypeError(\"Not enough space\");\n    if (r < 0 || r > 4294967295)\n      throw new TypeError(\"Invalid uint32 value\");\n    for (let i = 0; i < 4; i++)\n      t[n + i] = r >> (3 - i) * 8 & 255;\n  }\n  putUint64(t, r, n) {\n    if (t.length < n + 8)\n      throw new TypeError(\"Not enough space\");\n    if (r < 0 || r > 18446744073709551615n)\n      throw new TypeError(\"Invalid uint64 value\");\n    for (let i = 0; i < 8; i++)\n      t[n + i] = Number(r >> BigInt((7 - i) * 8) & 0xffn);\n  }\n}, yo = class {\n  static {\n    o(this, \"LittleEndian\");\n  }\n  uint8(t, r) {\n    if (t.byteLength < r + 1)\n      throw new TypeError(\"Insufficient bytes\");\n    return t[r];\n  }\n  uint16(t, r) {\n    if (t.byteLength < r + 2)\n      throw new TypeError(\"Insufficient bytes\");\n    return t[r] | t[r + 1] << 8;\n  }\n  uint32(t, r) {\n    if (t.byteLength < r + 4)\n      throw new TypeError(\"Insufficient bytes\");\n    let n = 0;\n    for (let i = 0; i < 4; i++)\n      n |= t[r + i] << i * 8;\n    return n;\n  }\n  uint64(t, r) {\n    if (t.byteLength < r + 8)\n      throw new TypeError(\"Insufficient bytes\");\n    let n = 0n;\n    for (let i = 0; i < 8; i++)\n      n |= BigInt(t[r + i]) << BigInt(i * 8);\n    return n;\n  }\n  putUint8(t, r, n) {\n    if (t.length < 1 + n)\n      throw new TypeError(\"Insufficient space\");\n    if (r < 0 || r > 255)\n      throw new TypeError(\"Invalid uint8 value\");\n    t[n] = r;\n  }\n  putUint16(t, r, n) {\n    if (t.length < 2 + n)\n      throw new TypeError(\"Insufficient space\");\n    if (r < 0 || r > 65535)\n      throw new TypeError(\"Invalid uint16 value\");\n    t[n + 1] = r >> 8, t[n] = r & 255;\n  }\n  putUint32(t, r, n) {\n    if (t.length < 4 + n)\n      throw new TypeError(\"Insufficient space\");\n    if (r < 0 || r > 4294967295)\n      throw new TypeError(\"Invalid uint32 value\");\n    for (let i = 0; i < 4; i++)\n      t[n + i] = r >> i * 8 & 255;\n  }\n  putUint64(t, r, n) {\n    if (t.length < 8 + n)\n      throw new TypeError(\"Insufficient space\");\n    if (r < 0 || r > 18446744073709551615n)\n      throw new TypeError(\"Invalid uint64 value\");\n    for (let i = 0; i < 8; i++)\n      t[n + i] = Number(r >> BigInt(i * 8) & 0xffn);\n  }\n}, Qe = new mo(), Ud = new yo();\n\n// node_modules/@oslojs/binary/dist/bits.js\nfunction ee(e, t) {\n  return (e << 32 - t | e >>> t) >>> 0;\n}\no(ee, \"rotr32\");\n\n// node_modules/@oslojs/binary/dist/big.js\nfunction Wr(e) {\n  if (e.byteLength < 1)\n    throw new TypeError(\"Empty Uint8Array\");\n  let t = 0n;\n  for (let r = 0; r < e.byteLength; r++)\n    t += BigInt(e[r]) << BigInt((e.byteLength - 1 - r) * 8);\n  return t;\n}\no(Wr, \"bigIntFromBytes\");\n\n// node_modules/@oslojs/crypto/dist/sha2/sha224.js\nvar $_ = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]);\n\n// node_modules/@oslojs/crypto/dist/sha2/sha256.js\nfunction wo(e) {\n  let t = new $r();\n  return t.update(e), t.digest();\n}\no(wo, \"sha256\");\nvar $r = class {\n  static {\n    o(this, \"SHA256\");\n  }\n  blockSize = 64;\n  size = 32;\n  blocks = new Uint8Array(64);\n  currentBlockSize = 0;\n  H = new Uint32Array([\n    1779033703,\n    3144134277,\n    1013904242,\n    2773480762,\n    1359893119,\n    2600822924,\n    528734635,\n    1541459225\n  ]);\n  l = 0n;\n  w = new Uint32Array(64);\n  update(t) {\n    if (this.l += BigInt(t.byteLength) * 8n, this.currentBlockSize + t.byteLength < 64) {\n      this.blocks.set(t, this.currentBlockSize), this.currentBlockSize += t.byteLength;\n      return;\n    }\n    let r = 0;\n    if (this.currentBlockSize > 0) {\n      let n = t.slice(0, 64 - this.currentBlockSize);\n      this.blocks.set(n, this.currentBlockSize), this.process(), r += n.byteLength, this.currentBlockSize = 0;\n    }\n    for (; r + 64 <= t.byteLength; ) {\n      let n = t.slice(r, r + 64);\n      this.blocks.set(n), this.process(), r += 64;\n    }\n    if (t.byteLength - r > 0) {\n      let n = t.slice(r);\n      this.blocks.set(n), this.currentBlockSize = n.byteLength;\n    }\n  }\n  digest() {\n    this.blocks[this.currentBlockSize] = 128, this.currentBlockSize += 1, 64 - this.currentBlockSize < 8 && (this.blocks.fill(0, this.currentBlockSize), this.process(), this.currentBlockSize = 0), this.blocks.fill(0, this.currentBlockSize), Qe.putUint64(this.blocks, this.l, this.blockSize - 8), this.process();\n    let t = new Uint8Array(32);\n    for (let r = 0; r < 8; r++)\n      Qe.putUint32(t, this.H[r], r * 4);\n    return t;\n  }\n  process() {\n    for (let u = 0; u < 16; u++)\n      this.w[u] = (this.blocks[u * 4] << 24 | this.blocks[u * 4 + 1] << 16 | this.blocks[u * 4 + 2] << 8 | this.blocks[u * 4 + 3]) >>> 0;\n    for (let u = 16; u < 64; u++) {\n      let f = (ee(this.w[u - 2], 17) ^ ee(this.w[u - 2], 19) ^ this.w[u - 2] >>> 10) >>> 0, l = (ee(this.w[u - 15], 7) ^ ee(this.w[u - 15], 18) ^ this.w[u - 15] >>> 3) >>> 0;\n      this.w[u] = f + this.w[u - 7] + l + this.w[u - 16] | 0;\n    }\n    let t = this.H[0], r = this.H[1], n = this.H[2], i = this.H[3], s = this.H[4], a = this.H[5], c = this.H[6], d = this.H[7];\n    for (let u = 0; u < 64; u++) {\n      let f = (ee(s, 6) ^ ee(s, 11) ^ ee(s, 25)) >>> 0, l = (s & a ^ ~s & c) >>> 0, y = d + f + l + Ld[u] + this.w[u] | 0, p = (ee(t, 2) ^ ee(t, 13) ^ ee(t, 22)) >>> 0, m = (t & r ^ t & n ^ r & n) >>> 0, S = p + m | 0;\n      d = c, c = a, a = s, s = i + y | 0, i = n, n = r, r = t, t = y + S | 0;\n    }\n    this.H[0] = t + this.H[0] | 0, this.H[1] = r + this.H[1] | 0, this.H[2] = n + this.H[2] | 0, this.H[3] = i + this.H[3] | 0, this.H[4] = s + this.H[4] | 0, this.H[5] = a + this.H[5] | 0, this.H[6] = c + this.H[6] | 0, this.H[7] = d + this.H[7] | 0;\n  }\n}, Ld = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]);\n\n// node_modules/@oslojs/crypto/dist/sha2/sha512.js\nvar q_ = new BigUint64Array([\n  0x428a2f98d728ae22n,\n  0x7137449123ef65cdn,\n  0xb5c0fbcfec4d3b2fn,\n  0xe9b5dba58189dbbcn,\n  0x3956c25bf348b538n,\n  0x59f111f1b605d019n,\n  0x923f82a4af194f9bn,\n  0xab1c5ed5da6d8118n,\n  0xd807aa98a3030242n,\n  0x12835b0145706fben,\n  0x243185be4ee4b28cn,\n  0x550c7dc3d5ffb4e2n,\n  0x72be5d74f27b896fn,\n  0x80deb1fe3b1696b1n,\n  0x9bdc06a725c71235n,\n  0xc19bf174cf692694n,\n  0xe49b69c19ef14ad2n,\n  0xefbe4786384f25e3n,\n  0x0fc19dc68b8cd5b5n,\n  0x240ca1cc77ac9c65n,\n  0x2de92c6f592b0275n,\n  0x4a7484aa6ea6e483n,\n  0x5cb0a9dcbd41fbd4n,\n  0x76f988da831153b5n,\n  0x983e5152ee66dfabn,\n  0xa831c66d2db43210n,\n  0xb00327c898fb213fn,\n  0xbf597fc7beef0ee4n,\n  0xc6e00bf33da88fc2n,\n  0xd5a79147930aa725n,\n  0x06ca6351e003826fn,\n  0x142929670a0e6e70n,\n  0x27b70a8546d22ffcn,\n  0x2e1b21385c26c926n,\n  0x4d2c6dfc5ac42aedn,\n  0x53380d139d95b3dfn,\n  0x650a73548baf63den,\n  0x766a0abb3c77b2a8n,\n  0x81c2c92e47edaee6n,\n  0x92722c851482353bn,\n  0xa2bfe8a14cf10364n,\n  0xa81a664bbc423001n,\n  0xc24b8b70d0f89791n,\n  0xc76c51a30654be30n,\n  0xd192e819d6ef5218n,\n  0xd69906245565a910n,\n  0xf40e35855771202an,\n  0x106aa07032bbd1b8n,\n  0x19a4c116b8d2d0c8n,\n  0x1e376c085141ab53n,\n  0x2748774cdf8eeb99n,\n  0x34b0bcb5e19b48a8n,\n  0x391c0cb3c5c95a63n,\n  0x4ed8aa4ae3418acbn,\n  0x5b9cca4f7763e373n,\n  0x682e6ff3d6b2b8a3n,\n  0x748f82ee5defb2fcn,\n  0x78a5636f43172f60n,\n  0x84c87814a1f0ab72n,\n  0x8cc702081a6439ecn,\n  0x90befffa23631e28n,\n  0xa4506cebde82bde9n,\n  0xbef9a3f7b2c67915n,\n  0xc67178f2e372532bn,\n  0xca273eceea26619cn,\n  0xd186b8c721c0c207n,\n  0xeada7dd6cde0eb1en,\n  0xf57d4f7fee6ed178n,\n  0x06f067aa72176fban,\n  0x0a637dc5a2c898a6n,\n  0x113f9804bef90daen,\n  0x1b710b35131c471bn,\n  0x28db77f523047d84n,\n  0x32caab7b40c72493n,\n  0x3c9ebe0a15c9bebcn,\n  0x431d67c49c100d4cn,\n  0x4cc5d4becb3e42b6n,\n  0x597f299cfc657e2an,\n  0x5fcb6fab3ad6faecn,\n  0x6c44198c4a475817n\n]);\n\n// node_modules/@oslojs/encoding/dist/hex.js\nfunction go(e) {\n  let t = \"\";\n  for (let r = 0; r < e.length; r++)\n    t += Ms[e[r] >> 4], t += Ms[e[r] & 15];\n  return t;\n}\no(go, \"encodeHexLowerCase\");\nfunction Hd(e) {\n  if (e.length % 2 !== 0)\n    throw new Error(\"Invalid hex string\");\n  let t = new Uint8Array(e.length / 2);\n  for (let r = 0; r < e.length; r += 2) {\n    if (!(e[r] in Br))\n      throw new Error(\"Invalid character\");\n    if (!(e[r + 1] in Br))\n      throw new Error(\"Invalid character\");\n    t[r / 2] |= Br[e[r]] << 4, t[r / 2] |= Br[e[r + 1]];\n  }\n  return t;\n}\no(Hd, \"decodeHex\");\nvar Ms = \"0123456789abcdef\", Br = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n};\n\n// node_modules/@oslojs/encoding/dist/base32.js\nvar zs;\n(function(e) {\n  e[e.Include = 0] = \"Include\", e[e.None = 1] = \"None\";\n})(zs || (zs = {}));\nvar js;\n(function(e) {\n  e[e.Required = 0] = \"Required\", e[e.Ignore = 1] = \"Ignore\";\n})(js || (js = {}));\n\n// node_modules/@oslojs/encoding/dist/base64.js\nvar Vs;\n(function(e) {\n  e[e.Include = 0] = \"Include\", e[e.None = 1] = \"None\";\n})(Vs || (Vs = {}));\nvar Fs;\n(function(e) {\n  e[e.Required = 0] = \"Required\", e[e.Ignore = 1] = \"Ignore\";\n})(Fs || (Fs = {}));\n\n// node_modules/@oslojs/crypto/dist/random/index.js\nfunction Dd(e, t) {\n  if (t < 2)\n    throw new Error(\"Argument 'max' must be a positive integer larger than 1\");\n  let r = (t - 1n).toString(2).length, n = r % 8, i = new Uint8Array(Math.ceil(r / 8));\n  try {\n    e.read(i);\n  } catch (a) {\n    throw new Error(\"Failed to retrieve random bytes\", {\n      cause: a\n    });\n  }\n  n !== 0 && (i[0] &= (1 << n) - 1);\n  let s = Wr(i);\n  for (; s >= t; ) {\n    try {\n      e.read(i);\n    } catch (a) {\n      throw new Error(\"Failed to retrieve random bytes\", {\n        cause: a\n      });\n    }\n    n !== 0 && (i[0] &= (1 << n) - 1), s = Wr(i);\n  }\n  return s;\n}\no(Dd, \"generateRandomInteger\");\nfunction Kd(e, t) {\n  if (t < 2 || t > Number.MAX_SAFE_INTEGER)\n    throw new Error(\"Argument 'max' must be a positive integer larger than 1\");\n  return Number(Dd(e, BigInt(t)));\n}\no(Kd, \"generateRandomIntegerNumber\");\nfunction Gs(e, t, r) {\n  let n = \"\";\n  for (let i = 0; i < r; i++)\n    n += t[Kd(e, t.length)];\n  return n;\n}\no(Gs, \"generateRandomString\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/utils.js\nvar xe = \"|\", _o = \"|\";\nfunction Jr(e) {\n  return e !== void 0 ? Number(e) : void 0;\n}\no(Jr, \"stringToNumber\");\nasync function Ye(e) {\n  return go(wo(new TextEncoder().encode(e)));\n}\no(Ye, \"sha256\");\nfunction Mr(e, t) {\n  return Gs({\n    read(n) {\n      crypto.getRandomValues(n);\n    }\n  }, t, e);\n}\no(Mr, \"generateRandomString\");\nfunction xo(e) {\n  g(v.ERROR, e instanceof Error ? e.message + `\n` + e.stack?.replace(\"\\\\n\", `\n`) : e);\n}\no(xo, \"logError\");\nvar v = {\n  ERROR: \"ERROR\",\n  WARN: \"WARN\",\n  INFO: \"INFO\",\n  DEBUG: \"DEBUG\"\n};\nfunction g(e, ...t) {\n  let r = v[process.env.AUTH_LOG_LEVEL ?? \"INFO\"] ?? \"INFO\";\n  switch (e) {\n    case \"ERROR\":\n      console.error(...t);\n      break;\n    case \"WARN\":\n      r !== \"ERROR\" && console.warn(...t);\n      break;\n    case \"INFO\":\n      (r === \"INFO\" || r === \"DEBUG\") && console.info(...t);\n      break;\n    case \"DEBUG\":\n      r === \"DEBUG\" && console.debug(...t);\n      break;\n  }\n}\no(g, \"logWithLevel\");\nvar bo = 5;\nfunction L(e) {\n  return e === \"\" ? \"\" : process.env.AUTH_LOG_SECRETS !== \"true\" ? e.length < bo * 2 ? \"<redacted>\" : e.substring(0, bo) + \"<redacted>\" + e.substring(e.length - bo) : e;\n}\no(L, \"maybeRedact\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/tokens.js\nvar Nd = 1e3 * 60 * 60;\nasync function qs(e, t) {\n  let r = await En(F(\"JWT_PRIVATE_KEY\"), \"RS256\"), n = new Date(Date.now() + (t.jwt?.durationMs ?? Nd));\n  return await new mt({\n    sub: e.userId + xe + e.sessionId\n  }).setProtectedHeader({ alg: \"RS256\" }).setIssuedAt().setIssuer(F(\"CONVEX_SITE_URL\")).setAudience(\"convex\").setExpirationTime(n).sign(r);\n}\no(qs, \"generateToken\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/refreshTokens.js\nvar Wd = 1e3 * 60 * 60 * 24 * 30, zr = 10 * 1e3;\nasync function Xs(e, t, r, n) {\n  let i = Date.now() + (t.session?.inactiveDurationMs ?? Jr(process.env.AUTH_SESSION_INACTIVE_DURATION_MS) ?? Wd);\n  return await e.db.insert(\"authRefreshTokens\", {\n    sessionId: r,\n    expirationTime: i,\n    parentRefreshTokenId: n ?? void 0\n  });\n}\no(Xs, \"createRefreshToken\");\nvar Zs = /* @__PURE__ */ o((e, t) => `${e}${_o}${t}`, \"formatRefreshToken\"), jr = /* @__PURE__ */ o((e) => {\n  let [t, r] = e.split(_o);\n  if (!t || !r)\n    throw new Error(`Can't parse refresh token: ${L(e)}`);\n  return {\n    refreshTokenId: t,\n    sessionId: r\n  };\n}, \"parseRefreshToken\");\nasync function Qs(e, t) {\n  let r = [t], n = [t._id];\n  for (; n.length > 0; ) {\n    let i = [];\n    for (let s of n) {\n      let a = await e.db.query(\"authRefreshTokens\").withIndex(\"sessionIdAndParentRefreshTokenId\", (c) => c.eq(\"sessionId\", t.sessionId).eq(\"parentRefreshTokenId\", s)).collect();\n      r.push(...a), i.push(...a.map((c) => c._id));\n    }\n    n = i;\n  }\n  for (let i of r)\n    (i.firstUsedTime === void 0 || i.firstUsedTime > Date.now() - zr) && await e.db.patch(i._id, {\n      firstUsedTime: Date.now() - zr\n    });\n  return r;\n}\no(Qs, \"invalidateRefreshTokensInSubtree\");\nasync function Vr(e, t) {\n  let r = await e.db.query(\"authRefreshTokens\").withIndex(\"sessionIdAndParentRefreshTokenId\", (n) => n.eq(\"sessionId\", t)).collect();\n  for (let n of r)\n    await e.db.delete(n._id);\n}\no(Vr, \"deleteAllRefreshTokens\");\nasync function Ys(e, t, r) {\n  let n = await e.db.get(t);\n  if (n === null)\n    return g(v.ERROR, \"Invalid refresh token\"), null;\n  if (n.expirationTime < Date.now())\n    return g(v.ERROR, \"Expired refresh token\"), null;\n  if (n.sessionId !== r)\n    return g(v.ERROR, \"Invalid refresh token session ID\"), null;\n  let i = await e.db.get(n.sessionId);\n  return i === null ? (g(v.ERROR, \"Invalid refresh token session\"), null) : i.expirationTime < Date.now() ? (g(v.ERROR, \"Expired refresh token session\"), null) : { session: i, refreshTokenDoc: n };\n}\no(Ys, \"refreshTokenIfValid\");\nasync function ea(e, t) {\n  return e.db.query(\"authRefreshTokens\").withIndex(\"sessionId\", (r) => r.eq(\"sessionId\", t)).filter((r) => r.eq(r.field(\"firstUsedTime\"), void 0)).order(\"desc\").first();\n}\no(ea, \"loadActiveRefreshToken\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/sessions.js\nvar $d = 1e3 * 60 * 60 * 24 * 30;\nasync function Fr(e, t, r, n, i) {\n  return {\n    userId: r,\n    sessionId: n,\n    tokens: i ? await It(e, t, {\n      userId: r,\n      sessionId: n,\n      issuedRefreshTokenId: null,\n      parentRefreshTokenId: null\n    }) : null\n  };\n}\no(Fr, \"maybeGenerateTokensForSession\");\nasync function Gr(e, t, r) {\n  let n = await te(e);\n  if (n !== null) {\n    let i = await e.db.get(n);\n    i !== null && await Tt(e, i);\n  }\n  return await Bd(e, r, t);\n}\no(Gr, \"createNewAndDeleteExistingSession\");\nasync function It(e, t, r) {\n  let n = { userId: r.userId, sessionId: r.sessionId }, i = r.issuedRefreshTokenId ?? await Xs(e, t, r.sessionId, r.parentRefreshTokenId), s = {\n    token: await qs(n, t),\n    refreshToken: Zs(i, r.sessionId)\n  };\n  return g(v.DEBUG, `Generated token ${L(s.token)} and refresh token ${L(i)} for session ${L(r.sessionId)}`), s;\n}\no(It, \"generateTokensForSession\");\nasync function Bd(e, t, r) {\n  let n = Date.now() + (r.session?.totalDurationMs ?? Jr(process.env.AUTH_SESSION_TOTAL_DURATION_MS) ?? $d);\n  return await e.db.insert(\"authSessions\", { expirationTime: n, userId: t });\n}\no(Bd, \"createSession\");\nasync function Tt(e, t) {\n  await e.db.delete(t._id), await Vr(e, t._id);\n}\no(Tt, \"deleteSession\");\nasync function te(e) {\n  let t = await e.auth.getUserIdentity();\n  if (t === null)\n    return null;\n  let [, r] = t.subject.split(xe);\n  return r;\n}\no(te, \"getAuthSessionId\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/signIn.js\nvar ta = h.object({\n  userId: h.id(\"users\"),\n  sessionId: h.optional(h.id(\"authSessions\")),\n  generateTokens: h.boolean()\n});\nasync function ra(e, t, r) {\n  g(v.DEBUG, \"signInImpl args:\", t);\n  let { userId: n, sessionId: i, generateTokens: s } = t, a = i ?? await Gr(e, r, n);\n  return await Fr(e, r, n, a, s);\n}\no(ra, \"signInImpl\");\nvar So = /* @__PURE__ */ o(async (e, t) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"signIn\",\n    ...t\n  }\n}), \"callSignIn\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/signOut.js\nasync function na(e) {\n  let t = await te(e);\n  if (t !== null) {\n    let r = await e.db.get(t);\n    if (r !== null)\n      return await Tt(e, r), { userId: r.userId, sessionId: r._id };\n  }\n  return null;\n}\no(na, \"signOutImpl\");\nvar vo = /* @__PURE__ */ o(async (e) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"signOut\"\n  }\n}), \"callSignOut\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/refreshSession.js\nvar oa = h.object({\n  refreshToken: h.string()\n});\nasync function ia(e, t, r, n) {\n  let { refreshToken: i } = t, { refreshTokenId: s, sessionId: a } = jr(i);\n  g(\"DEBUG\", `refreshSessionImpl args: Token ID: ${L(s)} Session ID: ${L(a)}`);\n  let c = await Ys(e, s, a);\n  if (c === null) {\n    let p = await e.db.get(a);\n    return p !== null && await e.db.delete(p._id), await Vr(e, a), null;\n  }\n  let { session: d } = c, u = d._id, f = d.userId, l = c.refreshTokenDoc.firstUsedTime;\n  if (l === void 0) {\n    await e.db.patch(s, {\n      firstUsedTime: Date.now()\n    });\n    let p = await It(e, n, {\n      userId: f,\n      sessionId: u,\n      issuedRefreshTokenId: null,\n      parentRefreshTokenId: s\n    }), { refreshTokenId: m } = jr(p.refreshToken);\n    return g(\"DEBUG\", `Exchanged ${L(c.refreshTokenDoc._id)} (first use) for new refresh token ${L(m)}`), p;\n  }\n  let y = await ea(e, a);\n  if (g(\"DEBUG\", `Active refresh token: ${L(y?._id ?? \"(none)\")}, parent ${L(y?.parentRefreshTokenId ?? \"(none)\")}`), y !== null && y.parentRefreshTokenId === s)\n    return g(\"DEBUG\", `Token ${L(c.refreshTokenDoc._id)} is parent of active refresh token ${L(y._id)}, so returning that token`), await It(e, n, {\n      userId: f,\n      sessionId: u,\n      issuedRefreshTokenId: y._id,\n      parentRefreshTokenId: s\n    });\n  if (l + zr > Date.now()) {\n    let p = await It(e, n, {\n      userId: f,\n      sessionId: u,\n      issuedRefreshTokenId: null,\n      parentRefreshTokenId: s\n    }), { refreshTokenId: m } = jr(p.refreshToken);\n    return g(\"DEBUG\", `Exchanged ${L(c.refreshTokenDoc._id)} (reuse) for new refresh token ${L(m)}`), p;\n  } else {\n    g(\"ERROR\", \"Refresh token used outside of reuse window\"), g(\"DEBUG\", `Token ${L(c.refreshTokenDoc._id)} being used outside of reuse window, so invalidating all refresh tokens in subtree`);\n    let p = await Qs(e, c.refreshTokenDoc);\n    return g(\"DEBUG\", `Invalidated ${p.length} refresh tokens in subtree: ${p.map((m) => L(m._id)).join(\", \")}`), null;\n  }\n}\no(ia, \"refreshSessionImpl\");\nvar Ao = /* @__PURE__ */ o(async (e, t) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"refreshSession\",\n    ...t\n  }\n}), \"callRefreshSession\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/rateLimit.js\nasync function qr(e, t, r) {\n  let n = await sa(e, t, r);\n  return n === null ? !1 : n.attempsLeft < 1;\n}\no(qr, \"isSignInRateLimited\");\nasync function Xr(e, t, r) {\n  let n = await sa(e, t, r);\n  if (n !== null)\n    await e.db.patch(n.limit._id, {\n      attemptsLeft: n.attempsLeft - 1,\n      lastAttemptTime: Date.now()\n    });\n  else {\n    let i = aa(r);\n    await e.db.insert(\"authRateLimits\", {\n      identifier: t,\n      attemptsLeft: i - 1,\n      lastAttemptTime: Date.now()\n    });\n  }\n}\no(Xr, \"recordFailedSignIn\");\nasync function Zr(e, t) {\n  let r = await e.db.query(\"authRateLimits\").withIndex(\"identifier\", (n) => n.eq(\"identifier\", t)).unique();\n  r !== null && await e.db.delete(r._id);\n}\no(Zr, \"resetSignInRateLimit\");\nasync function sa(e, t, r) {\n  let n = Date.now(), i = aa(r), s = await e.db.query(\"authRateLimits\").withIndex(\"identifier\", (u) => u.eq(\"identifier\", t)).unique();\n  if (s === null)\n    return null;\n  let a = n - s.lastAttemptTime, c = i / (3600 * 1e3), d = Math.min(i, s.attemptsLeft + a * c);\n  return { limit: s, attempsLeft: d };\n}\no(sa, \"getRateLimitState\");\nfunction aa(e) {\n  return e.signIn?.maxFailedAttempsPerHour ?? 10;\n}\no(aa, \"configuredMaxAttempsPerHour\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/users.js\nasync function Se(e, t, r, n, i) {\n  let s = await Jd(e, t, \"existingAccount\" in r ? r.existingAccount : null, n, i), a = await jd(e, s, r, n);\n  return { userId: s, accountId: a };\n}\no(Se, \"upsertUserAndAccount\");\nasync function Jd(e, t, r, n, i) {\n  g(v.DEBUG, \"defaultCreateOrUpdateUser args:\", {\n    existingAccountId: r?._id,\n    existingSessionId: t,\n    args: n\n  });\n  let s = r?.userId ?? null;\n  if (i.callbacks?.createOrUpdateUser !== void 0)\n    return g(v.DEBUG, \"Using custom createOrUpdateUser callback\"), await i.callbacks.createOrUpdateUser(e, {\n      existingUserId: s,\n      ...n\n    });\n  let { provider: a, profile: { emailVerified: c, phoneVerified: d, ...u } } = n, f = c ?? ((a.type === \"oauth\" || a.type === \"oidc\") && a.allowDangerousEmailAccountLinking !== !1), l = d ?? !1, y = n.shouldLinkViaEmail || f || a.type === \"email\", p = n.shouldLinkViaPhone || l || a.type === \"phone\", m = s;\n  if (s === null) {\n    let b = typeof u.email == \"string\" && y ? (await Md(e, u.email))?._id ?? null : null, k = typeof u.phone == \"string\" && p ? (await zd(e, u.phone))?._id ?? null : null;\n    b !== null && k !== null ? (g(v.DEBUG, `Found existing email and phone verified users, so not linking: email: ${b}, phone: ${k}`), m = null) : b !== null ? (g(v.DEBUG, `Found existing email verified user, linking: ${b}`), m = b) : k !== null ? (g(v.DEBUG, `Found existing phone verified user, linking: ${k}`), m = k) : (g(v.DEBUG, \"No existing verified users found, creating new user\"), m = null);\n  }\n  let S = {\n    ...f ? { emailVerificationTime: Date.now() } : null,\n    ...l ? { phoneVerificationTime: Date.now() } : null,\n    ...u\n  }, I = m;\n  if (m !== null)\n    try {\n      await e.db.patch(m, S);\n    } catch (b) {\n      throw new Error(`Could not update user document with ID \\`${m}\\`, either the user has been deleted but their account has not, or the profile data doesn't match the \\`users\\` table schema: ${b.message}`);\n    }\n  else\n    m = await e.db.insert(\"users\", S);\n  let A = i.callbacks?.afterUserCreatedOrUpdated;\n  return A !== void 0 ? (g(v.DEBUG, \"Calling custom afterUserCreatedOrUpdated callback\"), await A(e, {\n    userId: m,\n    existingUserId: I,\n    ...n\n  })) : g(v.DEBUG, \"No custom afterUserCreatedOrUpdated callback, skipping\"), m;\n}\no(Jd, \"defaultCreateOrUpdateUser\");\nasync function Md(e, t) {\n  let r = await e.db.query(\"users\").withIndex(\"email\", (n) => n.eq(\"email\", t)).filter((n) => n.neq(n.field(\"emailVerificationTime\"), void 0)).take(2);\n  return r.length === 1 ? r[0] : null;\n}\no(Md, \"uniqueUserWithVerifiedEmail\");\nasync function zd(e, t) {\n  let r = await e.db.query(\"users\").withIndex(\"phone\", (n) => n.eq(\"phone\", t)).filter((n) => n.neq(n.field(\"phoneVerificationTime\"), void 0)).take(2);\n  return r.length === 1 ? r[0] : null;\n}\no(zd, \"uniqueUserWithVerifiedPhone\");\nasync function jd(e, t, r, n) {\n  let i = \"existingAccount\" in r ? r.existingAccount._id : await e.db.insert(\"authAccounts\", {\n    userId: t,\n    provider: n.provider.id,\n    providerAccountId: r.providerAccountId,\n    secret: r.secret\n  });\n  return \"existingAccount\" in r && r.existingAccount.userId !== t && await e.db.patch(i, { userId: t }), n.profile.emailVerified && await e.db.patch(i, { emailVerified: n.profile.email }), n.profile.phoneVerified && await e.db.patch(i, { phoneVerified: n.profile.phone }), i;\n}\no(jd, \"createOrUpdateAccount\");\nasync function ca(e, t) {\n  let r = await e.db.get(t);\n  if (r === null)\n    throw new Error(`Expected an account to exist for ID \"${t}\"`);\n  return r;\n}\no(ca, \"getAccountOrThrow\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/verifyCodeAndSignIn.js\nvar ua = h.object({\n  params: h.any(),\n  provider: h.optional(h.string()),\n  verifier: h.optional(h.string()),\n  generateTokens: h.boolean(),\n  allowExtraProviders: h.boolean()\n});\nasync function da(e, t, r, n) {\n  g(v.DEBUG, \"verifyCodeAndSignInImpl args:\", {\n    params: { email: t.params.email, phone: t.params.phone },\n    provider: t.provider,\n    verifier: t.verifier,\n    generateTokens: t.generateTokens,\n    allowExtraProviders: t.allowExtraProviders\n  });\n  let { generateTokens: i, provider: s, allowExtraProviders: a } = t, c = t.params.email ?? t.params.phone;\n  if (c !== void 0 && await qr(e, c, n))\n    return g(v.ERROR, \"Too many failed attempts to verify code for this email\"), null;\n  let d = await Vd(e, t, s ?? null, r, a, n, await te(e));\n  if (d === null)\n    return c !== void 0 && await Xr(e, c, n), null;\n  c !== void 0 && await Zr(e, c);\n  let { userId: u } = d, f = await Gr(e, n, u);\n  return await Fr(e, n, u, f, i);\n}\no(da, \"verifyCodeAndSignInImpl\");\nvar Rt = /* @__PURE__ */ o(async (e, t) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"verifyCodeAndSignIn\",\n    ...t\n  }\n}), \"callVerifyCodeAndSignIn\");\nasync function Vd(e, t, r, n, i, s, a) {\n  let { params: c, verifier: d } = t, u = await Ye(c.code), f = await e.db.query(\"authVerificationCodes\").withIndex(\"code\", (b) => b.eq(\"code\", u)).unique();\n  if (f === null)\n    return g(v.ERROR, \"Invalid verification code\"), null;\n  if (await e.db.delete(f._id), f.verifier !== d)\n    return g(v.ERROR, \"Invalid verifier\"), null;\n  if (f.expirationTime < Date.now())\n    return g(v.ERROR, \"Expired verification code\"), null;\n  let { accountId: l, emailVerified: y, phoneVerified: p } = f, m = await e.db.get(l);\n  if (m === null)\n    return g(v.ERROR, \"Account associated with this email has been deleted\"), null;\n  if (r !== null && f.provider !== r)\n    return g(v.ERROR, `Invalid provider \"${r}\" for given \\`code\\`, which was generated by provider \"${f.provider}\"`), null;\n  let S = n(f.provider, i);\n  S !== null && (S.type === \"email\" || S.type === \"phone\") && S.authorize !== void 0 && await S.authorize(t.params, m);\n  let I = m.userId, A = n(m.provider);\n  return A.type === \"oauth\" || A.type === \"oidc\" || ({ userId: I } = await Se(e, a, { existingAccount: m }, {\n    type: \"verification\",\n    provider: A,\n    profile: {\n      ...y !== void 0 ? { email: y, emailVerified: !0 } : {},\n      ...p !== void 0 ? { phone: p, phoneVerified: !0 } : {}\n    }\n  }, s)), { providerAccountId: m.providerAccountId, userId: I };\n}\no(Vd, \"verifyCodeOnly\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/verifierSignature.js\nvar la = h.object({\n  verifier: h.string(),\n  signature: h.string()\n});\nasync function fa(e, t) {\n  let { verifier: r, signature: n } = t, i = await e.db.get(r);\n  if (i === null)\n    throw new Error(\"Invalid verifier\");\n  return await e.db.patch(i._id, { signature: n });\n}\no(fa, \"verifierSignatureImpl\");\nvar Eo = /* @__PURE__ */ o(async (e, t) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"verifierSignature\",\n    ...t\n  }\n}), \"callVerifierSignature\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/userOAuth.js\nvar Fd = 1e3 * 60 * 2, pa = h.object({\n  provider: h.string(),\n  providerAccountId: h.string(),\n  profile: h.any(),\n  signature: h.string()\n});\nasync function ha(e, t, r, n) {\n  g(\"DEBUG\", \"userOAuthImpl args:\", t);\n  let { profile: i, provider: s, providerAccountId: a, signature: c } = t, d = r(s), u = await e.db.query(\"authAccounts\").withIndex(\"providerAndAccountId\", (m) => m.eq(\"provider\", s).eq(\"providerAccountId\", a)).unique(), f = await e.db.query(\"authVerifiers\").withIndex(\"signature\", (m) => m.eq(\"signature\", c)).unique();\n  if (f === null)\n    throw new Error(\"Invalid state\");\n  let { accountId: l } = await Se(e, f.sessionId ?? null, u !== null ? { existingAccount: u } : { providerAccountId: a }, { type: \"oauth\", provider: d, profile: i }, n), y = Mr(8, \"0123456789\");\n  await e.db.delete(f._id);\n  let p = await e.db.query(\"authVerificationCodes\").withIndex(\"accountId\", (m) => m.eq(\"accountId\", l)).unique();\n  return p !== null && await e.db.delete(p._id), await e.db.insert(\"authVerificationCodes\", {\n    code: await Ye(y),\n    accountId: l,\n    provider: s,\n    expirationTime: Date.now() + Fd,\n    // The use of a verifier means we don't need an identifier\n    // during verification.\n    verifier: f._id\n  }), y;\n}\no(ha, \"userOAuthImpl\");\nvar ko = /* @__PURE__ */ o(async (e, t) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"userOAuth\",\n    ...t\n  }\n}), \"callUserOAuth\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/createVerificationCode.js\nvar ma = h.object({\n  accountId: h.optional(h.id(\"authAccounts\")),\n  provider: h.string(),\n  email: h.optional(h.string()),\n  phone: h.optional(h.string()),\n  code: h.string(),\n  expirationTime: h.number(),\n  allowExtraProviders: h.boolean()\n});\nasync function ya(e, t, r, n) {\n  g(v.DEBUG, \"createVerificationCodeImpl args:\", t);\n  let { email: i, phone: s, code: a, expirationTime: c, provider: d, accountId: u, allowExtraProviders: f } = t, l = u !== void 0 ? await ca(e, u) : await e.db.query(\"authAccounts\").withIndex(\"providerAndAccountId\", (m) => m.eq(\"provider\", d).eq(\"providerAccountId\", i ?? s)).unique(), y = r(d, f), { accountId: p } = await Se(e, await te(e), l !== null ? { existingAccount: l } : { providerAccountId: i ?? s }, y.type === \"email\" ? { type: \"email\", provider: y, profile: { email: i } } : { type: \"phone\", provider: y, profile: { phone: s } }, n);\n  return await Gd(e, p, d, a, c, { email: i, phone: s }), i ?? s;\n}\no(ya, \"createVerificationCodeImpl\");\nvar Io = /* @__PURE__ */ o(async (e, t) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"createVerificationCode\",\n    ...t\n  }\n}), \"callCreateVerificationCode\");\nasync function Gd(e, t, r, n, i, { email: s, phone: a }) {\n  let c = await e.db.query(\"authVerificationCodes\").withIndex(\"accountId\", (d) => d.eq(\"accountId\", t)).unique();\n  c !== null && await e.db.delete(c._id), await e.db.insert(\"authVerificationCodes\", {\n    accountId: t,\n    provider: r,\n    code: await Ye(n),\n    expirationTime: i,\n    emailVerified: s,\n    phoneVerified: a\n  });\n}\no(Gd, \"generateUniqueVerificationCode\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/provider.js\nasync function Qr(e, t) {\n  if (e.type !== \"credentials\")\n    throw new Error(`Provider ${e.id} is not a credentials provider`);\n  let r = e.crypto?.hashSecret;\n  if (r === void 0)\n    throw new Error(`Provider ${e.id} does not have a \\`crypto.hashSecret\\` function`);\n  return await r(t);\n}\no(Qr, \"hash\");\nasync function Yr(e, t, r) {\n  if (e.type !== \"credentials\")\n    throw new Error(`Provider ${e.id} is not a credentials provider`);\n  let n = e.crypto?.verifySecret;\n  if (n === void 0)\n    throw new Error(`Provider ${e.id} does not have a \\`crypto.verifySecret\\` function`);\n  return await n(t, r);\n}\no(Yr, \"verify\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/createAccountFromCredentials.js\nvar ga = h.object({\n  provider: h.string(),\n  account: h.object({ id: h.string(), secret: h.optional(h.string()) }),\n  profile: h.any(),\n  shouldLinkViaEmail: h.optional(h.boolean()),\n  shouldLinkViaPhone: h.optional(h.boolean())\n});\nasync function ba(e, t, r, n) {\n  g(v.DEBUG, \"createAccountFromCredentialsImpl args:\", {\n    provider: t.provider,\n    account: {\n      id: t.account.id,\n      secret: L(t.account.secret ?? \"\")\n    }\n  });\n  let { provider: i, account: s, profile: a, shouldLinkViaEmail: c, shouldLinkViaPhone: d } = t, u = r(i), f = await e.db.query(\"authAccounts\").withIndex(\"providerAndAccountId\", (m) => m.eq(\"provider\", u.id).eq(\"providerAccountId\", s.id)).unique();\n  if (f !== null) {\n    if (s.secret !== void 0 && !await Yr(u, s.secret, f.secret ?? \"\"))\n      throw new Error(`Account ${s.id} already exists`);\n    return {\n      account: f,\n      // TODO: Ian removed this,\n      user: await e.db.get(f.userId)\n    };\n  }\n  let l = s.secret !== void 0 ? await Qr(u, s.secret) : void 0, { userId: y, accountId: p } = await Se(e, await te(e), { providerAccountId: s.id, secret: l }, {\n    type: \"credentials\",\n    provider: u,\n    profile: a,\n    shouldLinkViaEmail: c,\n    shouldLinkViaPhone: d\n  }, n);\n  return {\n    account: await e.db.get(p),\n    user: await e.db.get(y)\n  };\n}\no(ba, \"createAccountFromCredentialsImpl\");\nvar To = /* @__PURE__ */ o(async (e, t) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"createAccountFromCredentials\",\n    ...t\n  }\n}), \"callCreateAccountFromCredentials\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/retrieveAccountWithCredentials.js\nvar _a = h.object({\n  provider: h.string(),\n  account: h.object({ id: h.string(), secret: h.optional(h.string()) })\n});\nasync function xa(e, t, r, n) {\n  let { provider: i, account: s } = t;\n  g(v.DEBUG, \"retrieveAccountWithCredentialsImpl args:\", {\n    provider: i,\n    account: {\n      id: s.id,\n      secret: L(s.secret ?? \"\")\n    }\n  });\n  let a = await e.db.query(\"authAccounts\").withIndex(\"providerAndAccountId\", (c) => c.eq(\"provider\", i).eq(\"providerAccountId\", s.id)).unique();\n  if (a === null)\n    return \"InvalidAccountId\";\n  if (s.secret !== void 0) {\n    if (await qr(e, a._id, n))\n      return \"TooManyFailedAttempts\";\n    if (!await Yr(r(i), s.secret, a.secret ?? \"\"))\n      return await Xr(e, a._id, n), \"InvalidSecret\";\n    await Zr(e, a._id);\n  }\n  return {\n    account: a,\n    // TODO: Ian removed this\n    user: await e.db.get(a.userId)\n  };\n}\no(xa, \"retrieveAccountWithCredentialsImpl\");\nvar Ro = /* @__PURE__ */ o(async (e, t) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"retrieveAccountWithCredentials\",\n    ...t\n  }\n}), \"callRetreiveAccountWithCredentials\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/modifyAccount.js\nvar Sa = h.object({\n  provider: h.string(),\n  account: h.object({ id: h.string(), secret: h.string() })\n});\nasync function va(e, t, r) {\n  let { provider: n, account: i } = t;\n  g(v.DEBUG, \"retrieveAccountWithCredentialsImpl args:\", {\n    provider: n,\n    account: {\n      id: i.id,\n      secret: L(i.secret ?? \"\")\n    }\n  });\n  let s = await e.db.query(\"authAccounts\").withIndex(\"providerAndAccountId\", (a) => a.eq(\"provider\", n).eq(\"providerAccountId\", i.id)).unique();\n  if (s === null)\n    throw new Error(`Cannot modify account with ID ${i.id} because it does not exist`);\n  await e.db.patch(s._id, {\n    secret: await Qr(r(n), i.secret)\n  });\n}\no(va, \"modifyAccountImpl\");\nvar Co = /* @__PURE__ */ o(async (e, t) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"modifyAccount\",\n    ...t\n  }\n}), \"callModifyAccount\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/invalidateSessions.js\nvar Aa = h.object({\n  userId: h.id(\"users\"),\n  except: h.optional(h.array(h.id(\"authSessions\")))\n}), Po = /* @__PURE__ */ o(async (e, t) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"invalidateSessions\",\n    ...t\n  }\n}), \"callInvalidateSessions\"), Ea = /* @__PURE__ */ o(async (e, t) => {\n  g(v.DEBUG, \"invalidateSessionsImpl args:\", t);\n  let { userId: r, except: n } = t, i = new Set(n ?? []), s = await e.db.query(\"authSessions\").withIndex(\"userId\", (a) => a.eq(\"userId\", r)).collect();\n  for (let a of s)\n    i.has(a._id) || await Tt(e, a);\n}, \"invalidateSessionsImpl\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/verifier.js\nasync function ka(e) {\n  return await e.db.insert(\"authVerifiers\", {\n    sessionId: await te(e) ?? void 0\n  });\n}\no(ka, \"verifierImpl\");\nvar Uo = /* @__PURE__ */ o(async (e) => e.runMutation(\"auth:store\", {\n  args: {\n    type: \"verifier\"\n  }\n}), \"callVerifier\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/mutations/index.js\nvar Ia = h.object({\n  args: h.union(h.object({\n    type: h.literal(\"signIn\"),\n    ...ta.fields\n  }), h.object({\n    type: h.literal(\"signOut\")\n  }), h.object({\n    type: h.literal(\"refreshSession\"),\n    ...oa.fields\n  }), h.object({\n    type: h.literal(\"verifyCodeAndSignIn\"),\n    ...ua.fields\n  }), h.object({\n    type: h.literal(\"verifier\")\n  }), h.object({\n    type: h.literal(\"verifierSignature\"),\n    ...la.fields\n  }), h.object({\n    type: h.literal(\"userOAuth\"),\n    ...pa.fields\n  }), h.object({\n    type: h.literal(\"createVerificationCode\"),\n    ...ma.fields\n  }), h.object({\n    type: h.literal(\"createAccountFromCredentials\"),\n    ...ga.fields\n  }), h.object({\n    type: h.literal(\"retrieveAccountWithCredentials\"),\n    ..._a.fields\n  }), h.object({\n    type: h.literal(\"modifyAccount\"),\n    ...Sa.fields\n  }), h.object({\n    type: h.literal(\"invalidateSessions\"),\n    ...Aa.fields\n  }))\n}), Ta = /* @__PURE__ */ o(async (e, t, r, n) => {\n  let i = t.args;\n  switch (g(v.INFO, `\\`auth:store\\` type: ${i.type}`), i.type) {\n    case \"signIn\":\n      return ra(e, i, n);\n    case \"signOut\":\n      return na(e);\n    case \"refreshSession\":\n      return ia(e, i, r, n);\n    case \"verifyCodeAndSignIn\":\n      return da(e, i, r, n);\n    case \"verifier\":\n      return ka(e);\n    case \"verifierSignature\":\n      return fa(e, i);\n    case \"userOAuth\":\n      return ha(e, i, r, n);\n    case \"createVerificationCode\":\n      return ya(e, i, r, n);\n    case \"createAccountFromCredentials\":\n      return ba(e, i, r, n);\n    case \"retrieveAccountWithCredentials\":\n      return xa(e, i, r, n);\n    case \"modifyAccount\":\n      return va(e, i, r);\n    case \"invalidateSessions\":\n      return Ea(e, i);\n    default:\n  }\n}, \"storeImpl\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/redirects.js\nasync function en(e, t) {\n  if (t.redirectTo !== void 0) {\n    if (typeof t.redirectTo != \"string\")\n      throw new Error(`Expected \\`redirectTo\\` to be a string, got ${t.redirectTo}`);\n    return await (e.callbacks?.redirect ?? qd)(t);\n  }\n  return Ra();\n}\no(en, \"redirectAbsoluteUrl\");\nasync function qd({ redirectTo: e }) {\n  let t = Ra();\n  if (e.startsWith(\"?\") || e.startsWith(\"/\"))\n    return `${t}${e}`;\n  if (e.startsWith(t)) {\n    let r = e[t.length];\n    if (r === void 0 || r === \"?\" || r === \"/\")\n      return e;\n  }\n  throw new Error(`Invalid \\`redirectTo\\` ${e} for configured SITE_URL: ${t.toString()}`);\n}\no(qd, \"defaultRedirectCallback\");\nfunction tn(e, t, r) {\n  let n = /([^:]+):(.*)/, [, i, s] = e.match(n), a = /^\\/\\/(?:\\/|$|\\?)/.test(s), c = a && s.startsWith(\"///\"), d = new URL(`http:${a ? \"//googblibok\" + s.slice(2) : s}`);\n  d.searchParams.set(t, r);\n  let [, , u] = d.toString().match(n);\n  return `${i}:${a ? (c ? \"/\" : \"\") + \"//\" + u.slice(13) : u}`;\n}\no(tn, \"setURLSearchParam\");\nfunction Ra() {\n  return F(\"SITE_URL\").replace(/\\/$/, \"\");\n}\no(Ra, \"siteUrl\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/signIn.js\nvar Xd = 3600 * 24;\nasync function Oo(e, t, r, n) {\n  if (t === null && r.refreshToken)\n    return { kind: \"refreshTokens\", signedIn: { tokens: await Ao(e, {\n      refreshToken: r.refreshToken\n    }) } };\n  if (t === null && r.params?.code !== void 0)\n    return {\n      kind: \"signedIn\",\n      signedIn: await Rt(e, {\n        params: r.params,\n        verifier: r.verifier,\n        generateTokens: !0,\n        allowExtraProviders: n.allowExtraProviders\n      })\n    };\n  if (t === null)\n    throw new Error(\"Cannot sign in: Missing `provider`, `params.code` or `refreshToken`\");\n  if (t.type === \"email\" || t.type === \"phone\")\n    return Zd(e, t, r, n);\n  if (t.type === \"credentials\")\n    return Qd(e, t, r, n);\n  if (t.type === \"oauth\" || t.type === \"oidc\")\n    return Yd(e, t, r, n);\n  let i = t;\n  throw new Error(`Provider type ${t.type} is not supported yet`);\n}\no(Oo, \"signInImpl\");\nasync function Zd(e, t, r, n) {\n  if (r.params?.code !== void 0) {\n    let f = await Rt(e, {\n      params: r.params,\n      provider: t.id,\n      generateTokens: n.generateTokens,\n      allowExtraProviders: n.allowExtraProviders\n    });\n    if (f === null)\n      throw new Error(\"Could not verify code\");\n    return {\n      kind: \"signedIn\",\n      signedIn: f\n    };\n  }\n  let s = t.generateVerificationToken ? await t.generateVerificationToken() : Mr(32, \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"), a = Date.now() + (t.maxAge ?? Xd) * 1e3, c = await Io(e, {\n    provider: t.id,\n    accountId: r.accountId,\n    email: r.params?.email,\n    phone: r.params?.phone,\n    code: s,\n    expirationTime: a,\n    allowExtraProviders: n.allowExtraProviders\n  }), d = await en(e.auth.config, r.params ?? {}), u = {\n    identifier: c,\n    url: tn(d, \"code\", s),\n    token: s,\n    expires: new Date(a)\n  };\n  return t.type === \"email\" ? await t.sendVerificationRequest(\n    {\n      ...u,\n      provider: {\n        ...t,\n        from: (\n          // Simplifies demo configuration of Resend\n          t.from === \"Auth.js <no-reply@authjs.dev>\" && t.id === \"resend\" ? \"My App <onboarding@resend.dev>\" : t.from\n        )\n      },\n      request: new Request(\"http://localhost\"),\n      // TODO: Document\n      theme: e.auth.config.theme\n    },\n    // @ts-expect-error Figure out typing for email providers so they can\n    // access ctx.\n    e\n  ) : t.type === \"phone\" && await t.sendVerificationRequest({ ...u, provider: t }, e), { kind: \"started\", started: !0 };\n}\no(Zd, \"handleEmailAndPhoneProvider\");\nasync function Qd(e, t, r, n) {\n  let i = await t.authorize(r.params ?? {}, e);\n  return i === null ? { kind: \"signedIn\", signedIn: null } : {\n    kind: \"signedIn\",\n    signedIn: await So(e, {\n      userId: i.userId,\n      sessionId: i.sessionId,\n      generateTokens: n.generateTokens\n    })\n  };\n}\no(Qd, \"handleCredentials\");\nasync function Yd(e, t, r, n) {\n  if (r.params?.code !== void 0)\n    return {\n      kind: \"signedIn\",\n      signedIn: await Rt(e, {\n        params: r.params,\n        verifier: r.verifier,\n        generateTokens: !0,\n        allowExtraProviders: n.allowExtraProviders\n      })\n    };\n  let i = new URL((process.env.CUSTOM_AUTH_SITE_URL ?? F(\"CONVEX_SITE_URL\")) + `/api/auth/signin/${t.id}`), s = await Uo(e);\n  if (i.searchParams.set(\"code\", s), r.params?.redirectTo !== void 0) {\n    if (typeof r.params.redirectTo != \"string\")\n      throw new Error(`Expected \\`redirectTo\\` to be a string, got ${r.params.redirectTo}`);\n    i.searchParams.set(\"redirectTo\", r.params.redirectTo);\n  }\n  return { kind: \"redirect\", redirect: i.toString(), verifier: s };\n}\no(Yd, \"handleOAuthProvider\");\n\n// node_modules/@convex-dev/auth/dist/server/oauth/checks.js\nvar Ca = 900;\nasync function Lo(e, t, r) {\n  let { cookies: n } = r, i = n[e], s = /* @__PURE__ */ new Date();\n  s.setTime(s.getTime() + Ca * 1e3), g(\"DEBUG\", `CREATE_${e.toUpperCase()}`, {\n    name: i.name,\n    payload: t,\n    COOKIE_TTL: Ca,\n    expires: s\n  });\n  let a = { ...i.options, expires: s };\n  return { name: i.name, value: t, options: a };\n}\no(Lo, \"createCookie\");\nfunction el(e, t, r) {\n  let { cookies: n } = t, i = n[e];\n  g(\"DEBUG\", `CLEAR_${e.toUpperCase()}`, { cookie: i }), r.push({\n    name: i.name,\n    value: \"\",\n    options: { ...n[e].options, maxAge: 0 }\n  });\n}\no(el, \"clearCookie\");\nfunction Ho(e, t) {\n  return async function(r, n, i) {\n    let { provider: s } = i;\n    if (!s?.checks?.includes(e))\n      return;\n    let a = r?.[i.cookies[t].name];\n    return g(\"DEBUG\", `USE_${t.toUpperCase()}`, { value: a }), el(t, i, n), a;\n  };\n}\no(Ho, \"useCookie\");\nvar rn = {\n  /** Creates a PKCE code challenge and verifier pair. The verifier is stored in the cookie. */\n  async create(e) {\n    let t = Pr(), r = await Lr(t);\n    return { cookie: await Lo(\"pkceCodeVerifier\", t, e), codeChallenge: r, codeVerifier: t };\n  },\n  /**\n   * Returns code_verifier if the provider is configured to use PKCE,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the code_verifier is missing or invalid.\n   */\n  use: Ho(\"pkce\", \"pkceCodeVerifier\")\n}, nn = {\n  /** Creates a state cookie with an optionally encoded body. */\n  async create(e, t) {\n    let { provider: r } = e;\n    if (!r.checks.includes(\"state\")) {\n      if (t)\n        throw new Error(\"State data was provided but the provider is not configured to use state\");\n      return;\n    }\n    let n = Ur();\n    return { cookie: await Lo(\"state\", n, e), value: n };\n  },\n  /**\n   * Returns state if the provider is configured to use state,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the state is missing or invalid.\n   */\n  use: Ho(\"state\", \"state\")\n}, on = {\n  async create(e) {\n    if (!e.provider.checks.includes(\"nonce\"))\n      return;\n    let t = Or();\n    return { cookie: await Lo(\"nonce\", t, e), value: t };\n  },\n  /**\n   * Returns nonce if the provider is configured to use nonce,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the nonce is missing or invalid.\n   * @see https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes\n   * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#nonce\n   */\n  use: Ho(\"nonce\", \"nonce\")\n};\n\n// node_modules/@convex-dev/auth/dist/server/oauth/lib/utils/customFetch.js\nfunction et(e) {\n  return { [_e]: e[we] ?? fetch };\n}\no(et, \"fetchOpt\");\n\n// node_modules/@convex-dev/auth/dist/server/oauth/convexAuth.js\nfunction sn(e) {\n  return (process.env.CUSTOM_AUTH_SITE_URL ?? F(\"CONVEX_SITE_URL\")) + \"/api/auth/callback/\" + e;\n}\no(sn, \"callbackUrl\");\nfunction an({ codeVerifier: e, state: t, nonce: r }) {\n  return [e, t, r].filter((n) => n !== void 0).join(\" \");\n}\no(an, \"getAuthorizationSignature\");\nfunction Do(e, t) {\n  return (Ut(process.env.CONVEX_SITE_URL) ? \"\" : \"__Host-\") + t + \"OAuth\" + e;\n}\no(Do, \"oauthStateCookieName\");\nvar Ko = /* @__PURE__ */ o((e) => ({\n  pkceCodeVerifier: {\n    name: Do(\"pkce\", e),\n    options: {\n      ...oe\n    }\n  },\n  state: {\n    name: Do(\"state\", e),\n    options: {\n      ...oe\n    }\n  },\n  nonce: {\n    name: Do(\"nonce\", e),\n    options: {\n      ...oe\n    }\n  },\n  // ConvexAuth: We don't support webauthn, so this value doesn't actually matter\n  webauthnChallenge: {\n    name: \"ConvexAuth_shouldNotBeUsed_webauthnChallenge\",\n    options: {\n      ...oe\n    }\n  },\n  // ConvexAuth: We don't use these cookies, so their values should never be used\n  sessionToken: {\n    name: \"ConvexAuth_shouldNotBeUsed_sessionToken\",\n    options: {\n      ...oe\n    }\n  },\n  callbackUrl: {\n    name: \"ConvexAuth_shouldNotBeUsed_callbackUrl\",\n    options: {\n      ...oe\n    }\n  },\n  csrfToken: {\n    name: \"ConvexAuth_shouldNotBeUsed_csrfToken\",\n    options: {\n      ...oe\n    }\n  }\n}), \"defaultCookiesOptions\");\nasync function No(e) {\n  if (!e.authorization || !e.token || !e.userinfo) {\n    if (!e.issuer)\n      throw new Error(`Provider \\`${e.id}\\` is missing an \\`issuer\\` URL configuration. Consult the provider docs.`);\n    let i = new URL(e.issuer), s = await ls(i, {\n      ...et(e),\n      [le]: !0\n    }), a = await fs(i, s);\n    if (!a.token_endpoint)\n      throw new TypeError(\"TODO: Authorization server did not provide a token endpoint.\");\n    let c = a;\n    return {\n      ...e,\n      checks: e.checks,\n      profile: e.profile,\n      account: e.account,\n      clientId: e.clientId,\n      idToken: e.type === \"oidc\" ? e.idToken : void 0,\n      // ConvexAuth: Apparently it's important for us to normalize the endpoint after\n      // service discovery (https://github.com/get-convex/convex-auth/commit/35bf716bfb0d29dbce1cbca318973b0732f75015)\n      authorization: Le({\n        ...e.authorization,\n        url: c.authorization_endpoint\n      }),\n      token: Le({\n        ...e.token,\n        url: c.token_endpoint\n      }),\n      userinfo: c.userinfo_endpoint ? Le({\n        ...e.userinfo,\n        url: c.userinfo_endpoint\n      }) : e.userinfo,\n      as: c,\n      configSource: \"discovered\"\n    };\n  }\n  let t = Le(e.authorization), r = Le(e.token), n = e.userinfo ? Le(e.userinfo) : void 0;\n  return {\n    ...e,\n    checks: e.checks,\n    profile: e.profile,\n    account: e.account,\n    clientId: e.clientId,\n    idToken: e.type === \"oidc\" ? e.idToken : void 0,\n    authorization: t,\n    token: r,\n    userinfo: n,\n    as: {\n      issuer: e.issuer ?? \"theremustbeastringhere.dev\",\n      authorization_endpoint: t?.url.toString(),\n      token_endpoint: r?.url.toString(),\n      userinfo_endpoint: n?.url.toString()\n    },\n    configSource: \"provided\"\n  };\n}\no(No, \"oAuthConfigToInternalProvider\");\n\n// node_modules/@convex-dev/auth/dist/server/oauth/authorizationUrl.js\nasync function Ua(e) {\n  let { provider: t } = e, r = t.authorization?.url, { as: n, authorization: i, configSource: s } = t;\n  if (!i)\n    throw new TypeError(\"Could not determine the authorization endpoint.\");\n  r || (r = new URL(i.url));\n  let a = r.searchParams, c = sn(t.id), d = Object.assign({\n    response_type: \"code\",\n    // clientId can technically be undefined, should we check this in assert.ts or rely on the Authorization Server to do it?\n    client_id: t.clientId,\n    redirect_uri: c,\n    // @ts-expect-error TODO:\n    ...t.authorization?.params\n  }, Object.fromEntries(r.searchParams.entries() ?? []));\n  for (let m in d)\n    a.set(m, d[m]);\n  let u = [], f = await nn.create(e);\n  f && (a.set(\"state\", f.value), u.push(f.cookie));\n  let l;\n  if (t.checks?.includes(\"pkce\"))\n    if (s === \"discovered\" && !n.code_challenge_methods_supported?.includes(\"S256\"))\n      t.type === \"oidc\" && (t.checks = [\"nonce\"]);\n    else {\n      let m = await rn.create(e);\n      a.set(\"code_challenge\", m.codeChallenge), a.set(\"code_challenge_method\", \"S256\"), u.push(m.cookie), l = m.codeVerifier;\n    }\n  let y = await on.create(e);\n  y && (a.set(\"nonce\", y.value), u.push(y.cookie)), t.type === \"oidc\" && !r.searchParams.has(\"scope\") && r.searchParams.set(\"scope\", \"openid profile email\"), g(\"DEBUG\", \"authorization url is ready\", {\n    url: r,\n    cookies: u,\n    provider: t\n  });\n  let p = an({\n    codeVerifier: l,\n    state: a.get(\"state\") ?? void 0,\n    nonce: a.get(\"nonce\") ?? void 0\n  });\n  return { redirect: r.toString(), cookies: u, signature: p };\n}\no(Ua, \"getAuthorizationUrl\");\n\n// node_modules/@convex-dev/auth/dist/server/oauth/lib/utils/providers.js\nfunction Oa(e) {\n  return e.type === \"oidc\";\n}\no(Oa, \"isOIDCProvider\");\n\n// node_modules/@convex-dev/auth/dist/server/oauth/callback.js\nfunction La(e) {\n  return encodeURIComponent(e).replace(/%20/g, \"+\");\n}\no(La, \"formUrlEncode\");\nfunction tl(e, t) {\n  let r = La(e), n = La(t);\n  return `Basic ${btoa(`${r}:${n}`)}`;\n}\no(tl, \"clientSecretBasic\");\nasync function Ha(e, t, r) {\n  let { provider: n } = r, { userinfo: i, as: s } = n, a = {\n    client_id: n.clientId,\n    ...n.client\n  }, c;\n  switch (a.token_endpoint_auth_method) {\n    // TODO: in the next breaking major version have undefined be `client_secret_post`\n    case void 0:\n    case \"client_secret_basic\":\n      c = /* @__PURE__ */ o((k, P, Z, V) => {\n        V.set(\"authorization\", tl(n.clientId, n.clientSecret));\n      }, \"clientAuth\");\n      break;\n    case \"client_secret_post\":\n      c = hs(n.clientSecret);\n      break;\n    case \"client_secret_jwt\":\n      c = ws(n.clientSecret);\n      break;\n    case \"private_key_jwt\":\n      c = ys(n.token.clientPrivateKey, {\n        // TODO: review in the next breaking change\n        [Tr](k, P) {\n          P.aud = [s.issuer, s.token_endpoint];\n        }\n      });\n      break;\n    default:\n      throw new Error(\"unsupported client authentication method\");\n  }\n  let d = [], u = await nn.use(t, d, r), f;\n  try {\n    f = Os(s, a, new URLSearchParams(e), n.checks.includes(\"state\") ? u : oo);\n  } catch (k) {\n    if (k instanceof St) {\n      let P = {\n        providerId: n.id,\n        ...Object.fromEntries(k.cause.entries())\n      };\n      throw g(\"DEBUG\", \"OAuthCallbackError\", P), new Error(\"OAuth Provider returned an error\", { cause: P });\n    }\n    throw k;\n  }\n  let l = await rn.use(t, d, r), y = sn(n.id), p = await Ts(s, a, c, f, y, l ?? \"decoy\", {\n    // TODO: move away from allowing insecure HTTP requests\n    [le]: !0,\n    [_e]: (...k) => (n.checks.includes(\"pkce\") || k[1].body.delete(\"code_verifier\"), et(n)[_e](...k))\n  });\n  n.token?.conform && (p = await n.token.conform(p.clone()) ?? p);\n  let m = {}, S = await on.use(t, d, r), I = Oa(n), A = await Rs(s, a, p, {\n    expectedNonce: S,\n    requireIdToken: I\n  }), b = A;\n  if (I) {\n    let k = Kr(A);\n    if (k === void 0)\n      throw new Error(\"ID Token claims are missing\");\n    let P = k;\n    if (m = P, n.id === \"apple\")\n      try {\n        m.user = JSON.parse(e?.user);\n      } catch {\n      }\n    if (n.idToken === !1) {\n      let Z = await to(s, a, A.access_token, {\n        ...et(n),\n        // TODO: move away from allowing insecure HTTP requests\n        [le]: !0\n      });\n      m = await xs(s, a, P.sub, Z);\n    }\n  } else if (i?.request) {\n    let k = await i.request({ tokens: b, provider: n });\n    k instanceof Object && (m = k);\n  } else if (i?.url)\n    m = await (await to(s, a, A.access_token, et(n))).json();\n  else\n    throw new TypeError(\"No userinfo endpoint configured\");\n  return b.expires_in && (b.expires_at = Math.floor(Date.now() / 1e3) + Number(b.expires_in)), {\n    profile: m,\n    tokens: b,\n    cookies: d,\n    signature: an({ codeVerifier: l, state: u, nonce: S })\n  };\n}\no(Ha, \"handleOAuth\");\n\n// node_modules/@convex-dev/auth/dist/server/implementation/index.js\nfunction rl(e) {\n  let t = Ns(e), r = t.providers.some((c) => c.type === \"oauth\" || c.type === \"oidc\"), n = /* @__PURE__ */ o((c, d = !1) => t.providers.find((u) => u.id === c) ?? (d ? t.extraProviders.find((u) => u.id === c) : void 0), \"getProvider\"), i = /* @__PURE__ */ o((c, d = !1) => {\n    let u = n(c, d);\n    if (u === void 0) {\n      let f = `Provider \\`${c}\\` is not configured, available providers are ${Bs(t, d)}.`;\n      throw g(v.ERROR, f), new Error(f);\n    }\n    return u;\n  }, \"getProviderOrThrow\"), s = /* @__PURE__ */ o((c) => ({ ...c, auth: { ...c.auth, config: t } }), \"enrichCtx\");\n  return {\n    /**\n     * Helper for configuring HTTP actions.\n     */\n    auth: {\n      /**\n       * @deprecated - Use `getAuthUserId` from \"@convex-dev/auth/server\":\n       *\n       * ```ts\n       * import { getAuthUserId } from \"@convex-dev/auth/server\";\n       * ```\n       *\n       * @hidden\n       */\n      getUserId: /* @__PURE__ */ o(async (c) => {\n        let d = await c.auth.getUserIdentity();\n        if (d === null)\n          return null;\n        let [u] = d.subject.split(xe);\n        return u;\n      }, \"getUserId\"),\n      /**\n       * @deprecated - Use `getAuthSessionId` from \"@convex-dev/auth/server\":\n       *\n       * ```\n       * import { getAuthSessionId } from \"@convex-dev/auth/server\";\n       * ```\n       *\n       * @hidden\n       */\n      getSessionId: /* @__PURE__ */ o(async (c) => {\n        let d = await c.auth.getUserIdentity();\n        if (d === null)\n          return null;\n        let [, u] = d.subject.split(xe);\n        return u;\n      }, \"getSessionId\"),\n      /**\n       * Add HTTP actions for JWT verification and OAuth sign-in.\n       *\n       * ```ts\n       * import { httpRouter } from \"convex/server\";\n       * import { auth } from \"./auth.js\";\n       *\n       * const http = httpRouter();\n       *\n       * auth.addHttpRoutes(http);\n       *\n       * export default http;\n       * ```\n       *\n       * The following routes are handled always:\n       *\n       * - `/.well-known/openid-configuration`\n       * - `/.well-known/jwks.json`\n       *\n       * The following routes are handled if OAuth is configured:\n       *\n       * - `/api/auth/signin/*`\n       * - `/api/auth/callback/*`\n       *\n       * @param http your HTTP router\n       */\n      addHttpRoutes: /* @__PURE__ */ o((c) => {\n        if (c.route({\n          path: \"/.well-known/openid-configuration\",\n          method: \"GET\",\n          handler: rt(async () => new Response(JSON.stringify({\n            issuer: F(\"CONVEX_SITE_URL\"),\n            jwks_uri: F(\"CONVEX_SITE_URL\") + \"/.well-known/jwks.json\",\n            authorization_endpoint: F(\"CONVEX_SITE_URL\") + \"/oauth/authorize\"\n          }), {\n            status: 200,\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"Cache-Control\": \"public, max-age=15, stale-while-revalidate=15, stale-if-error=86400\"\n            }\n          }))\n        }), c.route({\n          path: \"/.well-known/jwks.json\",\n          method: \"GET\",\n          handler: rt(async () => new Response(F(\"JWKS\"), {\n            status: 200,\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"Cache-Control\": \"public, max-age=15, stale-while-revalidate=15, stale-if-error=86400\"\n            }\n          }))\n        }), r) {\n          c.route({\n            pathPrefix: \"/api/auth/signin/\",\n            method: \"GET\",\n            handler: rt(ul(400, async (u, f) => {\n              let l = new URL(f.url), p = l.pathname.split(\"/\").at(-1);\n              if (p === null)\n                throw new Error(\"Missing provider id\");\n              let m = l.searchParams.get(\"code\");\n              if (m === null)\n                throw new Error(\"Missing sign-in verifier\");\n              let S = i(p), { redirect: I, cookies: A, signature: b } = await Ua({\n                provider: await No(S),\n                cookies: Ko(p)\n              });\n              await Eo(u, {\n                verifier: m,\n                signature: b\n              });\n              let k = l.searchParams.get(\"redirectTo\");\n              k !== null && A.push(Go(p, k));\n              let P = new Headers({ Location: I });\n              for (let { name: Z, value: V, options: ve } of A)\n                P.append(\"Set-Cookie\", (0, cn.serialize)(Z, V, ve));\n              return new Response(null, { status: 302, headers: P });\n            }))\n          });\n          let d = rt(async (u, f) => {\n            let l = u, y = new URL(f.url), m = y.pathname.split(\"/\").at(-1);\n            g(v.DEBUG, \"Handling OAuth callback for provider:\", m);\n            let S = i(m), I = dl(f), A = qo(S.id, I), b = await en(t, {\n              redirectTo: A?.redirectTo\n            }), k = y.searchParams;\n            if (f.headers.get(\"Content-Type\") === \"application/x-www-form-urlencoded\") {\n              let P = await f.formData();\n              for (let [Z, V] of P.entries())\n                typeof V == \"string\" && k.append(Z, V);\n            }\n            try {\n              let { profile: P, tokens: Z, signature: V } = await Ha(Object.fromEntries(k.entries()), I, {\n                provider: await No(S),\n                cookies: Ko(S.id)\n              }), { id: ve, ...He } = await S.profile(P, Z);\n              if (typeof ve != \"string\")\n                throw new Error(`The profile method of the ${m} config must return a string ID`);\n              let tt = await ko(l, {\n                provider: m,\n                providerAccountId: ve,\n                profile: He,\n                signature: V\n              });\n              return new Response(null, {\n                status: 302,\n                headers: {\n                  Location: tn(b, \"code\", tt),\n                  \"Cache-Control\": \"must-revalidate\"\n                }\n              });\n            } catch (P) {\n              return xo(P), Response.redirect(b);\n            }\n          });\n          c.route({\n            pathPrefix: \"/api/auth/callback/\",\n            method: \"GET\",\n            handler: d\n          }), c.route({\n            pathPrefix: \"/api/auth/callback/\",\n            method: \"POST\",\n            handler: d\n          });\n        }\n      }, \"addHttpRoutes\")\n    },\n    /**\n     * Action called by the client to sign the user in.\n     *\n     * Also used for refreshing the session.\n     */\n    signIn: un({\n      args: {\n        provider: h.optional(h.string()),\n        params: h.optional(h.any()),\n        verifier: h.optional(h.string()),\n        refreshToken: h.optional(h.string()),\n        calledBy: h.optional(h.string())\n      },\n      handler: /* @__PURE__ */ o(async (c, d) => {\n        d.calledBy !== void 0 && g(\"INFO\", `\\`auth:signIn\\` called by ${d.calledBy}`);\n        let u = d.provider !== void 0 ? i(d.provider) : null, f = await Oo(s(c), u, d, {\n          generateTokens: !0,\n          allowExtraProviders: !1\n        });\n        switch (f.kind) {\n          case \"redirect\":\n            return { redirect: f.redirect, verifier: f.verifier };\n          case \"signedIn\":\n          case \"refreshTokens\":\n            return { tokens: f.signedIn?.tokens ?? null };\n          case \"started\":\n            return { started: !0 };\n          default: {\n            let l = f;\n            throw new Error(`Unexpected result from signIn, ${f}`);\n          }\n        }\n      }, \"handler\")\n    }),\n    /**\n     * Action called by the client to invalidate the current session.\n     */\n    signOut: un({\n      args: {},\n      handler: /* @__PURE__ */ o(async (c) => {\n        await vo(c);\n      }, \"handler\")\n    }),\n    /**\n     * Internal mutation used by the library to read and write\n     * to the database during signin and signout.\n     */\n    store: Bo({\n      args: Ia,\n      handler: /* @__PURE__ */ o(async (c, d) => Ta(c, d, i, t), \"handler\")\n    }),\n    /**\n     * Utility function for frameworks to use to get the current auth state\n     * based on credentials that they've supplied separately.\n     */\n    isAuthenticated: Jo({\n      args: {},\n      handler: /* @__PURE__ */ o(async (c, d) => await c.auth.getUserIdentity() !== null, \"handler\")\n    })\n  };\n}\no(rl, \"convexAuth\");\nasync function nl(e) {\n  let t = await e.auth.getUserIdentity();\n  if (t === null)\n    return null;\n  let [r] = t.subject.split(xe);\n  return r;\n}\no(nl, \"getAuthUserId\");\nasync function ol(e, t) {\n  return await To(e, t);\n}\no(ol, \"createAccount\");\nasync function il(e, t) {\n  let n = await Ro(e, t);\n  if (typeof n == \"string\")\n    throw new Error(n);\n  return n;\n}\no(il, \"retrieveAccount\");\nasync function sl(e, t) {\n  return await Co(e, t);\n}\no(sl, \"modifyAccountCredentials\");\nasync function al(e, t) {\n  return await Po(e, t);\n}\no(al, \"invalidateSessions\");\nasync function cl(e, t, r) {\n  let n = await Oo(e, Ws(t), r, {\n    generateTokens: !1,\n    allowExtraProviders: !0\n  });\n  return n.kind === \"signedIn\" && n.signedIn !== null ? { userId: n.signedIn.userId, sessionId: n.signedIn.sessionId } : null;\n}\no(cl, \"signInViaProvider\");\nfunction ul(e, t) {\n  return async (r, n) => {\n    try {\n      return await t(r, n);\n    } catch (i) {\n      return i instanceof $o ? new Response(null, {\n        status: e,\n        statusText: i.data\n      }) : (xo(i), new Response(null, {\n        status: 500,\n        statusText: \"Internal Server Error\"\n      }));\n    }\n  };\n}\no(ul, \"convertErrorsToResponse\");\nfunction dl(e) {\n  return (0, cn.parse)(e.headers.get(\"Cookie\") ?? \"\");\n}\no(dl, \"getCookies\");\n\nexport {\n  go as a,\n  Hd as b,\n  rl as c,\n  nl as d,\n  ol as e,\n  il as f,\n  sl as g,\n  al as h,\n  cl as i\n};\n/*! Bundled license information:\n\n@auth/core/lib/vendored/cookie.js:\n  (**\n   * @source https://github.com/jshttp/cookie\n   * @author blakeembrey\n   * @license MIT\n   *)\n*/\n//# sourceMappingURL=HCQKE6P2.js.map\n","environment":"isolate"},{"path":"seedMeetings.js","source":"import {\n  b as n\n} from \"./_deps/TRX5I57W.js\";\nimport {\n  a as t\n} from \"./_deps/Q5VBJYR5.js\";\n\n// convex/seedMeetings.ts\nvar a = n({\n  args: {},\n  handler: /* @__PURE__ */ t(async (i) => {\n    let e = [\n      {\n        title: \"Monday Mindset Session\",\n        description: \"Start your week with intention. Goal-setting, positive mindset, and weekly planning.\",\n        date: \"January 13, 2026\",\n        time: \"7:00 PM - 8:30 PM\",\n        location: \"Online (Zoom)\",\n        type: \"Online\"\n      },\n      {\n        title: \"Wednesday Wellness Check-In\",\n        description: \"Mid-week focus on mental health, stress management, and self-care practices.\",\n        date: \"January 15, 2026\",\n        time: \"6:30 PM - 8:00 PM\",\n        location: \"Community Center, Room 204\",\n        type: \"In-Person\"\n      },\n      {\n        title: \"Friday Wins & Reflections\",\n        description: \"Celebrate the week&apos;s achievements and reflect on lessons learned.\",\n        date: \"January 17, 2026\",\n        time: \"5:00 PM - 6:30 PM\",\n        location: \"Online (Zoom)\",\n        type: \"Online\"\n      },\n      {\n        title: \"Saturday Workshop: Building Resilience\",\n        description: \"Extended workshop with guest speaker Dr. Sarah Mitchell on developing mental resilience.\",\n        date: \"January 18, 2026\",\n        time: \"10:00 AM - 1:00 PM\",\n        location: \"Community Center, Main Hall\",\n        type: \"In-Person\"\n      },\n      {\n        title: \"Monday Mindset Session\",\n        description: \"Weekly session on goal-setting and positive mindset.\",\n        date: \"January 20, 2026\",\n        time: \"7:00 PM - 8:30 PM\",\n        location: \"Online (Zoom)\",\n        type: \"Online\"\n      },\n      {\n        title: \"Book Club: Atomic Habits Discussion\",\n        description: \"Join us to discuss key takeaways from Atomic Habits by James Clear.\",\n        date: \"January 22, 2026\",\n        time: \"7:00 PM - 8:30 PM\",\n        location: \"Online (Zoom)\",\n        type: \"Online\"\n      },\n      {\n        title: \"Monthly Deep Dive: Leadership Skills\",\n        description: \"Extended session exploring leadership principles and personal accountability.\",\n        date: \"February 1, 2026\",\n        time: \"10:00 AM - 2:00 PM\",\n        location: \"Community Center, Main Hall\",\n        type: \"In-Person\"\n      },\n      {\n        title: \"Evening Reflection Circle\",\n        description: \"Guided reflection and gratitude practice to close out the week.\",\n        date: \"February 7, 2026\",\n        time: \"7:00 PM - 8:30 PM\",\n        location: \"Online (Zoom)\",\n        type: \"Online\"\n      }\n    ];\n    for (let o of e)\n      await i.db.insert(\"meetings\", o);\n    return { success: !0, count: e.length };\n  }, \"handler\")\n});\nexport {\n  a as seedInitialMeetings\n};\n//# sourceMappingURL=seedMeetings.js.map\n","environment":"isolate","sourceMap":"{\n  \"version\": 3,\n  \"sources\": [\"../convex/seedMeetings.ts\"],\n  \"mappings\": \";;;;;;;;AAIO,IAAMA,IAAsBC,EAAS;AAAA,EAC1C,MAAM,CAAC;AAAA,EACP,SAAS,gBAAAC,EAAA,OAAOC,MAAQ;AACtB,QAAMC,IAAkB;AAAA,MACtB;AAAA,QACE,OAAO;AAAA,QACP,aAAa;AAAA,QACb,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU;AAAA,QACV,MAAM;AAAA,MACR;AAAA,MACA;AAAA,QACE,OAAO;AAAA,QACP,aAAa;AAAA,QACb,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU;AAAA,QACV,MAAM;AAAA,MACR;AAAA,MACA;AAAA,QACE,OAAO;AAAA,QACP,aAAa;AAAA,QACb,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU;AAAA,QACV,MAAM;AAAA,MACR;AAAA,MACA;AAAA,QACE,OAAO;AAAA,QACP,aAAa;AAAA,QACb,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU;AAAA,QACV,MAAM;AAAA,MACR;AAAA,MACA;AAAA,QACE,OAAO;AAAA,QACP,aAAa;AAAA,QACb,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU;AAAA,QACV,MAAM;AAAA,MACR;AAAA,MACA;AAAA,QACE,OAAO;AAAA,QACP,aAAa;AAAA,QACb,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU;AAAA,QACV,MAAM;AAAA,MACR;AAAA,MACA;AAAA,QACE,OAAO;AAAA,QACP,aAAa;AAAA,QACb,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU;AAAA,QACV,MAAM;AAAA,MACR;AAAA,MACA;AAAA,QACE,OAAO;AAAA,QACP,aAAa;AAAA,QACb,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU;AAAA,QACV,MAAM;AAAA,MACR;AAAA,IACF;AAEA,aAAWC,KAAWD;AACpB,YAAMD,EAAI,GAAG,OAAO,YAAYE,CAAO;AAGzC,WAAO,EAAE,SAAS,IAAM,OAAOD,EAAgB,OAAO;AAAA,EACxD,GAzES;AA0EX,CAAC;\",\n  \"names\": [\"seedInitialMeetings\", \"mutation\", \"__name\", \"ctx\", \"initialMeetings\", \"meeting\"]\n}\n"},{"path":"_deps/TRX5I57W.js","source":"import {\n  g as t,\n  h as n,\n  i as e,\n  j as o,\n  k as r\n} from \"./Q5VBJYR5.js\";\n\n// convex/_generated/server.js\nvar p = e;\nvar u = t, s = n, x = o, G = r;\n\nexport {\n  p as a,\n  u as b,\n  s as c,\n  x as d,\n  G as e\n};\n//# sourceMappingURL=TRX5I57W.js.map\n","environment":"isolate"},{"path":"_deps/Q5VBJYR5.js","source":"var Rt = Object.create;\nvar z = Object.defineProperty;\nvar qt = Object.getOwnPropertyDescriptor;\nvar Bt = Object.getOwnPropertyNames;\nvar jt = Object.getPrototypeOf, Mt = Object.prototype.hasOwnProperty;\nvar n = (t, e) => z(t, \"name\", { value: e, configurable: !0 });\nvar Zr = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), en = (t, e) => {\n  for (var r in e)\n    z(t, r, { get: e[r], enumerable: !0 });\n}, Ut = (t, e, r, o) => {\n  if (e && typeof e == \"object\" || typeof e == \"function\")\n    for (let s of Bt(e))\n      !Mt.call(t, s) && s !== r && z(t, s, { get: () => e[s], enumerable: !(o = qt(e, s)) || o.enumerable });\n  return t;\n};\nvar tn = (t, e, r) => (r = t != null ? Rt(jt(t)) : {}, Ut(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  e || !t || !t.__esModule ? z(r, \"default\", { value: t, enumerable: !0 }) : r,\n  t\n));\n\n// node_modules/convex/dist/esm/values/base64.js\nvar E = [], b = [], Jt = Uint8Array, Ae = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor (T = 0, et = Ae.length; T < et; ++T)\n  E[T] = Ae[T], b[Ae.charCodeAt(T)] = T;\nvar T, et;\nb[45] = 62;\nb[95] = 63;\nfunction Vt(t) {\n  var e = t.length;\n  if (e % 4 > 0)\n    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  var r = t.indexOf(\"=\");\n  r === -1 && (r = e);\n  var o = r === e ? 0 : 4 - r % 4;\n  return [r, o];\n}\nn(Vt, \"getLens\");\nfunction Lt(t, e, r) {\n  return (e + r) * 3 / 4 - r;\n}\nn(Lt, \"_byteLength\");\nfunction M(t) {\n  var e, r = Vt(t), o = r[0], s = r[1], i = new Jt(Lt(t, o, s)), a = 0, c = s > 0 ? o - 4 : o, d;\n  for (d = 0; d < c; d += 4)\n    e = b[t.charCodeAt(d)] << 18 | b[t.charCodeAt(d + 1)] << 12 | b[t.charCodeAt(d + 2)] << 6 | b[t.charCodeAt(d + 3)], i[a++] = e >> 16 & 255, i[a++] = e >> 8 & 255, i[a++] = e & 255;\n  return s === 2 && (e = b[t.charCodeAt(d)] << 2 | b[t.charCodeAt(d + 1)] >> 4, i[a++] = e & 255), s === 1 && (e = b[t.charCodeAt(d)] << 10 | b[t.charCodeAt(d + 1)] << 4 | b[t.charCodeAt(d + 2)] >> 2, i[a++] = e >> 8 & 255, i[a++] = e & 255), i;\n}\nn(M, \"toByteArray\");\nfunction kt(t) {\n  return E[t >> 18 & 63] + E[t >> 12 & 63] + E[t >> 6 & 63] + E[t & 63];\n}\nn(kt, \"tripletToBase64\");\nfunction Dt(t, e, r) {\n  for (var o, s = [], i = e; i < r; i += 3)\n    o = (t[i] << 16 & 16711680) + (t[i + 1] << 8 & 65280) + (t[i + 2] & 255), s.push(kt(o));\n  return s.join(\"\");\n}\nn(Dt, \"encodeChunk\");\nfunction U(t) {\n  for (var e, r = t.length, o = r % 3, s = [], i = 16383, a = 0, c = r - o; a < c; a += i)\n    s.push(\n      Dt(\n        t,\n        a,\n        a + i > c ? c : a + i\n      )\n    );\n  return o === 1 ? (e = t[r - 1], s.push(E[e >> 2] + E[e << 4 & 63] + \"==\")) : o === 2 && (e = (t[r - 2] << 8) + t[r - 1], s.push(\n    E[e >> 10] + E[e >> 4 & 63] + E[e << 2 & 63] + \"=\"\n  )), s.join(\"\");\n}\nn(U, \"fromByteArray\");\n\n// node_modules/convex/dist/esm/common/index.js\nfunction S(t) {\n  if (t === void 0)\n    return {};\n  if (!Ee(t))\n    throw new Error(\n      `The arguments to a Convex function must be an object. Received: ${t}`\n    );\n  return t;\n}\nn(S, \"parseArgs\");\nfunction Ee(t) {\n  let e = typeof t == \"object\", r = Object.getPrototypeOf(t), o = r === null || r === Object.prototype || // Objects generated from other contexts (e.g. across Node.js `vm` modules) will not satisfy the previous\n  // conditions but are still simple objects.\n  r?.constructor?.name === \"Object\";\n  return e && o;\n}\nn(Ee, \"isSimpleObject\");\n\n// node_modules/convex/dist/esm/values/value.js\nvar ot = !0, P = BigInt(\"-9223372036854775808\"), Te = BigInt(\"9223372036854775807\"), Se = BigInt(\"0\"), Qt = BigInt(\"8\"), Ht = BigInt(\"256\");\nfunction st(t) {\n  return Number.isNaN(t) || !Number.isFinite(t) || Object.is(t, -0);\n}\nn(st, \"isSpecial\");\nfunction Gt(t) {\n  t < Se && (t -= P + P);\n  let e = t.toString(16);\n  e.length % 2 === 1 && (e = \"0\" + e);\n  let r = new Uint8Array(new ArrayBuffer(8)), o = 0;\n  for (let s of e.match(/.{2}/g).reverse())\n    r.set([parseInt(s, 16)], o++), t >>= Qt;\n  return U(r);\n}\nn(Gt, \"slowBigIntToBase64\");\nfunction Wt(t) {\n  let e = M(t);\n  if (e.byteLength !== 8)\n    throw new Error(\n      `Received ${e.byteLength} bytes, expected 8 for $integer`\n    );\n  let r = Se, o = Se;\n  for (let s of e)\n    r += BigInt(s) * Ht ** o, o++;\n  return r > Te && (r += P + P), r;\n}\nn(Wt, \"slowBase64ToBigInt\");\nfunction zt(t) {\n  if (t < P || Te < t)\n    throw new Error(\n      `BigInt ${t} does not fit into a 64-bit signed integer.`\n    );\n  let e = new ArrayBuffer(8);\n  return new DataView(e).setBigInt64(0, t, !0), U(new Uint8Array(e));\n}\nn(zt, \"modernBigIntToBase64\");\nfunction Xt(t) {\n  let e = M(t);\n  if (e.byteLength !== 8)\n    throw new Error(\n      `Received ${e.byteLength} bytes, expected 8 for $integer`\n    );\n  return new DataView(e.buffer).getBigInt64(0, !0);\n}\nn(Xt, \"modernBase64ToBigInt\");\nvar Yt = DataView.prototype.setBigInt64 ? zt : Gt, Kt = DataView.prototype.getBigInt64 ? Xt : Wt, rt = 1024;\nfunction Oe(t) {\n  if (t.length > rt)\n    throw new Error(\n      `Field name ${t} exceeds maximum field name length ${rt}.`\n    );\n  if (t.startsWith(\"$\"))\n    throw new Error(`Field name ${t} starts with a '$', which is reserved.`);\n  for (let e = 0; e < t.length; e += 1) {\n    let r = t.charCodeAt(e);\n    if (r < 32 || r >= 127)\n      throw new Error(\n        `Field name ${t} has invalid character '${t[e]}': Field names can only contain non-control ASCII characters`\n      );\n  }\n}\nn(Oe, \"validateObjectField\");\nfunction y(t) {\n  if (t === null || typeof t == \"boolean\" || typeof t == \"number\" || typeof t == \"string\")\n    return t;\n  if (Array.isArray(t))\n    return t.map((o) => y(o));\n  if (typeof t != \"object\")\n    throw new Error(`Unexpected type of ${t}`);\n  let e = Object.entries(t);\n  if (e.length === 1) {\n    let o = e[0][0];\n    if (o === \"$bytes\") {\n      if (typeof t.$bytes != \"string\")\n        throw new Error(`Malformed $bytes field on ${t}`);\n      return M(t.$bytes).buffer;\n    }\n    if (o === \"$integer\") {\n      if (typeof t.$integer != \"string\")\n        throw new Error(`Malformed $integer field on ${t}`);\n      return Kt(t.$integer);\n    }\n    if (o === \"$float\") {\n      if (typeof t.$float != \"string\")\n        throw new Error(`Malformed $float field on ${t}`);\n      let s = M(t.$float);\n      if (s.byteLength !== 8)\n        throw new Error(\n          `Received ${s.byteLength} bytes, expected 8 for $float`\n        );\n      let a = new DataView(s.buffer).getFloat64(0, ot);\n      if (!st(a))\n        throw new Error(`Float ${a} should be encoded as a number`);\n      return a;\n    }\n    if (o === \"$set\")\n      throw new Error(\n        \"Received a Set which is no longer supported as a Convex type.\"\n      );\n    if (o === \"$map\")\n      throw new Error(\n        \"Received a Map which is no longer supported as a Convex type.\"\n      );\n  }\n  let r = {};\n  for (let [o, s] of Object.entries(t))\n    Oe(o), r[o] = y(s);\n  return r;\n}\nn(y, \"jsonToConvex\");\nvar nt = 16384;\nfunction _(t) {\n  let e = JSON.stringify(t, (r, o) => o === void 0 ? \"undefined\" : typeof o == \"bigint\" ? `${o.toString()}n` : o);\n  if (e.length > nt) {\n    let r = \"[...truncated]\", o = nt - r.length, s = e.codePointAt(o - 1);\n    return s !== void 0 && s > 65535 && (o -= 1), e.substring(0, o) + r;\n  }\n  return e;\n}\nn(_, \"stringifyValueForError\");\nfunction J(t, e, r, o) {\n  if (t === void 0) {\n    let a = r && ` (present at path ${r} in original object ${_(\n      e\n    )})`;\n    throw new Error(\n      `undefined is not a valid Convex value${a}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`\n    );\n  }\n  if (t === null)\n    return t;\n  if (typeof t == \"bigint\") {\n    if (t < P || Te < t)\n      throw new Error(\n        `BigInt ${t} does not fit into a 64-bit signed integer.`\n      );\n    return { $integer: Yt(t) };\n  }\n  if (typeof t == \"number\")\n    if (st(t)) {\n      let a = new ArrayBuffer(8);\n      return new DataView(a).setFloat64(0, t, ot), { $float: U(new Uint8Array(a)) };\n    } else\n      return t;\n  if (typeof t == \"boolean\" || typeof t == \"string\")\n    return t;\n  if (t instanceof ArrayBuffer)\n    return { $bytes: U(new Uint8Array(t)) };\n  if (Array.isArray(t))\n    return t.map(\n      (a, c) => J(a, e, r + `[${c}]`, !1)\n    );\n  if (t instanceof Set)\n    throw new Error(\n      Ie(r, \"Set\", [...t], e)\n    );\n  if (t instanceof Map)\n    throw new Error(\n      Ie(r, \"Map\", [...t], e)\n    );\n  if (!Ee(t)) {\n    let a = t?.constructor?.name, c = a ? `${a} ` : \"\";\n    throw new Error(\n      Ie(r, c, t, e)\n    );\n  }\n  let s = {}, i = Object.entries(t);\n  i.sort(([a, c], [d, O]) => a === d ? 0 : a < d ? -1 : 1);\n  for (let [a, c] of i)\n    c !== void 0 ? (Oe(a), s[a] = J(c, e, r + `.${a}`, !1)) : o && (Oe(a), s[a] = it(\n      c,\n      e,\n      r + `.${a}`\n    ));\n  return s;\n}\nn(J, \"convexToJsonInternal\");\nfunction Ie(t, e, r, o) {\n  return t ? `${e}${_(\n    r\n  )} is not a supported Convex type (present at path ${t} in original object ${_(\n    o\n  )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.` : `${e}${_(\n    r\n  )} is not a supported Convex type.`;\n}\nn(Ie, \"errorMessageForUnsupportedType\");\nfunction it(t, e, r) {\n  if (t === void 0)\n    return { $undefined: null };\n  if (e === void 0)\n    throw new Error(\n      `Programming error. Current value is ${_(\n        t\n      )} but original value is undefined`\n    );\n  return J(t, e, r, !1);\n}\nn(it, \"convexOrUndefinedToJsonInternal\");\nfunction h(t) {\n  return J(t, t, \"\", !1);\n}\nn(h, \"convexToJson\");\nfunction v(t) {\n  return it(t, t, \"\");\n}\nn(v, \"convexOrUndefinedToJson\");\nfunction at(t) {\n  return J(t, t, \"\", !0);\n}\nn(at, \"patchValueToJson\");\n\n// node_modules/convex/dist/esm/values/validators.js\nvar Zt = Object.defineProperty, er = /* @__PURE__ */ n((t, e, r) => e in t ? Zt(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), m = /* @__PURE__ */ n((t, e, r) => er(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), tr = \"https://docs.convex.dev/error#undefined-validator\";\nfunction V(t, e) {\n  let r = e !== void 0 ? ` for field \"${e}\"` : \"\";\n  throw new Error(\n    `A validator is undefined${r} in ${t}. This is often caused by circular imports. See ${tr} for details.`\n  );\n}\nn(V, \"throwUndefinedValidatorError\");\nvar g = class {\n  static {\n    n(this, \"BaseValidator\");\n  }\n  constructor({ isOptional: e }) {\n    m(this, \"type\"), m(this, \"fieldPaths\"), m(this, \"isOptional\"), m(this, \"isConvexValidator\"), this.isOptional = e, this.isConvexValidator = !0;\n  }\n}, X = class t extends g {\n  static {\n    n(this, \"VId\");\n  }\n  /**\n   * Usually you'd use `v.id(tableName)` instead.\n   */\n  constructor({\n    isOptional: e,\n    tableName: r\n  }) {\n    if (super({ isOptional: e }), m(this, \"tableName\"), m(this, \"kind\", \"id\"), typeof r != \"string\")\n      throw new Error(\"v.id(tableName) requires a string\");\n    this.tableName = r;\n  }\n  /** @internal */\n  get json() {\n    return { type: \"id\", tableName: this.tableName };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({\n      isOptional: \"optional\",\n      tableName: this.tableName\n    });\n  }\n}, L = class t extends g {\n  static {\n    n(this, \"VFloat64\");\n  }\n  constructor() {\n    super(...arguments), m(this, \"kind\", \"float64\");\n  }\n  /** @internal */\n  get json() {\n    return { type: \"number\" };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({\n      isOptional: \"optional\"\n    });\n  }\n}, k = class t extends g {\n  static {\n    n(this, \"VInt64\");\n  }\n  constructor() {\n    super(...arguments), m(this, \"kind\", \"int64\");\n  }\n  /** @internal */\n  get json() {\n    return { type: \"bigint\" };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({ isOptional: \"optional\" });\n  }\n}, Y = class t extends g {\n  static {\n    n(this, \"VBoolean\");\n  }\n  constructor() {\n    super(...arguments), m(this, \"kind\", \"boolean\");\n  }\n  /** @internal */\n  get json() {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({\n      isOptional: \"optional\"\n    });\n  }\n}, K = class t extends g {\n  static {\n    n(this, \"VBytes\");\n  }\n  constructor() {\n    super(...arguments), m(this, \"kind\", \"bytes\");\n  }\n  /** @internal */\n  get json() {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({ isOptional: \"optional\" });\n  }\n}, Z = class t extends g {\n  static {\n    n(this, \"VString\");\n  }\n  constructor() {\n    super(...arguments), m(this, \"kind\", \"string\");\n  }\n  /** @internal */\n  get json() {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({\n      isOptional: \"optional\"\n    });\n  }\n}, ee = class t extends g {\n  static {\n    n(this, \"VNull\");\n  }\n  constructor() {\n    super(...arguments), m(this, \"kind\", \"null\");\n  }\n  /** @internal */\n  get json() {\n    return { type: this.kind };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({ isOptional: \"optional\" });\n  }\n}, te = class t extends g {\n  static {\n    n(this, \"VAny\");\n  }\n  constructor() {\n    super(...arguments), m(this, \"kind\", \"any\");\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({\n      isOptional: \"optional\"\n    });\n  }\n}, re = class t extends g {\n  static {\n    n(this, \"VObject\");\n  }\n  /**\n   * Usually you'd use `v.object({ ... })` instead.\n   */\n  constructor({\n    isOptional: e,\n    fields: r\n  }) {\n    super({ isOptional: e }), m(this, \"fields\"), m(this, \"kind\", \"object\"), globalThis.Object.entries(r).forEach(([o, s]) => {\n      if (s === void 0 && V(\"v.object()\", o), !s.isConvexValidator)\n        throw new Error(\"v.object() entries must be validators\");\n    }), this.fields = r;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: globalThis.Object.fromEntries(\n        globalThis.Object.entries(this.fields).map(([e, r]) => [\n          e,\n          {\n            fieldType: r.json,\n            optional: r.isOptional === \"optional\"\n          }\n        ])\n      )\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({\n      isOptional: \"optional\",\n      fields: this.fields\n    });\n  }\n  /**\n   * Create a new VObject with the specified fields omitted.\n   * @param fields The field names to omit from this VObject.\n   */\n  omit(...e) {\n    let r = { ...this.fields };\n    for (let o of e)\n      delete r[o];\n    return new t({\n      isOptional: this.isOptional,\n      fields: r\n    });\n  }\n  /**\n   * Create a new VObject with only the specified fields.\n   * @param fields The field names to pick from this VObject.\n   */\n  pick(...e) {\n    let r = {};\n    for (let o of e)\n      r[o] = this.fields[o];\n    return new t({\n      isOptional: this.isOptional,\n      fields: r\n    });\n  }\n  /**\n   * Create a new VObject with all fields marked as optional.\n   */\n  partial() {\n    let e = {};\n    for (let [r, o] of globalThis.Object.entries(this.fields))\n      e[r] = o.asOptional();\n    return new t({\n      isOptional: this.isOptional,\n      fields: e\n    });\n  }\n  /**\n   * Create a new VObject with additional fields merged in.\n   * @param fields An object with additional validators to merge into this VObject.\n   */\n  extend(e) {\n    return new t({\n      isOptional: this.isOptional,\n      fields: { ...this.fields, ...e }\n    });\n  }\n}, ne = class t extends g {\n  static {\n    n(this, \"VLiteral\");\n  }\n  /**\n   * Usually you'd use `v.literal(value)` instead.\n   */\n  constructor({ isOptional: e, value: r }) {\n    if (super({ isOptional: e }), m(this, \"value\"), m(this, \"kind\", \"literal\"), typeof r != \"string\" && typeof r != \"boolean\" && typeof r != \"number\" && typeof r != \"bigint\")\n      throw new Error(\"v.literal(value) must be a string, number, or boolean\");\n    this.value = r;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: h(this.value)\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({\n      isOptional: \"optional\",\n      value: this.value\n    });\n  }\n}, oe = class t extends g {\n  static {\n    n(this, \"VArray\");\n  }\n  /**\n   * Usually you'd use `v.array(element)` instead.\n   */\n  constructor({\n    isOptional: e,\n    element: r\n  }) {\n    super({ isOptional: e }), m(this, \"element\"), m(this, \"kind\", \"array\"), r === void 0 && V(\"v.array()\"), this.element = r;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: this.element.json\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({\n      isOptional: \"optional\",\n      element: this.element\n    });\n  }\n}, se = class t extends g {\n  static {\n    n(this, \"VRecord\");\n  }\n  /**\n   * Usually you'd use `v.record(key, value)` instead.\n   */\n  constructor({\n    isOptional: e,\n    key: r,\n    value: o\n  }) {\n    if (super({ isOptional: e }), m(this, \"key\"), m(this, \"value\"), m(this, \"kind\", \"record\"), r === void 0 && V(\"v.record()\", \"key\"), o === void 0 && V(\"v.record()\", \"value\"), r.isOptional === \"optional\")\n      throw new Error(\"Record validator cannot have optional keys\");\n    if (o.isOptional === \"optional\")\n      throw new Error(\"Record validator cannot have optional values\");\n    if (!r.isConvexValidator || !o.isConvexValidator)\n      throw new Error(\"Key and value of v.record() but be validators\");\n    this.key = r, this.value = o;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      // This cast is needed because TypeScript thinks the key type is too wide\n      keys: this.key.json,\n      values: {\n        fieldType: this.value.json,\n        optional: !1\n      }\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({\n      isOptional: \"optional\",\n      key: this.key,\n      value: this.value\n    });\n  }\n}, ie = class t extends g {\n  static {\n    n(this, \"VUnion\");\n  }\n  /**\n   * Usually you'd use `v.union(...members)` instead.\n   */\n  constructor({ isOptional: e, members: r }) {\n    super({ isOptional: e }), m(this, \"members\"), m(this, \"kind\", \"union\"), r.forEach((o, s) => {\n      if (o === void 0 && V(\"v.union()\", `member at index ${s}`), !o.isConvexValidator)\n        throw new Error(\"All members of v.union() must be validators\");\n    }), this.members = r;\n  }\n  /** @internal */\n  get json() {\n    return {\n      type: this.kind,\n      value: this.members.map((e) => e.json)\n    };\n  }\n  /** @internal */\n  asOptional() {\n    return new t({\n      isOptional: \"optional\",\n      members: this.members\n    });\n  }\n};\n\n// node_modules/convex/dist/esm/values/validator.js\nfunction _e(t) {\n  return !!t.isConvexValidator;\n}\nn(_e, \"isValidator\");\nfunction ae(t) {\n  return _e(t) ? t : u.object(t);\n}\nn(ae, \"asObjectValidator\");\nvar u = {\n  /**\n   * Validates that the value corresponds to an ID of a document in given table.\n   * @param tableName The name of the table.\n   */\n  id: /* @__PURE__ */ n((t) => new X({\n    isOptional: \"required\",\n    tableName: t\n  }), \"id\"),\n  /**\n   * Validates that the value is of type Null.\n   */\n  null: /* @__PURE__ */ n(() => new ee({ isOptional: \"required\" }), \"null\"),\n  /**\n   * Validates that the value is of Convex type Float64 (Number in JS).\n   *\n   * Alias for `v.float64()`\n   */\n  number: /* @__PURE__ */ n(() => new L({ isOptional: \"required\" }), \"number\"),\n  /**\n   * Validates that the value is of Convex type Float64 (Number in JS).\n   */\n  float64: /* @__PURE__ */ n(() => new L({ isOptional: \"required\" }), \"float64\"),\n  /**\n   * @deprecated Use `v.int64()` instead\n   */\n  bigint: /* @__PURE__ */ n(() => new k({ isOptional: \"required\" }), \"bigint\"),\n  /**\n   * Validates that the value is of Convex type Int64 (BigInt in JS).\n   */\n  int64: /* @__PURE__ */ n(() => new k({ isOptional: \"required\" }), \"int64\"),\n  /**\n   * Validates that the value is of type Boolean.\n   */\n  boolean: /* @__PURE__ */ n(() => new Y({ isOptional: \"required\" }), \"boolean\"),\n  /**\n   * Validates that the value is of type String.\n   */\n  string: /* @__PURE__ */ n(() => new Z({ isOptional: \"required\" }), \"string\"),\n  /**\n   * Validates that the value is of Convex type Bytes (constructed in JS via `ArrayBuffer`).\n   */\n  bytes: /* @__PURE__ */ n(() => new K({ isOptional: \"required\" }), \"bytes\"),\n  /**\n   * Validates that the value is equal to the given literal value.\n   * @param literal The literal value to compare against.\n   */\n  literal: /* @__PURE__ */ n((t) => new ne({ isOptional: \"required\", value: t }), \"literal\"),\n  /**\n   * Validates that the value is an Array of the given element type.\n   * @param element The validator for the elements of the array.\n   */\n  array: /* @__PURE__ */ n((t) => new oe({ isOptional: \"required\", element: t }), \"array\"),\n  /**\n   * Validates that the value is an Object with the given properties.\n   * @param fields An object specifying the validator for each property.\n   */\n  object: /* @__PURE__ */ n((t) => new re({ isOptional: \"required\", fields: t }), \"object\"),\n  /**\n   * Validates that the value is a Record with keys and values that match the given types.\n   * @param keys The validator for the keys of the record. This cannot contain string literals.\n   * @param values The validator for the values of the record.\n   */\n  record: /* @__PURE__ */ n((t, e) => new se({\n    isOptional: \"required\",\n    key: t,\n    value: e\n  }), \"record\"),\n  /**\n   * Validates that the value matches one of the given validators.\n   * @param members The validators to match against.\n   */\n  union: /* @__PURE__ */ n((...t) => new ie({\n    isOptional: \"required\",\n    members: t\n  }), \"union\"),\n  /**\n   * Does not validate the value.\n   */\n  any: /* @__PURE__ */ n(() => new te({ isOptional: \"required\" }), \"any\"),\n  /**\n   * Allows not specifying a value for a property in an Object.\n   * @param value The property value validator to make optional.\n   *\n   * ```typescript\n   * const objectWithOptionalFields = v.object({\n   *   requiredField: v.string(),\n   *   optionalField: v.optional(v.string()),\n   * });\n   * ```\n   */\n  optional: /* @__PURE__ */ n((t) => t.asOptional(), \"optional\"),\n  /**\n   * Allows specifying a value or null.\n   */\n  nullable: /* @__PURE__ */ n((t) => u.union(t, u.null()), \"nullable\")\n};\n\n// node_modules/convex/dist/esm/values/errors.js\nvar rr = Object.defineProperty, nr = /* @__PURE__ */ n((t, e, r) => e in t ? rr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), Ce = /* @__PURE__ */ n((t, e, r) => nr(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), ut, ct, or = Symbol.for(\"ConvexError\"), ue = class extends (ct = Error, ut = or, ct) {\n  static {\n    n(this, \"ConvexError\");\n  }\n  constructor(e) {\n    super(typeof e == \"string\" ? e : _(e)), Ce(this, \"name\", \"ConvexError\"), Ce(this, \"data\"), Ce(this, ut, !0), this.data = e;\n  }\n};\n\n// node_modules/convex/dist/esm/values/compare_utf8.js\nvar lt = /* @__PURE__ */ n(() => Array.from({ length: 4 }, () => 0), \"arr\"), gn = lt(), bn = lt();\n\n// node_modules/convex/dist/esm/server/functionName.js\nvar F = Symbol.for(\"functionName\");\n\n// node_modules/convex/dist/esm/server/components/paths.js\nvar $e = Symbol.for(\"toReferencePath\");\nfunction sr(t) {\n  return t[$e] ?? null;\n}\nn(sr, \"extractReferencePath\");\nfunction ir(t) {\n  return t.startsWith(\"function://\");\n}\nn(ir, \"isFunctionHandle\");\nfunction A(t) {\n  let e;\n  if (typeof t == \"string\")\n    ir(t) ? e = { functionHandle: t } : e = { name: t };\n  else if (t[F])\n    e = { name: t[F] };\n  else {\n    let r = sr(t);\n    if (!r)\n      throw new Error(`${t} is not a functionReference`);\n    e = { reference: r };\n  }\n  return e;\n}\nn(A, \"getFunctionAddress\");\n\n// node_modules/convex/dist/esm/server/api.js\nfunction Ne(t) {\n  let e = A(t);\n  if (e.name === void 0)\n    throw e.functionHandle !== void 0 ? new Error(\n      `Expected function reference like \"api.file.func\" or \"internal.file.func\", but received function handle ${e.functionHandle}`\n    ) : e.reference !== void 0 ? new Error(\n      `Expected function reference in the current component like \"api.file.func\" or \"internal.file.func\", but received reference ${e.reference}`\n    ) : new Error(\n      `Expected function reference like \"api.file.func\" or \"internal.file.func\", but received ${JSON.stringify(e)}`\n    );\n  if (typeof t == \"string\") return t;\n  let r = t[F];\n  if (!r)\n    throw new Error(`${t} is not a functionReference`);\n  return r;\n}\nn(Ne, \"getFunctionName\");\nfunction ft(t = []) {\n  let e = {\n    get(r, o) {\n      if (typeof o == \"string\") {\n        let s = [...t, o];\n        return ft(s);\n      } else if (o === F) {\n        if (t.length < 2) {\n          let a = [\"api\", ...t].join(\".\");\n          throw new Error(\n            `API path is expected to be of the form \\`api.moduleName.functionName\\`. Found: \\`${a}\\``\n          );\n        }\n        let s = t.slice(0, -1).join(\"/\"), i = t[t.length - 1];\n        return i === \"default\" ? s : s + \":\" + i;\n      } else return o === Symbol.toStringTag ? \"FunctionReference\" : void 0;\n    }\n  };\n  return new Proxy({}, e);\n}\nn(ft, \"createApi\");\nvar ar = ft();\n\n// node_modules/convex/dist/esm/server/cron.js\nvar ur = Object.defineProperty, cr = /* @__PURE__ */ n((t, e, r) => e in t ? ur(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), pt = /* @__PURE__ */ n((t, e, r) => cr(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), lr = [\n  \"sunday\",\n  \"monday\",\n  \"tuesday\",\n  \"wednesday\",\n  \"thursday\",\n  \"friday\",\n  \"saturday\"\n], fr = /* @__PURE__ */ n(() => new Re(), \"cronJobs\");\nfunction Pe(t) {\n  if (!Number.isInteger(t) || t <= 0)\n    throw new Error(\"Interval must be an integer greater than 0\");\n}\nn(Pe, \"validateIntervalNumber\");\nfunction pr(t) {\n  if (!Number.isInteger(t) || t < 1 || t > 31)\n    throw new Error(\"Day of month must be an integer from 1 to 31\");\n  return t;\n}\nn(pr, \"validatedDayOfMonth\");\nfunction dr(t) {\n  if (!lr.includes(t))\n    throw new Error('Day of week must be a string like \"monday\".');\n  return t;\n}\nn(dr, \"validatedDayOfWeek\");\nfunction Fe(t) {\n  if (!Number.isInteger(t) || t < 0 || t > 23)\n    throw new Error(\"Hour of day must be an integer from 0 to 23\");\n  return t;\n}\nn(Fe, \"validatedHourOfDay\");\nfunction ce(t) {\n  if (!Number.isInteger(t) || t < 0 || t > 59)\n    throw new Error(\"Minute of hour must be an integer from 0 to 59\");\n  return t;\n}\nn(ce, \"validatedMinuteOfHour\");\nfunction hr(t) {\n  if (!t.match(/^[ -~]*$/))\n    throw new Error(\n      `Invalid cron identifier ${t}: use ASCII letters that are not control characters`\n    );\n  return t;\n}\nn(hr, \"validatedCronIdentifier\");\nvar Re = class {\n  static {\n    n(this, \"Crons\");\n  }\n  constructor() {\n    pt(this, \"crons\"), pt(this, \"isCrons\"), this.isCrons = !0, this.crons = {};\n  }\n  /** @internal */\n  schedule(e, r, o, s) {\n    let i = S(s);\n    if (hr(e), e in this.crons)\n      throw new Error(`Cron identifier registered twice: ${e}`);\n    this.crons[e] = {\n      name: Ne(o),\n      args: [h(i)],\n      schedule: r\n    };\n  }\n  /**\n   * Schedule a mutation or action to run at some interval.\n   *\n   * ```js\n   * crons.interval(\"Clear presence data\", {seconds: 30}, api.presence.clear);\n   * ```\n   *\n   * @param identifier - A unique name for this scheduled job.\n   * @param schedule - The time between runs for this scheduled job.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  interval(e, r, o, ...s) {\n    let i = r, a = +(\"seconds\" in i && i.seconds !== void 0), c = +(\"minutes\" in i && i.minutes !== void 0), d = +(\"hours\" in i && i.hours !== void 0);\n    if (a + c + d !== 1)\n      throw new Error(\"Must specify one of seconds, minutes, or hours\");\n    a ? Pe(r.seconds) : c ? Pe(r.minutes) : d && Pe(r.hours), this.schedule(\n      e,\n      { ...r, type: \"interval\" },\n      o,\n      ...s\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on an hourly basis.\n   *\n   * ```js\n   * crons.hourly(\n   *   \"Reset high scores\",\n   *   {\n   *     minuteUTC: 30,\n   *   },\n   *   api.scores.reset\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What time (UTC) each day to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  hourly(e, r, o, ...s) {\n    let i = ce(r.minuteUTC);\n    this.schedule(\n      e,\n      { minuteUTC: i, type: \"hourly\" },\n      o,\n      ...s\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a daily basis.\n   *\n   * ```js\n   * crons.daily(\n   *   \"Reset high scores\",\n   *   {\n   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)\n   *     minuteUTC: 30,\n   *   },\n   *   api.scores.reset\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What time (UTC) each day to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  daily(e, r, o, ...s) {\n    let i = Fe(r.hourUTC), a = ce(r.minuteUTC);\n    this.schedule(\n      e,\n      { hourUTC: i, minuteUTC: a, type: \"daily\" },\n      o,\n      ...s\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a weekly basis.\n   *\n   * ```js\n   * crons.weekly(\n   *   \"Weekly re-engagement email\",\n   *   {\n   *     dayOfWeek: \"Tuesday\",\n   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)\n   *     minuteUTC: 30,\n   *   },\n   *   api.emails.send\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What day and time (UTC) each week to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   */\n  weekly(e, r, o, ...s) {\n    let i = dr(r.dayOfWeek), a = Fe(r.hourUTC), c = ce(r.minuteUTC);\n    this.schedule(\n      e,\n      { dayOfWeek: i, hourUTC: a, minuteUTC: c, type: \"weekly\" },\n      o,\n      ...s\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a monthly basis.\n   *\n   * Note that some months have fewer days than others, so e.g. a function\n   * scheduled to run on the 30th will not run in February.\n   *\n   * ```js\n   * crons.monthly(\n   *   \"Bill customers at \",\n   *   {\n   *     hourUTC: 17, // (9:30am Pacific/10:30am Daylight Savings Pacific)\n   *     minuteUTC: 30,\n   *     day: 1,\n   *   },\n   *   api.billing.billCustomers\n   * )\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param schedule - What day and time (UTC) each month to run this function.\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  monthly(e, r, o, ...s) {\n    let i = pr(r.day), a = Fe(r.hourUTC), c = ce(r.minuteUTC);\n    this.schedule(\n      e,\n      { day: i, hourUTC: a, minuteUTC: c, type: \"monthly\" },\n      o,\n      ...s\n    );\n  }\n  /**\n   * Schedule a mutation or action to run on a recurring basis.\n   *\n   * Like the unix command `cron`, Sunday is 0, Monday is 1, etc.\n   *\n   * ```\n   *   minute (0 - 59)\n   *    hour (0 - 23)\n   *     day of the month (1 - 31)\n   *      month (1 - 12)\n   *       day of the week (0 - 6) (Sunday to Saturday)\n   * \"* * * * *\"\n   * ```\n   *\n   * @param cronIdentifier - A unique name for this scheduled job.\n   * @param cron - Cron string like `\"15 7 * * *\"` (Every day at 7:15 UTC)\n   * @param functionReference - A {@link FunctionReference} for the function\n   * to schedule.\n   * @param args - The arguments to the function.\n   */\n  cron(e, r, o, ...s) {\n    let i = r;\n    this.schedule(\n      e,\n      { cron: i, type: \"cron\" },\n      o,\n      ...s\n    );\n  }\n  /** @internal */\n  export() {\n    return JSON.stringify(this.crons);\n  }\n};\n\n// node_modules/convex/dist/esm/server/impl/syscall.js\nfunction D(t, e) {\n  if (typeof Convex > \"u\" || Convex.syscall === void 0)\n    throw new Error(\n      \"The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?\"\n    );\n  let r = Convex.syscall(t, JSON.stringify(e));\n  return JSON.parse(r);\n}\nn(D, \"performSyscall\");\nasync function f(t, e) {\n  if (typeof Convex > \"u\" || Convex.asyncSyscall === void 0)\n    throw new Error(\n      \"The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?\"\n    );\n  let r;\n  try {\n    r = await Convex.asyncSyscall(t, JSON.stringify(e));\n  } catch (o) {\n    if (o.data !== void 0) {\n      let s = new ue(o.message);\n      throw s.data = y(o.data), s;\n    }\n    throw new Error(o.message);\n  }\n  return JSON.parse(r);\n}\nn(f, \"performAsyncSyscall\");\nfunction C(t, e) {\n  if (typeof Convex > \"u\" || Convex.jsSyscall === void 0)\n    throw new Error(\n      \"The Convex database and auth objects are being used outside of a Convex backend. Did you mean to use `useQuery` or `useMutation` to call a Convex function?\"\n    );\n  return Convex.jsSyscall(t, e);\n}\nn(C, \"performJsSyscall\");\n\n// node_modules/convex/dist/esm/server/router.js\nvar mr = Object.defineProperty, yr = /* @__PURE__ */ n((t, e, r) => e in t ? mr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), $ = /* @__PURE__ */ n((t, e, r) => yr(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), dt = [\n  \"GET\",\n  \"POST\",\n  \"PUT\",\n  \"DELETE\",\n  \"OPTIONS\",\n  \"PATCH\"\n];\nfunction wr(t) {\n  return t === \"HEAD\" ? \"GET\" : t;\n}\nn(wr, \"normalizeMethod\");\nvar xr = /* @__PURE__ */ n(() => new le(), \"httpRouter\"), le = class {\n  static {\n    n(this, \"HttpRouter\");\n  }\n  constructor() {\n    $(this, \"exactRoutes\", /* @__PURE__ */ new Map()), $(this, \"prefixRoutes\", /* @__PURE__ */ new Map()), $(this, \"isRouter\", !0), $(this, \"route\", (e) => {\n      if (!e.handler) throw new Error(\"route requires handler\");\n      if (!e.method) throw new Error(\"route requires method\");\n      let { method: r, handler: o } = e;\n      if (!dt.includes(r))\n        throw new Error(\n          `'${r}' is not an allowed HTTP method (like GET, POST, PUT etc.)`\n        );\n      if (\"path\" in e) {\n        if (\"pathPrefix\" in e)\n          throw new Error(\n            \"Invalid httpRouter route: cannot contain both 'path' and 'pathPrefix'\"\n          );\n        if (!e.path.startsWith(\"/\"))\n          throw new Error(`path '${e.path}' does not start with a /`);\n        if (e.path.startsWith(\"/.files/\") || e.path === \"/.files\")\n          throw new Error(`path '${e.path}' is reserved`);\n        let s = this.exactRoutes.has(e.path) ? this.exactRoutes.get(e.path) : /* @__PURE__ */ new Map();\n        if (s.has(r))\n          throw new Error(\n            `Path '${e.path}' for method ${r} already in use`\n          );\n        s.set(r, o), this.exactRoutes.set(e.path, s);\n      } else if (\"pathPrefix\" in e) {\n        if (!e.pathPrefix.startsWith(\"/\"))\n          throw new Error(\n            `pathPrefix '${e.pathPrefix}' does not start with a /`\n          );\n        if (!e.pathPrefix.endsWith(\"/\"))\n          throw new Error(`pathPrefix ${e.pathPrefix} must end with a /`);\n        if (e.pathPrefix.startsWith(\"/.files/\"))\n          throw new Error(`pathPrefix '${e.pathPrefix}' is reserved`);\n        let s = this.prefixRoutes.get(r) || /* @__PURE__ */ new Map();\n        if (s.has(e.pathPrefix))\n          throw new Error(\n            `${e.method} pathPrefix ${e.pathPrefix} is already defined`\n          );\n        s.set(e.pathPrefix, o), this.prefixRoutes.set(r, s);\n      } else\n        throw new Error(\n          \"Invalid httpRouter route entry: must contain either field 'path' or 'pathPrefix'\"\n        );\n    }), $(this, \"getRoutes\", () => {\n      let r = [...this.exactRoutes.keys()].sort().flatMap(\n        (i) => [...this.exactRoutes.get(i).keys()].sort().map(\n          (a) => [i, a, this.exactRoutes.get(i).get(a)]\n        )\n      ), s = [...this.prefixRoutes.keys()].sort().flatMap(\n        (i) => [...this.prefixRoutes.get(i).keys()].sort().map(\n          (a) => [\n            `${a}*`,\n            i,\n            this.prefixRoutes.get(i).get(a)\n          ]\n        )\n      );\n      return [...r, ...s];\n    }), $(this, \"lookup\", (e, r) => {\n      r = wr(r);\n      let o = this.exactRoutes.get(e)?.get(r);\n      if (o) return [o, r, e];\n      let i = [...(this.prefixRoutes.get(r) || /* @__PURE__ */ new Map()).entries()].sort(\n        ([a, c], [d, O]) => d.length - a.length\n      );\n      for (let [a, c] of i)\n        if (e.startsWith(a))\n          return [c, r, `${a}*`];\n      return null;\n    }), $(this, \"runRequest\", async (e, r) => {\n      let o = C(\"requestFromConvexJson\", {\n        convexJson: JSON.parse(e)\n      }), s = r;\n      (!s || typeof s != \"string\") && (s = new URL(o.url).pathname);\n      let i = o.method, a = this.lookup(s, i);\n      if (!a) {\n        let ve = new Response(`No HttpAction routed for ${s}`, {\n          status: 404\n        });\n        return JSON.stringify(\n          C(\"convexJsonFromResponse\", { response: ve })\n        );\n      }\n      let [c, d, O] = a, be = await c.invokeHttpAction(o);\n      return JSON.stringify(\n        C(\"convexJsonFromResponse\", { response: be })\n      );\n    });\n  }\n};\n\n// node_modules/convex/dist/esm/index.js\nvar w = \"1.31.5\";\n\n// node_modules/convex/dist/esm/server/impl/actions_impl.js\nfunction qe(t, e, r) {\n  return {\n    ...A(e),\n    args: h(S(r)),\n    version: w,\n    requestId: t\n  };\n}\nn(qe, \"syscallArgs\");\nfunction Be(t) {\n  return {\n    runQuery: /* @__PURE__ */ n(async (e, r) => {\n      let o = await f(\n        \"1.0/actions/query\",\n        qe(t, e, r)\n      );\n      return y(o);\n    }, \"runQuery\"),\n    runMutation: /* @__PURE__ */ n(async (e, r) => {\n      let o = await f(\n        \"1.0/actions/mutation\",\n        qe(t, e, r)\n      );\n      return y(o);\n    }, \"runMutation\"),\n    runAction: /* @__PURE__ */ n(async (e, r) => {\n      let o = await f(\n        \"1.0/actions/action\",\n        qe(t, e, r)\n      );\n      return y(o);\n    }, \"runAction\")\n  };\n}\nn(Be, \"setupActionCalls\");\n\n// node_modules/convex/dist/esm/server/vector_search.js\nvar gr = Object.defineProperty, br = /* @__PURE__ */ n((t, e, r) => e in t ? gr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), ht = /* @__PURE__ */ n((t, e, r) => br(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), fe = class {\n  static {\n    n(this, \"FilterExpression\");\n  }\n  /**\n   * @internal\n   */\n  constructor() {\n    ht(this, \"_isExpression\"), ht(this, \"_value\");\n  }\n};\n\n// node_modules/convex/dist/esm/server/impl/validate.js\nfunction l(t, e, r, o) {\n  if (t === void 0)\n    throw new TypeError(\n      `Must provide arg ${e} \\`${o}\\` to \\`${r}\\``\n    );\n}\nn(l, \"validateArg\");\nfunction mt(t, e, r, o) {\n  if (!Number.isInteger(t) || t < 0)\n    throw new TypeError(\n      `Arg ${e} \\`${o}\\` to \\`${r}\\` must be a non-negative integer`\n    );\n}\nn(mt, \"validateArgIsNonNegativeInteger\");\n\n// node_modules/convex/dist/esm/server/impl/vector_search_impl.js\nvar vr = Object.defineProperty, Ar = /* @__PURE__ */ n((t, e, r) => e in t ? vr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), je = /* @__PURE__ */ n((t, e, r) => Ar(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\");\nfunction Ue(t) {\n  return async (e, r, o) => {\n    if (l(e, 1, \"vectorSearch\", \"tableName\"), l(r, 2, \"vectorSearch\", \"indexName\"), l(o, 3, \"vectorSearch\", \"query\"), !o.vector || !Array.isArray(o.vector) || o.vector.length === 0)\n      throw Error(\"`vector` must be a non-empty Array in vectorSearch\");\n    return await new Me(\n      t,\n      e + \".\" + r,\n      o\n    ).collect();\n  };\n}\nn(Ue, \"setupActionVectorSearch\");\nvar Me = class {\n  static {\n    n(this, \"VectorQueryImpl\");\n  }\n  constructor(e, r, o) {\n    je(this, \"requestId\"), je(this, \"state\"), this.requestId = e;\n    let s = o.filter ? pe(o.filter(Er)) : null;\n    this.state = {\n      type: \"preparing\",\n      query: {\n        indexName: r,\n        limit: o.limit,\n        vector: o.vector,\n        expressions: s\n      }\n    };\n  }\n  async collect() {\n    if (this.state.type === \"consumed\")\n      throw new Error(\"This query is closed and can't emit any more values.\");\n    let e = this.state.query;\n    this.state = { type: \"consumed\" };\n    let { results: r } = await f(\"1.0/actions/vectorSearch\", {\n      requestId: this.requestId,\n      version: w,\n      query: e\n    });\n    return r;\n  }\n}, R = class extends fe {\n  static {\n    n(this, \"ExpressionImpl\");\n  }\n  constructor(e) {\n    super(), je(this, \"inner\"), this.inner = e;\n  }\n  serialize() {\n    return this.inner;\n  }\n};\nfunction pe(t) {\n  return t instanceof R ? t.serialize() : { $literal: v(t) };\n}\nn(pe, \"serializeExpression\");\nvar Er = {\n  //  Comparisons  /////////////////////////////////////////////////////////////\n  eq(t, e) {\n    if (typeof t != \"string\")\n      throw new Error(\"The first argument to `q.eq` must be a field name.\");\n    return new R({\n      $eq: [\n        pe(new R({ $field: t })),\n        pe(e)\n      ]\n    });\n  },\n  //  Logic  ///////////////////////////////////////////////////////////////////\n  or(...t) {\n    return new R({ $or: t.map(pe) });\n  }\n};\n\n// node_modules/convex/dist/esm/server/impl/authentication_impl.js\nfunction Q(t) {\n  return {\n    getUserIdentity: /* @__PURE__ */ n(async () => await f(\"1.0/getUserIdentity\", {\n      requestId: t\n    }), \"getUserIdentity\")\n  };\n}\nn(Q, \"setupAuth\");\n\n// node_modules/convex/dist/esm/server/filter_builder.js\nvar Ir = Object.defineProperty, Sr = /* @__PURE__ */ n((t, e, r) => e in t ? Ir(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), yt = /* @__PURE__ */ n((t, e, r) => Sr(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), de = class {\n  static {\n    n(this, \"Expression\");\n  }\n  /**\n   * @internal\n   */\n  constructor() {\n    yt(this, \"_isExpression\"), yt(this, \"_value\");\n  }\n};\n\n// node_modules/convex/dist/esm/server/impl/filter_builder_impl.js\nvar Or = Object.defineProperty, Tr = /* @__PURE__ */ n((t, e, r) => e in t ? Or(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), _r = /* @__PURE__ */ n((t, e, r) => Tr(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), x = class extends de {\n  static {\n    n(this, \"ExpressionImpl\");\n  }\n  constructor(e) {\n    super(), _r(this, \"inner\"), this.inner = e;\n  }\n  serialize() {\n    return this.inner;\n  }\n};\nfunction p(t) {\n  return t instanceof x ? t.serialize() : { $literal: v(t) };\n}\nn(p, \"serializeExpression\");\nvar wt = {\n  //  Comparisons  /////////////////////////////////////////////////////////////\n  eq(t, e) {\n    return new x({\n      $eq: [p(t), p(e)]\n    });\n  },\n  neq(t, e) {\n    return new x({\n      $neq: [p(t), p(e)]\n    });\n  },\n  lt(t, e) {\n    return new x({\n      $lt: [p(t), p(e)]\n    });\n  },\n  lte(t, e) {\n    return new x({\n      $lte: [p(t), p(e)]\n    });\n  },\n  gt(t, e) {\n    return new x({\n      $gt: [p(t), p(e)]\n    });\n  },\n  gte(t, e) {\n    return new x({\n      $gte: [p(t), p(e)]\n    });\n  },\n  //  Arithmetic  //////////////////////////////////////////////////////////////\n  add(t, e) {\n    return new x({\n      $add: [p(t), p(e)]\n    });\n  },\n  sub(t, e) {\n    return new x({\n      $sub: [p(t), p(e)]\n    });\n  },\n  mul(t, e) {\n    return new x({\n      $mul: [p(t), p(e)]\n    });\n  },\n  div(t, e) {\n    return new x({\n      $div: [p(t), p(e)]\n    });\n  },\n  mod(t, e) {\n    return new x({\n      $mod: [p(t), p(e)]\n    });\n  },\n  neg(t) {\n    return new x({ $neg: p(t) });\n  },\n  //  Logic  ///////////////////////////////////////////////////////////////////\n  and(...t) {\n    return new x({ $and: t.map(p) });\n  },\n  or(...t) {\n    return new x({ $or: t.map(p) });\n  },\n  not(t) {\n    return new x({ $not: p(t) });\n  },\n  //  Other  ///////////////////////////////////////////////////////////////////\n  field(t) {\n    return new x({ $field: t });\n  }\n};\n\n// node_modules/convex/dist/esm/server/index_range_builder.js\nvar Cr = Object.defineProperty, $r = /* @__PURE__ */ n((t, e, r) => e in t ? Cr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), Nr = /* @__PURE__ */ n((t, e, r) => $r(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), he = class {\n  static {\n    n(this, \"IndexRange\");\n  }\n  /**\n   * @internal\n   */\n  constructor() {\n    Nr(this, \"_isIndexRange\");\n  }\n};\n\n// node_modules/convex/dist/esm/server/impl/index_range_builder_impl.js\nvar Pr = Object.defineProperty, Fr = /* @__PURE__ */ n((t, e, r) => e in t ? Pr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), xt = /* @__PURE__ */ n((t, e, r) => Fr(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), me = class t extends he {\n  static {\n    n(this, \"IndexRangeBuilderImpl\");\n  }\n  constructor(e) {\n    super(), xt(this, \"rangeExpressions\"), xt(this, \"isConsumed\"), this.rangeExpressions = e, this.isConsumed = !1;\n  }\n  static new() {\n    return new t([]);\n  }\n  consume() {\n    if (this.isConsumed)\n      throw new Error(\n        \"IndexRangeBuilder has already been used! Chain your method calls like `q => q.eq(...).eq(...)`. See https://docs.convex.dev/using/indexes\"\n      );\n    this.isConsumed = !0;\n  }\n  eq(e, r) {\n    return this.consume(), new t(\n      this.rangeExpressions.concat({\n        type: \"Eq\",\n        fieldPath: e,\n        value: v(r)\n      })\n    );\n  }\n  gt(e, r) {\n    return this.consume(), new t(\n      this.rangeExpressions.concat({\n        type: \"Gt\",\n        fieldPath: e,\n        value: v(r)\n      })\n    );\n  }\n  gte(e, r) {\n    return this.consume(), new t(\n      this.rangeExpressions.concat({\n        type: \"Gte\",\n        fieldPath: e,\n        value: v(r)\n      })\n    );\n  }\n  lt(e, r) {\n    return this.consume(), new t(\n      this.rangeExpressions.concat({\n        type: \"Lt\",\n        fieldPath: e,\n        value: v(r)\n      })\n    );\n  }\n  lte(e, r) {\n    return this.consume(), new t(\n      this.rangeExpressions.concat({\n        type: \"Lte\",\n        fieldPath: e,\n        value: v(r)\n      })\n    );\n  }\n  export() {\n    return this.consume(), this.rangeExpressions;\n  }\n};\n\n// node_modules/convex/dist/esm/server/search_filter_builder.js\nvar Rr = Object.defineProperty, qr = /* @__PURE__ */ n((t, e, r) => e in t ? Rr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), Br = /* @__PURE__ */ n((t, e, r) => qr(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), ye = class {\n  static {\n    n(this, \"SearchFilter\");\n  }\n  /**\n   * @internal\n   */\n  constructor() {\n    Br(this, \"_isSearchFilter\");\n  }\n};\n\n// node_modules/convex/dist/esm/server/impl/search_filter_builder_impl.js\nvar jr = Object.defineProperty, Mr = /* @__PURE__ */ n((t, e, r) => e in t ? jr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), gt = /* @__PURE__ */ n((t, e, r) => Mr(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), we = class t extends ye {\n  static {\n    n(this, \"SearchFilterBuilderImpl\");\n  }\n  constructor(e) {\n    super(), gt(this, \"filters\"), gt(this, \"isConsumed\"), this.filters = e, this.isConsumed = !1;\n  }\n  static new() {\n    return new t([]);\n  }\n  consume() {\n    if (this.isConsumed)\n      throw new Error(\n        \"SearchFilterBuilder has already been used! Chain your method calls like `q => q.search(...).eq(...)`.\"\n      );\n    this.isConsumed = !0;\n  }\n  search(e, r) {\n    return l(e, 1, \"search\", \"fieldName\"), l(r, 2, \"search\", \"query\"), this.consume(), new t(\n      this.filters.concat({\n        type: \"Search\",\n        fieldPath: e,\n        value: r\n      })\n    );\n  }\n  eq(e, r) {\n    return l(e, 1, \"eq\", \"fieldName\"), arguments.length !== 2 && l(r, 2, \"search\", \"value\"), this.consume(), new t(\n      this.filters.concat({\n        type: \"Eq\",\n        fieldPath: e,\n        value: v(r)\n      })\n    );\n  }\n  export() {\n    return this.consume(), this.filters;\n  }\n};\n\n// node_modules/convex/dist/esm/server/impl/query_impl.js\nvar Ur = Object.defineProperty, Jr = /* @__PURE__ */ n((t, e, r) => e in t ? Ur(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), Je = /* @__PURE__ */ n((t, e, r) => Jr(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), bt = 256, q = class {\n  static {\n    n(this, \"QueryInitializerImpl\");\n  }\n  constructor(e) {\n    Je(this, \"tableName\"), this.tableName = e;\n  }\n  withIndex(e, r) {\n    l(e, 1, \"withIndex\", \"indexName\");\n    let o = me.new();\n    return r !== void 0 && (o = r(o)), new N({\n      source: {\n        type: \"IndexRange\",\n        indexName: this.tableName + \".\" + e,\n        range: o.export(),\n        order: null\n      },\n      operators: []\n    });\n  }\n  withSearchIndex(e, r) {\n    l(e, 1, \"withSearchIndex\", \"indexName\"), l(r, 2, \"withSearchIndex\", \"searchFilter\");\n    let o = we.new();\n    return new N({\n      source: {\n        type: \"Search\",\n        indexName: this.tableName + \".\" + e,\n        filters: r(o).export()\n      },\n      operators: []\n    });\n  }\n  fullTableScan() {\n    return new N({\n      source: {\n        type: \"FullTableScan\",\n        tableName: this.tableName,\n        order: null\n      },\n      operators: []\n    });\n  }\n  order(e) {\n    return this.fullTableScan().order(e);\n  }\n  // This is internal API and should not be exposed to developers yet.\n  async count() {\n    let e = await f(\"1.0/count\", {\n      table: this.tableName\n    });\n    return y(e);\n  }\n  filter(e) {\n    return this.fullTableScan().filter(e);\n  }\n  limit(e) {\n    return this.fullTableScan().limit(e);\n  }\n  collect() {\n    return this.fullTableScan().collect();\n  }\n  take(e) {\n    return this.fullTableScan().take(e);\n  }\n  paginate(e) {\n    return this.fullTableScan().paginate(e);\n  }\n  first() {\n    return this.fullTableScan().first();\n  }\n  unique() {\n    return this.fullTableScan().unique();\n  }\n  [Symbol.asyncIterator]() {\n    return this.fullTableScan()[Symbol.asyncIterator]();\n  }\n};\nfunction vt(t) {\n  throw new Error(\n    t === \"consumed\" ? \"This query is closed and can't emit any more values.\" : \"This query has been chained with another operator and can't be reused.\"\n  );\n}\nn(vt, \"throwClosedError\");\nvar N = class t {\n  static {\n    n(this, \"QueryImpl\");\n  }\n  constructor(e) {\n    Je(this, \"state\"), Je(this, \"tableNameForErrorMessages\"), this.state = { type: \"preparing\", query: e }, e.source.type === \"FullTableScan\" ? this.tableNameForErrorMessages = e.source.tableName : this.tableNameForErrorMessages = e.source.indexName.split(\".\")[0];\n  }\n  takeQuery() {\n    if (this.state.type !== \"preparing\")\n      throw new Error(\n        \"A query can only be chained once and can't be chained after iteration begins.\"\n      );\n    let e = this.state.query;\n    return this.state = { type: \"closed\" }, e;\n  }\n  startQuery() {\n    if (this.state.type === \"executing\")\n      throw new Error(\"Iteration can only begin on a query once.\");\n    (this.state.type === \"closed\" || this.state.type === \"consumed\") && vt(this.state.type);\n    let e = this.state.query, { queryId: r } = D(\"1.0/queryStream\", { query: e, version: w });\n    return this.state = { type: \"executing\", queryId: r }, r;\n  }\n  closeQuery() {\n    if (this.state.type === \"executing\") {\n      let e = this.state.queryId;\n      D(\"1.0/queryCleanup\", { queryId: e });\n    }\n    this.state = { type: \"consumed\" };\n  }\n  order(e) {\n    l(e, 1, \"order\", \"order\");\n    let r = this.takeQuery();\n    if (r.source.type === \"Search\")\n      throw new Error(\n        \"Search queries must always be in relevance order. Can not set order manually.\"\n      );\n    if (r.source.order !== null)\n      throw new Error(\"Queries may only specify order at most once\");\n    return r.source.order = e, new t(r);\n  }\n  filter(e) {\n    l(e, 1, \"filter\", \"predicate\");\n    let r = this.takeQuery();\n    if (r.operators.length >= bt)\n      throw new Error(\n        `Can't construct query with more than ${bt} operators`\n      );\n    return r.operators.push({\n      filter: p(e(wt))\n    }), new t(r);\n  }\n  limit(e) {\n    l(e, 1, \"limit\", \"n\");\n    let r = this.takeQuery();\n    return r.operators.push({ limit: e }), new t(r);\n  }\n  [Symbol.asyncIterator]() {\n    return this.startQuery(), this;\n  }\n  async next() {\n    (this.state.type === \"closed\" || this.state.type === \"consumed\") && vt(this.state.type);\n    let e = this.state.type === \"preparing\" ? this.startQuery() : this.state.queryId, { value: r, done: o } = await f(\"1.0/queryStreamNext\", {\n      queryId: e\n    });\n    return o && this.closeQuery(), { value: y(r), done: o };\n  }\n  return() {\n    return this.closeQuery(), Promise.resolve({ done: !0, value: void 0 });\n  }\n  async paginate(e) {\n    if (l(e, 1, \"paginate\", \"options\"), typeof e?.numItems != \"number\" || e.numItems < 0)\n      throw new Error(\n        `\\`options.numItems\\` must be a positive number. Received \\`${e?.numItems}\\`.`\n      );\n    let r = this.takeQuery(), o = e.numItems, s = e.cursor, i = e?.endCursor ?? null, a = e.maximumRowsRead ?? null, { page: c, isDone: d, continueCursor: O, splitCursor: be, pageStatus: ve } = await f(\"1.0/queryPage\", {\n      query: r,\n      cursor: s,\n      endCursor: i,\n      pageSize: o,\n      maximumRowsRead: a,\n      maximumBytesRead: e.maximumBytesRead,\n      version: w\n    });\n    return {\n      page: c.map((Ft) => y(Ft)),\n      isDone: d,\n      continueCursor: O,\n      splitCursor: be,\n      pageStatus: ve\n    };\n  }\n  async collect() {\n    let e = [];\n    for await (let r of this)\n      e.push(r);\n    return e;\n  }\n  async take(e) {\n    return l(e, 1, \"take\", \"n\"), mt(e, 1, \"take\", \"n\"), this.limit(e).collect();\n  }\n  async first() {\n    let e = await this.take(1);\n    return e.length === 0 ? null : e[0];\n  }\n  async unique() {\n    let e = await this.take(2);\n    if (e.length === 0)\n      return null;\n    if (e.length === 2)\n      throw new Error(`unique() query returned more than one result from table ${this.tableNameForErrorMessages}:\n [${e[0]._id}, ${e[1]._id}, ...]`);\n    return e[0];\n  }\n};\n\n// node_modules/convex/dist/esm/server/impl/database_impl.js\nasync function Ve(t, e, r) {\n  if (l(e, 1, \"get\", \"id\"), typeof e != \"string\")\n    throw new Error(\n      `Invalid argument \\`id\\` for \\`db.get\\`, expected string but got '${typeof e}': ${e}`\n    );\n  let o = {\n    id: h(e),\n    isSystem: r,\n    version: w,\n    table: t\n  }, s = await f(\"1.0/get\", o);\n  return y(s);\n}\nn(Ve, \"get\");\nfunction He() {\n  let t = /* @__PURE__ */ n((s = !1) => ({\n    get: /* @__PURE__ */ n(async (i, a) => a !== void 0 ? await Ve(i, a, s) : await Ve(void 0, i, s), \"get\"),\n    query: /* @__PURE__ */ n((i) => new H(i, s).query(), \"query\"),\n    normalizeId: /* @__PURE__ */ n((i, a) => {\n      l(i, 1, \"normalizeId\", \"tableName\"), l(a, 2, \"normalizeId\", \"id\");\n      let c = i.startsWith(\"_\");\n      if (c !== s)\n        throw new Error(\n          `${c ? \"System\" : \"User\"} tables can only be accessed from db.${s ? \"\" : \"system.\"}normalizeId().`\n        );\n      let d = D(\"1.0/db/normalizeId\", {\n        table: i,\n        idString: a\n      });\n      return y(d).id;\n    }, \"normalizeId\"),\n    // We set the system reader on the next line\n    system: null,\n    table: /* @__PURE__ */ n((i) => new H(i, s), \"table\")\n  }), \"reader\"), { system: e, ...r } = t(!0), o = t();\n  return o.system = r, o;\n}\nn(He, \"setupReader\");\nasync function At(t, e) {\n  if (t.startsWith(\"_\"))\n    throw new Error(\"System tables (prefixed with `_`) are read-only.\");\n  l(t, 1, \"insert\", \"table\"), l(e, 2, \"insert\", \"value\");\n  let r = await f(\"1.0/insert\", {\n    table: t,\n    value: h(e)\n  });\n  return y(r)._id;\n}\nn(At, \"insert\");\nasync function Le(t, e, r) {\n  l(e, 1, \"patch\", \"id\"), l(r, 2, \"patch\", \"value\"), await f(\"1.0/shallowMerge\", {\n    id: h(e),\n    value: at(r),\n    table: t\n  });\n}\nn(Le, \"patch\");\nasync function ke(t, e, r) {\n  l(e, 1, \"replace\", \"id\"), l(r, 2, \"replace\", \"value\"), await f(\"1.0/replace\", {\n    id: h(e),\n    value: h(r),\n    table: t\n  });\n}\nn(ke, \"replace\");\nasync function De(t, e) {\n  l(e, 1, \"delete\", \"id\"), await f(\"1.0/remove\", {\n    id: h(e),\n    table: t\n  });\n}\nn(De, \"delete_\");\nfunction Et() {\n  let t = He();\n  return {\n    get: t.get,\n    query: t.query,\n    normalizeId: t.normalizeId,\n    system: t.system,\n    insert: /* @__PURE__ */ n(async (e, r) => await At(e, r), \"insert\"),\n    patch: /* @__PURE__ */ n(async (e, r, o) => o !== void 0 ? await Le(e, r, o) : await Le(void 0, e, r), \"patch\"),\n    replace: /* @__PURE__ */ n(async (e, r, o) => o !== void 0 ? await ke(e, r, o) : await ke(void 0, e, r), \"replace\"),\n    delete: /* @__PURE__ */ n(async (e, r) => r !== void 0 ? await De(e, r) : await De(void 0, e), \"delete\"),\n    table: /* @__PURE__ */ n((e) => new Qe(e, !1), \"table\")\n  };\n}\nn(Et, \"setupWriter\");\nvar H = class {\n  static {\n    n(this, \"TableReader\");\n  }\n  constructor(e, r) {\n    this.tableName = e, this.isSystem = r;\n  }\n  async get(e) {\n    return Ve(this.tableName, e, this.isSystem);\n  }\n  query() {\n    let e = this.tableName.startsWith(\"_\");\n    if (e !== this.isSystem)\n      throw new Error(\n        `${e ? \"System\" : \"User\"} tables can only be accessed from db.${this.isSystem ? \"\" : \"system.\"}query().`\n      );\n    return new q(this.tableName);\n  }\n}, Qe = class extends H {\n  static {\n    n(this, \"TableWriter\");\n  }\n  async insert(e) {\n    return At(this.tableName, e);\n  }\n  async patch(e, r) {\n    return Le(this.tableName, e, r);\n  }\n  async replace(e, r) {\n    return ke(this.tableName, e, r);\n  }\n  async delete(e) {\n    return De(this.tableName, e);\n  }\n};\n\n// node_modules/convex/dist/esm/server/impl/scheduler_impl.js\nfunction It() {\n  return {\n    runAfter: /* @__PURE__ */ n(async (t, e, r) => {\n      let o = St(t, e, r);\n      return await f(\"1.0/schedule\", o);\n    }, \"runAfter\"),\n    runAt: /* @__PURE__ */ n(async (t, e, r) => {\n      let o = Ot(\n        t,\n        e,\n        r\n      );\n      return await f(\"1.0/schedule\", o);\n    }, \"runAt\"),\n    cancel: /* @__PURE__ */ n(async (t) => {\n      l(t, 1, \"cancel\", \"id\");\n      let e = { id: h(t) };\n      await f(\"1.0/cancel_job\", e);\n    }, \"cancel\")\n  };\n}\nn(It, \"setupMutationScheduler\");\nfunction Ge(t) {\n  return {\n    runAfter: /* @__PURE__ */ n(async (e, r, o) => {\n      let s = {\n        requestId: t,\n        ...St(e, r, o)\n      };\n      return await f(\"1.0/actions/schedule\", s);\n    }, \"runAfter\"),\n    runAt: /* @__PURE__ */ n(async (e, r, o) => {\n      let s = {\n        requestId: t,\n        ...Ot(e, r, o)\n      };\n      return await f(\"1.0/actions/schedule\", s);\n    }, \"runAt\"),\n    cancel: /* @__PURE__ */ n(async (e) => {\n      l(e, 1, \"cancel\", \"id\");\n      let r = { id: h(e) };\n      return await f(\"1.0/actions/cancel_job\", r);\n    }, \"cancel\")\n  };\n}\nn(Ge, \"setupActionScheduler\");\nfunction St(t, e, r) {\n  if (typeof t != \"number\")\n    throw new Error(\"`delayMs` must be a number\");\n  if (!isFinite(t))\n    throw new Error(\"`delayMs` must be a finite number\");\n  if (t < 0)\n    throw new Error(\"`delayMs` must be non-negative\");\n  let o = S(r), s = A(e), i = (Date.now() + t) / 1e3;\n  return {\n    ...s,\n    ts: i,\n    args: h(o),\n    version: w\n  };\n}\nn(St, \"runAfterSyscallArgs\");\nfunction Ot(t, e, r) {\n  let o;\n  if (t instanceof Date)\n    o = t.valueOf() / 1e3;\n  else if (typeof t == \"number\")\n    o = t / 1e3;\n  else\n    throw new Error(\"The invoke time must a Date or a timestamp\");\n  let s = A(e), i = S(r);\n  return {\n    ...s,\n    ts: o,\n    args: h(i),\n    version: w\n  };\n}\nn(Ot, \"runAtSyscallArgs\");\n\n// node_modules/convex/dist/esm/server/impl/storage_impl.js\nfunction We(t) {\n  return {\n    getUrl: /* @__PURE__ */ n(async (e) => (l(e, 1, \"getUrl\", \"storageId\"), await f(\"1.0/storageGetUrl\", {\n      requestId: t,\n      version: w,\n      storageId: e\n    })), \"getUrl\"),\n    getMetadata: /* @__PURE__ */ n(async (e) => await f(\"1.0/storageGetMetadata\", {\n      requestId: t,\n      version: w,\n      storageId: e\n    }), \"getMetadata\")\n  };\n}\nn(We, \"setupStorageReader\");\nfunction ze(t) {\n  let e = We(t);\n  return {\n    generateUploadUrl: /* @__PURE__ */ n(async () => await f(\"1.0/storageGenerateUploadUrl\", {\n      requestId: t,\n      version: w\n    }), \"generateUploadUrl\"),\n    delete: /* @__PURE__ */ n(async (r) => {\n      await f(\"1.0/storageDelete\", {\n        requestId: t,\n        version: w,\n        storageId: r\n      });\n    }, \"delete\"),\n    getUrl: e.getUrl,\n    getMetadata: e.getMetadata\n  };\n}\nn(ze, \"setupStorageWriter\");\nfunction Xe(t) {\n  return {\n    ...ze(t),\n    store: /* @__PURE__ */ n(async (r, o) => await C(\"storage/storeBlob\", {\n      requestId: t,\n      version: w,\n      blob: r,\n      options: o\n    }), \"store\"),\n    get: /* @__PURE__ */ n(async (r) => await C(\"storage/getBlob\", {\n      requestId: t,\n      version: w,\n      storageId: r\n    }), \"get\")\n  };\n}\nn(Xe, \"setupStorageActionWriter\");\n\n// node_modules/convex/dist/esm/server/impl/registration_impl.js\nasync function Tt(t, e) {\n  let o = y(JSON.parse(e)), s = {\n    db: Et(),\n    auth: Q(\"\"),\n    storage: ze(\"\"),\n    scheduler: It(),\n    runQuery: /* @__PURE__ */ n((a, c) => Ye(\"query\", a, c), \"runQuery\"),\n    runMutation: /* @__PURE__ */ n((a, c) => Ye(\"mutation\", a, c), \"runMutation\")\n  }, i = await xe(t, s, o);\n  return _t(i), JSON.stringify(h(i === void 0 ? null : i));\n}\nn(Tt, \"invokeMutation\");\nfunction _t(t) {\n  if (t instanceof q || t instanceof N)\n    throw new Error(\n      \"Return value is a Query. Results must be retrieved with `.collect()`, `.take(n), `.unique()`, or `.first()`.\"\n    );\n}\nn(_t, \"validateReturnValue\");\nasync function xe(t, e, r) {\n  let o;\n  try {\n    o = await Promise.resolve(t(e, ...r));\n  } catch (s) {\n    throw Vr(s);\n  }\n  return o;\n}\nn(xe, \"invokeFunction\");\nfunction B(t, e) {\n  return (r, o) => (globalThis.console.warn(\n    `Convex functions should not directly call other Convex functions. Consider calling a helper function instead. e.g. \\`export const foo = ${t}(...); await foo(ctx);\\` is not supported. See https://docs.convex.dev/production/best-practices/#use-helper-functions-to-write-shared-code`\n  ), e(r, o));\n}\nn(B, \"dontCallDirectly\");\nfunction Vr(t) {\n  if (typeof t == \"object\" && t !== null && Symbol.for(\"ConvexError\") in t) {\n    let e = t;\n    return e.data = JSON.stringify(\n      h(e.data === void 0 ? null : e.data)\n    ), e.ConvexErrorSymbol = Symbol.for(\"ConvexError\"), e;\n  } else\n    return t;\n}\nn(Vr, \"serializeConvexErrorData\");\nfunction j() {\n  if (typeof window > \"u\" || window.__convexAllowFunctionsInBrowser)\n    return;\n  (Object.getOwnPropertyDescriptor(globalThis, \"window\")?.get?.toString().includes(\"[native code]\") ?? !1) && console.error(\n    \"Convex functions should not be imported in the browser. This will throw an error in future versions of `convex`. If this is a false negative, please report it to Convex support.\"\n  );\n}\nn(j, \"assertNotBrowser\");\nfunction Ct(t, e) {\n  if (e === void 0)\n    throw new Error(\n      `A validator is undefined for field \"${t}\". This is often caused by circular imports. See https://docs.convex.dev/error#undefined-validator for details.`\n    );\n  return e;\n}\nn(Ct, \"strictReplacer\");\nfunction G(t) {\n  return () => {\n    let e = u.any();\n    return typeof t == \"object\" && t.args !== void 0 && (e = ae(t.args)), JSON.stringify(e.json, Ct);\n  };\n}\nn(G, \"exportArgs\");\nfunction W(t) {\n  return () => {\n    let e;\n    return typeof t == \"object\" && t.returns !== void 0 && (e = ae(t.returns)), JSON.stringify(e ? e.json : null, Ct);\n  };\n}\nn(W, \"exportReturns\");\nvar Lr = /* @__PURE__ */ n(((t) => {\n  let e = typeof t == \"function\" ? t : t.handler, r = B(\"mutation\", e);\n  return j(), r.isMutation = !0, r.isPublic = !0, r.invokeMutation = (o) => Tt(e, o), r.exportArgs = G(t), r.exportReturns = W(t), r._handler = e, r;\n}), \"mutationGeneric\"), kr = /* @__PURE__ */ n(((t) => {\n  let e = typeof t == \"function\" ? t : t.handler, r = B(\n    \"internalMutation\",\n    e\n  );\n  return j(), r.isMutation = !0, r.isInternal = !0, r.invokeMutation = (o) => Tt(e, o), r.exportArgs = G(t), r.exportReturns = W(t), r._handler = e, r;\n}), \"internalMutationGeneric\");\nasync function Dr(t, e) {\n  let o = y(JSON.parse(e)), s = {\n    db: He(),\n    auth: Q(\"\"),\n    storage: We(\"\"),\n    runQuery: /* @__PURE__ */ n((a, c) => Ye(\"query\", a, c), \"runQuery\")\n  }, i = await xe(t, s, o);\n  return _t(i), JSON.stringify(h(i === void 0 ? null : i));\n}\nn(Dr, \"invokeQuery\");\nvar Qr = /* @__PURE__ */ n(((t) => {\n  let e = typeof t == \"function\" ? t : t.handler, r = B(\"query\", e);\n  return j(), r.isQuery = !0, r.isPublic = !0, r.invokeQuery = (o) => Dr(e, o), r.exportArgs = G(t), r.exportReturns = W(t), r._handler = e, r;\n}), \"queryGeneric\");\nasync function $t(t, e, r) {\n  let o = y(JSON.parse(r)), i = {\n    ...Be(e),\n    auth: Q(e),\n    scheduler: Ge(e),\n    storage: Xe(e),\n    vectorSearch: Ue(e)\n  }, a = await xe(t, i, o);\n  return JSON.stringify(h(a === void 0 ? null : a));\n}\nn($t, \"invokeAction\");\nvar Hr = /* @__PURE__ */ n(((t) => {\n  let e = typeof t == \"function\" ? t : t.handler, r = B(\"action\", e);\n  return j(), r.isAction = !0, r.isPublic = !0, r.invokeAction = (o, s) => $t(e, o, s), r.exportArgs = G(t), r.exportReturns = W(t), r._handler = e, r;\n}), \"actionGeneric\"), Gr = /* @__PURE__ */ n(((t) => {\n  let e = typeof t == \"function\" ? t : t.handler, r = B(\"internalAction\", e);\n  return j(), r.isAction = !0, r.isInternal = !0, r.invokeAction = (o, s) => $t(e, o, s), r.exportArgs = G(t), r.exportReturns = W(t), r._handler = e, r;\n}), \"internalActionGeneric\");\nasync function Wr(t, e) {\n  let s = {\n    ...Be(\"\"),\n    auth: Q(\"\"),\n    storage: Xe(\"\"),\n    scheduler: Ge(\"\"),\n    vectorSearch: Ue(\"\")\n  };\n  return await xe(t, s, [e]);\n}\nn(Wr, \"invokeHttpAction\");\nvar zr = /* @__PURE__ */ n((t) => {\n  let e = B(\"httpAction\", t);\n  return j(), e.isHttp = !0, e.invokeHttpAction = (r) => Wr(t, r), e._handler = t, e;\n}, \"httpActionGeneric\");\nasync function Ye(t, e, r) {\n  let o = S(r), s = {\n    udfType: t,\n    args: h(o),\n    ...A(e)\n  }, i = await f(\"1.0/runUdf\", s);\n  return y(i);\n}\nn(Ye, \"runUdf\");\n\n// node_modules/convex/dist/esm/server/pagination.js\nvar Ps = u.object({\n  numItems: u.number(),\n  cursor: u.union(u.string(), u.null()),\n  endCursor: u.optional(u.union(u.string(), u.null())),\n  id: u.optional(u.number()),\n  maximumRowsRead: u.optional(u.number()),\n  maximumBytesRead: u.optional(u.number())\n});\n\n// node_modules/convex/dist/esm/server/components/index.js\nfunction Nt(t, e) {\n  let r = {\n    get(o, s) {\n      if (typeof s == \"string\") {\n        let i = [...e, s];\n        return Nt(t, i);\n      } else if (s === $e) {\n        if (e.length < 1) {\n          let i = [t, ...e].join(\".\");\n          throw new Error(\n            `API path is expected to be of the form \\`${t}.childComponent.functionName\\`. Found: \\`${i}\\``\n          );\n        }\n        return \"_reference/childComponent/\" + e.join(\"/\");\n      } else\n        return;\n    }\n  };\n  return new Proxy({}, r);\n}\nn(Nt, \"createChildComponents\");\nvar Xr = /* @__PURE__ */ n(() => Nt(\"components\", []), \"componentsGeneric\");\n\n// node_modules/convex/dist/esm/server/schema.js\nvar Yr = Object.defineProperty, Kr = /* @__PURE__ */ n((t, e, r) => e in t ? Yr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, \"__defNormalProp\"), I = /* @__PURE__ */ n((t, e, r) => Kr(t, typeof e != \"symbol\" ? e + \"\" : e, r), \"__publicField\"), ge = class {\n  static {\n    n(this, \"TableDefinition\");\n  }\n  /**\n   * @internal\n   */\n  constructor(e) {\n    I(this, \"indexes\"), I(this, \"stagedDbIndexes\"), I(this, \"searchIndexes\"), I(this, \"stagedSearchIndexes\"), I(this, \"vectorIndexes\"), I(this, \"stagedVectorIndexes\"), I(this, \"validator\"), this.indexes = [], this.stagedDbIndexes = [], this.searchIndexes = [], this.stagedSearchIndexes = [], this.vectorIndexes = [], this.stagedVectorIndexes = [], this.validator = e;\n  }\n  /**\n   * This API is experimental: it may change or disappear.\n   *\n   * Returns indexes defined on this table.\n   * Intended for the advanced use cases of dynamically deciding which index to use for a query.\n   * If you think you need this, please chime in on ths issue in the Convex JS GitHub repo.\n   * https://github.com/get-convex/convex-js/issues/49\n   */\n  \" indexes\"() {\n    return this.indexes;\n  }\n  index(e, r) {\n    return Array.isArray(r) ? this.indexes.push({\n      indexDescriptor: e,\n      fields: r\n    }) : r.staged ? this.stagedDbIndexes.push({\n      indexDescriptor: e,\n      fields: r.fields\n    }) : this.indexes.push({\n      indexDescriptor: e,\n      fields: r.fields\n    }), this;\n  }\n  searchIndex(e, r) {\n    return r.staged ? this.stagedSearchIndexes.push({\n      indexDescriptor: e,\n      searchField: r.searchField,\n      filterFields: r.filterFields || []\n    }) : this.searchIndexes.push({\n      indexDescriptor: e,\n      searchField: r.searchField,\n      filterFields: r.filterFields || []\n    }), this;\n  }\n  vectorIndex(e, r) {\n    return r.staged ? this.stagedVectorIndexes.push({\n      indexDescriptor: e,\n      vectorField: r.vectorField,\n      dimensions: r.dimensions,\n      filterFields: r.filterFields || []\n    }) : this.vectorIndexes.push({\n      indexDescriptor: e,\n      vectorField: r.vectorField,\n      dimensions: r.dimensions,\n      filterFields: r.filterFields || []\n    }), this;\n  }\n  /**\n   * Work around for https://github.com/microsoft/TypeScript/issues/57035\n   */\n  self() {\n    return this;\n  }\n  /**\n   * Export the contents of this definition.\n   *\n   * This is called internally by the Convex framework.\n   * @internal\n   */\n  export() {\n    let e = this.validator.json;\n    if (typeof e != \"object\")\n      throw new Error(\n        \"Invalid validator: please make sure that the parameter of `defineTable` is valid (see https://docs.convex.dev/database/schemas)\"\n      );\n    return {\n      indexes: this.indexes,\n      stagedDbIndexes: this.stagedDbIndexes,\n      searchIndexes: this.searchIndexes,\n      stagedSearchIndexes: this.stagedSearchIndexes,\n      vectorIndexes: this.vectorIndexes,\n      stagedVectorIndexes: this.stagedVectorIndexes,\n      documentType: e\n    };\n  }\n};\nfunction Ke(t) {\n  return _e(t) ? new ge(t) : new ge(u.object(t));\n}\nn(Ke, \"defineTable\");\nvar Ze = class {\n  static {\n    n(this, \"SchemaDefinition\");\n  }\n  /**\n   * @internal\n   */\n  constructor(e, r) {\n    I(this, \"tables\"), I(this, \"strictTableNameTypes\"), I(this, \"schemaValidation\"), this.tables = e, this.schemaValidation = r?.schemaValidation === void 0 ? !0 : r.schemaValidation;\n  }\n  /**\n   * Export the contents of this definition.\n   *\n   * This is called internally by the Convex framework.\n   * @internal\n   */\n  export() {\n    return JSON.stringify({\n      tables: Object.entries(this.tables).map(([e, r]) => {\n        let {\n          indexes: o,\n          stagedDbIndexes: s,\n          searchIndexes: i,\n          stagedSearchIndexes: a,\n          vectorIndexes: c,\n          stagedVectorIndexes: d,\n          documentType: O\n        } = r.export();\n        return {\n          tableName: e,\n          indexes: o,\n          stagedDbIndexes: s,\n          searchIndexes: i,\n          stagedSearchIndexes: a,\n          vectorIndexes: c,\n          stagedVectorIndexes: d,\n          documentType: O\n        };\n      }),\n      schemaValidation: this.schemaValidation\n    });\n  }\n};\nfunction Pt(t, e) {\n  return new Ze(t, e);\n}\nn(Pt, \"defineSchema\");\nvar Ds = Pt({\n  _scheduled_functions: Ke({\n    name: u.string(),\n    args: u.array(u.any()),\n    scheduledTime: u.float64(),\n    completedTime: u.optional(u.float64()),\n    state: u.union(\n      u.object({ kind: u.literal(\"pending\") }),\n      u.object({ kind: u.literal(\"inProgress\") }),\n      u.object({ kind: u.literal(\"success\") }),\n      u.object({ kind: u.literal(\"failed\"), error: u.string() }),\n      u.object({ kind: u.literal(\"canceled\") })\n    )\n  }),\n  _storage: Ke({\n    sha256: u.string(),\n    size: u.float64(),\n    contentType: u.optional(u.string())\n  })\n});\n\nexport {\n  n as a,\n  Zr as b,\n  en as c,\n  tn as d,\n  u as e,\n  ue as f,\n  Lr as g,\n  kr as h,\n  Qr as i,\n  Hr as j,\n  Gr as k,\n  zr as l,\n  ar as m,\n  fr as n,\n  xr as o,\n  Xr as p\n};\n//# sourceMappingURL=Q5VBJYR5.js.map\n","environment":"isolate"},{"path":"auth.config.js","source":"// convex/auth.config.ts\nvar o = {\n  providers: [\n    {\n      domain: process.env.CONVEX_SITE_URL,\n      applicationID: \"convex\"\n    }\n  ]\n};\nexport {\n  o as default\n};\n//# sourceMappingURL=auth.config.js.map\n","environment":"isolate","sourceMap":"{\n  \"version\": 3,\n  \"sources\": [\"../convex/auth.config.ts\"],\n  \"mappings\": \";AAEA,IAAOA,IAAQ;AAAA,EACb,WAAW;AAAA,IACT;AAAA,MACE,QAAQ,QAAQ,IAAI;AAAA,MACpB,eAAe;AAAA,IACjB;AAAA,EACF;AACF;\",\n  \"names\": [\"auth_config_default\"]\n}\n"}],"nodeDependencies":[],"udfServerVersion":"1.31.5"}